                    <!DOCTYPE html>
                    <html lang="en">
                    <head>
                        <meta charset="UTF-8" />
                        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                        <title>mini Football â€“ by san :D</title>
                        <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@900&display=swap" rel="stylesheet">
                        <style>
                            :root{
                                --bg:#0b0f14;
                                --panel:#1a202c;
                                --field:#0e6f3b;
                                --line:#e2e8f0;
                                --accent:#48bb78;
                                --accent-light:#81e6d9;
                                --accent2:#f6ad55;
                                --danger:#e53e3e;
                                --kaiserA:#667eea;
                                --kaiserB:#ed64a6;
                                --glow:#ffffff;
                                --robsan-dark-primary: #312e81;
                                --robsan-dark-secondary: #4c1d95;
                                --robsan-particle-color: rgba(68, 10, 107, 0.9);
                                --robsan-particle-color-light: rgba(99, 58, 161, 0.7);
                                --robsan-trail-color-start: rgba(20, 0, 40, 0.95);
                                --robsan-trail-color-end: rgba(10, 0, 20, 0.7);
                                --robsan-charge-aura-color1: rgba(30, 0, 50, 0.7);
                                --robsan-charge-aura-color2: rgba(40, 0, 60, 0.4);
                                --robsan-shadow-enhanced: rgba(15, 0, 30, 0.8);
                                --robsan-void-enhanced: rgba(5, 0, 15, 0.9);
                                --eclipse-aura-start: rgba(0, 0, 0, 0.8);
                                --eclipse-aura-end: rgba(30, 0, 50, 0.4);
                                --eclipse-line-color: rgba(50, 0, 80, 0.9);
                                --eclipse-line-glow: rgba(100, 0, 150, 0.5);
                                --void-dash-primary: #1e1b4b;
                                --void-dash-secondary: #0c0a09;
                                --void-trail-color-start: rgba(0, 0, 0, 0.9);
                                --void-trail-color-end: rgba(50, 0, 80, 0.6);
                                --xdrake-green-primary: #10b981;
                                --xdrake-green-secondary: #059669;
                                --xdrake-dash-trail-start: rgba(16, 185, 129, 0.9);
                                --xdrake-dash-trail-end: rgba(5, 150, 105, 0.4);
                                --xdrake-footwork-color: #6d4b2e;
                                --xdrake-footwork-dust: rgba(109, 75, 46, 0.8);
                                --xdrake-apex-aura-start: rgba(0, 100, 0, 0.95);
                                --xdrake-apex-aura-end: rgba(100, 200, 100, 0.5);
                                --xdrake-apex-ball-trail-start: rgba(0, 150, 0, 0.95);
                                --xdrake-apex-ball-trail-end: rgba(0, 50, 0, 0.7);
                                --xdrake-nature-essence: rgba(34, 197, 94, 0.8);
                                --xdrake-earth-power: rgba(101, 69, 34, 0.9);
                                --gojo-red-primary: #e53e3e;
                                --gojo-red-secondary: #c53030;
                                --gojo-blue-primary: #3182ce;
                                --gojo-blue-secondary: #2c5282;
                                --gojo-purple-primary: #805ad5;
                                --gojo-purple-secondary: #553c9a;
                                --gojo-red-trail-start: rgba(229, 62, 62, 0.9);
                                --gojo-red-trail-end: rgba(197, 48, 48, 0.4);
                                --gojo-blue-trail-start: rgba(49, 130, 206, 0.9);
                                --gojo-blue-trail-end: rgba(44, 82, 130, 0.4);
                                --gojo-purple-trail-start: rgba(128, 90, 213, 0.95);
                                --gojo-purple-trail-end: rgba(85, 60, 154, 0.7);
                                --gojo-aura-color: rgba(99, 102, 241, 0.5);
                                --gojo-infinity-shimmer: rgba(255, 255, 255, 0.8);
                                --gojo-domain-energy: rgba(128, 90, 213, 0.7);
                                --eddie-primary: #1a202c;
                                --eddie-secondary: #000000;
                                --eddie-we-are-glow: rgba(255, 0, 0, 0.8);
                                --eddie-we-are-aura: rgba(20, 20, 20, 0.5);
                                --eddie-venom-strike-tendril-start: rgba(100, 0, 150, 0.9); /* Dark purple */
                                --eddie-venom-strike-tendril-end: rgba(0, 0, 0, 0.8);    /* Black */
                                --eddie-venom-strike-glow: rgba(150, 0, 200, 0.7); /* Brighter purple glow */
                                --eddie-venom-strike-trail-start: rgba(30, 0, 50, 0.9);
                                --eddie-venom-strike-trail-end: rgba(0, 0, 0, 0.6);
                                --eddie-symbiote-montage-trail: rgba(100, 0, 150, 0.7);
                                /* NEW ZEUS STYLES */
                                --zeus-primary: #3b82f6; /* Blue */
                                --zeus-secondary: #60a5fa; /* Lighter blue */
                                --zeus-lightning-trail-start: rgba(59, 130, 246, 0.9);
                                --zeus-lightning-trail-end: rgba(255, 255, 255, 0.6);
                                --zeus-shield-aura: rgba(59, 130, 246, 0.4);
                                --zeus-shield-glow: rgba(255, 255, 255, 0.7);
                                --zeus-olympus-aura-start: rgba(253, 224, 71, 0.8); /* Yellow */
                                --zeus-olympus-aura-end: rgba(59, 130, 246, 0.6); /* Blue */
                                --zeus-olympus-ball-trail-start: rgba(253, 224, 71, 0.9);
                                --zeus-olympus-ball-trail-end: rgba(255, 255, 255, 0.7);
                                /* NEW ASHER STYLES */
                                --asher-primary: #a78bfa; /* Light Purple */
                                --asher-secondary: #7c3aed; /* Darker Purple */
                                --asher-star-trail-start: rgba(233, 213, 255, 0.9); /* Light lavender */
                                --asher-star-trail-end: rgba(167, 139, 250, 0.6); /* Light purple */
                                --asher-teleport-burst: rgba(255, 255, 255, 0.9);
                                --asher-arrival-glimmer: rgba(209, 213, 219, 0.8);
                                /* NEW LEONARDO STYLES */
                                --leonardo-primary: #06b6d4; /* Cyan */
                                --leonardo-secondary: #0891b2; /* Darker Cyan */
                                --leonardo-accent: #a5f3fc; /* Light Cyan */
                                --leonardo-trail-start: rgba(6, 182, 212, 0.9);
                                --leonardo-trail-end: rgba(165, 243, 252, 0.6);
                                /* ENHANCED ANGUS STYLES */
                                --angus-primary: #ffffff; /* White */
                                --angus-secondary: #f3f4f6; /* Light Gray */
                                --angus-accent: #e5e7eb; /* Lighter Gray */
                                --angus-trail-start: rgba(255, 255, 255, 0.95);
                                --angus-trail-end: rgba(243, 244, 246, 0.7);
                                --angus-burst-color: rgba(255, 255, 255, 0.95);
                                --angus-charge-glow: rgba(255, 255, 255, 0.85);
                                --angus-time-distort: rgba(200, 200, 255, 0.6);
                                --angus-teleport-shimmer: rgba(255, 255, 255, 0.9);
                                /* NEW DIDDY STYLES */
                                --diddy-primary: #8B4513; /* Saddle Brown */
                                --diddy-secondary: #A0522D; /* Sienna */
                                --diddy-accent: #CD853F; /* Peru */
                                --diddy-oil-color: #FFD700; /* Gold */
                                --diddy-oil-shimmer: rgba(255, 215, 0, 0.8);
                                --diddy-ascension-glow: rgba(255, 215, 0, 0.9);
                                --diddy-trail-start: rgba(139, 69, 19, 0.9);
                                --diddy-trail-end: rgba(160, 82, 45, 0.6);
                                --baby-oil-guy-subtitle-bg: rgba(0, 0, 0, 0.8);
                                --baby-oil-guy-subtitle-text: #FFD700;
                                /* EDDIE AWAKENING STYLES */
                                --eddie-awakening-bg: #1e3a8a; /* Blue background */
                                --eddie-awakening-fill: #22c55e; /* Green fill */
                                --eddie-awakening-glow: rgba(0, 0, 0, 0.9); /* Black glow for awakened state */
                                --eddie-awakening-aura: rgba(0, 0, 0, 0.8); /* Black aura */
                                /* CRISTIANO STYLES */
                                --cristiano-primary: #dc2626; /* Red */
                                --cristiano-secondary: #16a34a; /* Green */
                                --cristiano-accent: #fbbf24; /* Gold accent */
                                --cristiano-power-shot-trail-start: rgba(255, 50, 50, 0.95);
                                --cristiano-power-shot-trail-end: rgba(255, 215, 0, 0.8);
                                --cristiano-tackle-burst: rgba(255, 215, 0, 0.95);
                                --cristiano-spirit-aura-start: rgba(255, 50, 50, 0.9);
                                --cristiano-spirit-aura-end: rgba(22, 163, 74, 0.8);
                                --cristiano-trail-start: rgba(255, 50, 50, 0.95);
                                --cristiano-trail-end: rgba(255, 215, 0, 0.8);
                                --cristiano-power-glow: rgba(255, 215, 0, 0.9);
                                --cristiano-shot-explosion: rgba(255, 100, 100, 0.95);
                                /* HUDSON EMPEROR STYLES */
                                --hudson-primary: #e91e63; /* Pink */
                                --hudson-secondary: #3f51b5; /* Blue */
                                --hudson-emperor-pink: rgba(233, 30, 99, 0.9);
                                --hudson-emperor-blue: rgba(63, 81, 181, 0.9);
                                --hudson-emperor-trail-start: rgba(233, 30, 99, 0.95);
                                --hudson-emperor-trail-end: rgba(63, 81, 181, 0.7);
                                --hudson-emperor-aura: rgba(200, 50, 150, 0.6);
                                --hudson-emperor-glow: rgba(150, 100, 200, 0.8);
                            }
                            *{box-sizing:border-box}
                            html,body{height:100%}
                            body{
                                margin:0;
                                display:flex;
                                align-items:center;
                                justify-content:center;
                                flex-direction:column;
                                background:radial-gradient(1000px 500px at 50% -10%, #1a202c 0%, var(--bg) 60%);
                                color:var(--line);
                                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                                font-weight: 500;
                                text-shadow: 0 2px 4px rgba(0,0,0,0.3);
                            }
                            .screen{
                                position:absolute;
                                inset:0;
                                display:flex;
                                flex-direction:column;
                                align-items:center;
                                justify-content:center;
                                transition:opacity 0.3s ease-in-out;
                                opacity:0;
                                visibility:hidden;
                            }
                            .screen.active{opacity:1; visibility:visible;}

                            .main-menu{
                                gap:28px;
                            }
                            .main-menu h1{
                                font-size:3.8rem;
                                margin:0 0 20px;
                                text-align:center;
                                color: var(--accent-light);
                                text-shadow: 0 4px 12px rgba(0,0,0,0.5), 0 0 10px var(--glow);
                                animation:popIn 0.6s cubic-bezier(.36,.07,.19,.97) both;
                            }
                            .menu-button{
                                padding:18px 36px;
                                border:2px solid var(--accent);
                                border-radius:10px;
                                background:linear-gradient(to bottom, rgba(72,187,120,0.2), rgba(72,187,120,0.1));
                                color:var(--line);
                                font-size:1.3rem;
                                font-weight:bold;
                                cursor:pointer;
                                transition:transform 0.15s ease-in-out, background 0.15s ease-in-out, border-color 0.15s ease-in-out;
                                width:240px;
                                text-align:center;
                                box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                            }
                            .menu-button:hover{
                                transform:translateY(-2px);
                                background:linear-gradient(to bottom, rgba(72,187,120,0.3), rgba(72,187,120,0.2));
                                border-color: var(--accent-light);
                            }
                            .menu-button:active{transform:translateY(1px);}

                            .game-screen{
                                gap:20px;
                                position: relative;
                                display: flex;
                                flex-direction: column;
                                align-items: center;
                                justify-content: center;
                            }
                            .wrap{
                                position:relative;
                                display: flex;
                                flex-direction: column;
                                align-items: center;
                                justify-content: center;
                            }
                            canvas{
                                background:linear-gradient(0deg, rgba(14,111,59,.95), rgba(12,98,52,.95));
                                border:6px solid #2a4334;
                                border-radius:12px;
                                box-shadow:0 12px 30px rgba(0,0,0,.4);
                            }
                            .hud{position:absolute; inset:auto 20px 20px 20px; display:flex; justify-content:space-between; pointer-events:none; width: auto;}
                            .hud > * {background:rgba(26, 32, 44, 0.85); border:1px solid rgba(255,255,255,0.05); backdrop-filter: blur(8px); padding:12px 18px; border-radius:8px; box-shadow: 0 6px 16px rgba(0,0,0,0.3);}

                            #game-screen.active .hud {
                                display: none;
                            }

                            .row{display:flex; gap:8px; align-items:center}
                            .kbd{display:inline-block; padding:4px 8px; border-radius:4px; border:1px solid rgba(255,255,255,.1); font-weight:600; background:rgba(255,255,255,.04); font-size:0.9rem;}
                            .powerbar{position:absolute; left:50%; transform:translateX(-50%); top:20px; width:60%; height:14px; border-radius:10px; background:rgba(255,255,255,.1); border:1px solid rgba(255,255,255,.15); overflow:hidden; box-shadow: 0 3px 8px rgba(0,0,0,0.4); transition: all 0.2s ease;}
                            .fill{height:100%; width:0%; background:linear-gradient(90deg, var(--accent), var(--accent2), var(--accent-light)); border-radius:10px; transition:width .06s ease-out; box-shadow: 0 0 6px rgba(72,187,120,0.5);}
                            .title{font-weight:700; letter-spacing:.3px; opacity:.9; font-size:1.1rem; color: var(--glow); text-shadow: 0 0 6px var(--glow);}
                            .small{opacity:.7; font-size:0.85rem;}
                            .badge{font-size:0.8rem; padding:3px 7px; border-radius:999px; border:1px solid rgba(255,255,255,.15); background:rgba(255,255,255,.05); margin-left:8px;}

                            .movesbar{
                                position:absolute;
                                left:50%;
                                bottom:20px;
                                transform:translateX(-50%);
                                display:flex; gap:16px; align-items:center; justify-content:center;
                                padding:12px 20px; border-radius:10px; background:rgba(26, 32, 44, 0.7);
                                border:1px solid rgba(255,255,255,.06); backdrop-filter: blur(8px);
                                box-shadow:0 8px 20px rgba(0,0,0,.35); z-index:10;
                            }
                            .slot{
                                position:relative; min-width:180px; height:42px; border-radius:8px; overflow:hidden; cursor:default;
                                border:1px solid rgba(255,255,255,.1); background:linear-gradient(90deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
                                box-shadow: inset 0 1px 0 rgba(255,255,255,.04), 0 4px 12px rgba(0,0,0,.2);

                            }

                            .slot .label{position:absolute; inset:0; display:flex; align-items:center; gap:8px; padding:0 12px; font-weight:600; letter-spacing:.2px; color: var(--line); text-shadow: 0 0 4px var(--glow);}
                            .slot .key{font-size:0.8rem; font-weight:700; padding:3px 6px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.05);}
                            .slot .name{opacity:.9;}
                            .slot .ready{position:absolute; inset:0; background:linear-gradient(90deg, var(--kaiserA), var(--kaiserB)); opacity:.15; border-radius: 8px;}
                            .slot.robsan .ready { background: linear-gradient(90deg, var(--robsan-dark-primary), var(--robsan-dark-secondary)); opacity: 0.2; }
                            .slot.robsan.eclipse-ready .ready { background: linear-gradient(90deg, var(--eclipse-aura-start), var(--eclipse-aura-end)); opacity: 0.25; } 
                            .slot.robsan.void-ready .ready { background: linear-gradient(90deg, var(--void-dash-primary), var(--void-dash-secondary)); opacity: 0.25; }
                            .slot.xdrake.ready .ready { background: linear-gradient(90deg, var(--xdrake-green-primary), var(--xdrake-green-secondary)); opacity: 0.25; }
                            .slot.xdrake.footwork-ready .ready { background: linear-gradient(90deg, var(--xdrake-footwork-color), var(--xdrake-green-secondary)); opacity: 0.25; }
                            .slot.xdrake.apex-ready .ready { background: linear-gradient(90deg, var(--xdrake-apex-aura-start), var(--xdrake-apex-aura-end)); opacity: 0.25; }
                            .slot.gojo.ready .ready { background: linear-gradient(90deg, var(--gojo-blue-primary), var(--gojo-red-primary)); opacity: 0.25; }
                            .slot.gojo.gojo-red-ready .ready { background: linear-gradient(90deg, var(--gojo-red-primary), var(--gojo-red-secondary)); opacity: 0.25; }
                            .slot.gojo.gojo-blue-ready .ready { background: linear-gradient(90deg, var(--gojo-blue-primary), var(--gojo-blue-secondary)); opacity: 0.25; }
                            .slot.gojo.gojo-purple-ready .ready { background: linear-gradient(90deg, var(--gojo-purple-primary), var(--gojo-purple-secondary)); opacity: 0.25; }
                            .slot.eddie.ready .ready { background: linear-gradient(90deg, var(--eddie-primary), var(--eddie-secondary)); opacity: 0.35; }
                            .slot.zeus.ready .ready { background: linear-gradient(90deg, var(--zeus-primary), var(--zeus-secondary)); opacity: 0.25; } /* NEW ZEUS */
                            .slot.asher.ready .ready { background: linear-gradient(90deg, var(--asher-primary), var(--asher-secondary)); opacity: 0.25; } /* NEW ASHER */


                            .slot .pulse{position:absolute; inset:-1px; border-radius:inherit; border:1px solid transparent;}
                            .slot.ready .pulse{animation:pulseGlow 1.2s ease-in-out infinite}
                            .slot.robsan.ready .pulse {
                                 animation:pulseRobsanGlow 1.2s ease-in-out infinite;
                            }
                            .slot.robsan.eclipse-ready .pulse {
                                animation:pulseEclipseGlow 1.2s ease-in-out infinite;
                            }
                            .slot.robsan.void-ready .pulse {
                                animation:pulseVoidGlow 1.2s ease-in-out infinite;
                            }

                            .slot.xdrake.ready .pulse { animation:pulseXDDashGlow 1.2s ease-in-out infinite; }
                            .slot.xdrake.footwork-ready .pulse { animation:pulseXDFootworkGlow 1.2s ease-in-out infinite; }
                            .slot.xdrake.apex-ready .pulse { animation:pulseXDApexGlow 1.2s ease-in-out infinite; }
                            .slot.gojo.gojo-red-ready .pulse { animation:pulseGojoRedGlow 1.2s ease-in-out infinite; }
                            .slot.gojo.gojo-blue-ready .pulse { animation:pulseGojoBlueGlow 1.2s ease-in-out infinite; }
                            .slot.gojo.gojo-purple-ready .pulse { animation:pulseGojoPurpleGlow 1.2s ease-in-out infinite; }
                            .slot.eddie.ready .pulse { animation:pulseEddieGlow 1.2s ease-in-out infinite; }
                            .slot.zeus.ready .pulse { animation:pulseZeusGlow 1.2s ease-in-out infinite; } /* NEW ZEUS */
                            .slot.asher.ready .pulse { animation:pulseAsherGlow 1.2s ease-in-out infinite; } /* NEW ASHER */
                            .slot.leonardo.ready .pulse { animation:pulseLeonardoGlow 1.2s ease-in-out infinite; }
                    .slot.leonardo.ready .ready { background: linear-gradient(90deg, var(--leonardo-primary), var(--leonardo-secondary)); opacity: 0.25; }
                            .slot.angus.ready .pulse { animation:pulseAngusGlow 1.2s ease-in-out infinite; }
                            .slot.angus.ready .ready { background: linear-gradient(90deg, var(--angus-primary), var(--angus-secondary)); opacity: 0.25; }
                            .slot.diddy.ready .pulse { animation:pulseBabyOilGuyGlow 1.2s ease-in-out infinite; }
                            .slot.diddy.ready .ready { background: linear-gradient(90deg, var(--diddy-primary), var(--diddy-secondary)); opacity: 0.25; }
                            .slot.cristiano.ready .pulse { animation:pulseCristianoGlow 1.2s ease-in-out infinite; }
                            .slot.cristiano.ready .ready { background: linear-gradient(90deg, var(--cristiano-primary), var(--cristiano-secondary)); opacity: 0.25; }
                            .slot.hudson.ready .pulse { animation:pulseHudsonGlow 1.2s ease-in-out infinite; }
                            .slot.hudson.ready .ready { background: linear-gradient(90deg, var(--hudson-primary), var(--hudson-secondary)); opacity: 0.25; }

                            @keyframes pulseGlow{
                                0%{box-shadow:0 0 0 0 rgba(102,126,234,.3), 0 0 0 0 rgba(237,100,166,.3)}
                                70%{box-shadow:0 0 0 8px rgba(102,126,234,0), 0 0 0 16px rgba(237,100,166,0)}
                                100%{box-shadow:0 0 0 0 rgba(102,126,234,0), 0 0 0 0 rgba(237,100,166,0)}
                            }
                            @keyframes pulseRobsanGlow{
                                0%{box-shadow:0 0 0 0 rgba(49,46,129,.3), 0 0 0 0 rgba(76,29,149,.3)}
                                70%{box-shadow:0 0 0 8px rgba(49,46,129,0), 0 0 0 16px rgba(76,29,149,0)}
                                100%{box-shadow:0 0 0 0 rgba(49,46,129,0), 0 0 0 0 rgba(76,29,149,0)}
                            }
                            @keyframes pulseEclipseGlow{
                                0%{box-shadow:0 0 0 0 rgba(0,0,0,.4), 0 0 0 0 rgba(30,0,50,.4)}
                                70%{box-shadow:0 0 0 8px rgba(0,0,0,0), 0 0 0 16px rgba(30,0,50,0)}
                                100%{box-shadow:0 0 0 0 rgba(0,0,0,0), 0 0 0 0 rgba(30,0,50,0)}
                            }
                            @keyframes pulseVoidGlow{
                                0%{box-shadow:0 0 0 0 rgba(30,27,75,.4), 0 0 0 0 rgba(12,10,9,.4)}
                                70%{box-shadow:0 0 0 8px rgba(30,27,75,0), 0 0 0 16px rgba(12,10,9,0)}
                                100%{box-shadow:0 0 0 0 rgba(30,27,75,0), 0 0 0 0 rgba(12,10,9,0)}
                            }
                            @keyframes pulseXDDashGlow{
                                0%{box-shadow:0 0 0 0 rgba(16,185,129,.4), 0 0 0 0 rgba(5,150,105,.4)}
                                70%{box-shadow:0 0 0 8px rgba(16,185,129,0), 0 0 0 16px rgba(5,150,105,0)}
                                100%{box-shadow:0 0 0 0 rgba(16,185,129,0), 0 0 0 0 rgba(5,150,105,0)}
                            }
                            @keyframes pulseXDFootworkGlow{
                                0%{box-shadow:0 0 0 0 rgba(109,75,46,.4), 0 0 0 0 rgba(5,150,105,.4)}
                                70%{box-shadow:0 0 0 8px rgba(109,75,46,0), 0 0 0 16px rgba(5,150,105,0)}
                                100%{box-shadow:0 0 0 0 rgba(109,75,46,0), 0 0 0 0 rgba(5,150,105,0)}
                            }
                            @keyframes pulseXDApexGlow{
                                0%{box-shadow:0 0 0 0 rgba(0,100,0,.4), 0 0 0 0 rgba(100,200,100,.4)}
                                70%{box-shadow:0 0 0 8px rgba(0,100,0,0), 0 0 0 16px rgba(100,200,100,0)}
                                100%{box-shadow:0 0 0 0 rgba(0,100,0,0), 0 0 0 0 rgba(100,200,100,0)}
                            }
                            @keyframes pulseGojoRedGlow{
                                0%{box-shadow:0 0 0 0 rgba(229,62,62,.4), 0 0 0 0 rgba(197,48,48,.4)}
                                70%{box-shadow:0 0 0 8px rgba(229,62,62,0), 0 0 0 16px rgba(197,48,48,0)}
                                100%{box-shadow:0 0 0 0 rgba(229,62,62,0), 0 0 0 0 rgba(197,48,48,0)}
                            }
                            @keyframes pulseGojoBlueGlow{
                                0%{box-shadow:0 0 0 0 rgba(49,130,206,.4), 0 0 0 0 rgba(44,82,130,.4)}
                                70%{box-shadow:0 0 0 8px rgba(49,130,206,0), 0 0 0 16px rgba(44,82,130,0)}
                                100%{box-shadow:0 0 0 0 rgba(49,130,206,0), 0 0 0 0 rgba(44,82,130,0)}
                            }
                            @keyframes pulseGojoPurpleGlow{
                                0%{box-shadow:0 0 0 0 rgba(128,90,213,.4), 0 0 0 0 rgba(85,60,154,.4)}
                                70%{box-shadow:0 0 0 8px rgba(128,90,213,0), 0 0 0 16px rgba(85,60,154,0)}
                                100%{box-shadow:0 0 0 0 rgba(128,90,213,0), 0 0 0 0 rgba(85,60,154,0)}
                            }
                            @keyframes pulseEddieGlow{
                                0%{box-shadow:0 0 0 0 rgba(0,0,0,.4), 0 0 0 0 rgba(26,32,44,.4)}
                                70%{box-shadow:0 0 0 8px rgba(0,0,0,0), 0 0 0 16px rgba(26,32,44,0)}
                                100%{box-shadow:0 0 0 0 rgba(0,0,0,0), 0 0 0 0 rgba(26,32,44,0)}
                            }
                            /* NEW ZEUS KEYFRAMES */
                            @keyframes pulseZeusGlow{
                                0%{box-shadow:0 0 0 0 rgba(59,130,246,.4), 0 0 0 0 rgba(96,165,250,.4)}
                                70%{box-shadow:0 0 0 8px rgba(59,130,246,0), 0 0 0 16px rgba(96,165,250,0)}
                                100%{box-shadow:0 0 0 0 rgba(59,130,246,0), 0 0 0 0 rgba(96,165,250,0)}
                            }
                            /* NEW ASHER KEYFRAMES */
                            @keyframes pulseAsherGlow{
                                0%{box-shadow:0 0 0 0 rgba(167,139,250,.4), 0 0 0 0 rgba(233,213,255,.4)}
                                70%{box-shadow:0 0 0 8px rgba(167,139,250,0), 0 0 0 16px rgba(233,213,255,0)}
                                100%{box-shadow:0 0 0 0 rgba(167,139,250,0), 0 0 0 0 rgba(233,213,255,0)}
                            }

                            /* NEW LEONARDO KEYFRAMES */
                            @keyframes pulseLeonardoGlow{
                                0%{box-shadow:0 0 0 0 rgba(6,182,212,.4), 0 0 0 0 rgba(165,243,252,.4)}
                                70%{box-shadow:0 0 0 8px rgba(6,182,212,0), 0 0 0 16px rgba(165,243,252,0)}
                                100%{box-shadow:0 0 0 0 rgba(6,182,212,0), 0 0 0 0 rgba(165,243,252,0)}
                            }
                            /* NEW ANGUS KEYFRAMES */
                            @keyframes pulseAngusGlow{
                                0%{box-shadow:0 0 0 0 rgba(255,255,255,.4), 0 0 0 0 rgba(243,244,246,.4)}
                                70%{box-shadow:0 0 0 8px rgba(255,255,255,0), 0 0 0 16px rgba(243,244,246,0)}
                                100%{box-shadow:0 0 0 0 rgba(255,255,255,0), 0 0 0 0 rgba(243,244,246,0)}
                            }
                            /* NEW BABY OIL GUY KEYFRAMES */
                            @keyframes pulseBabyOilGuyGlow{
                                0%{box-shadow:0 0 0 0 rgba(139,69,19,.4), 0 0 0 0 rgba(255,215,0,.4)}
                                70%{box-shadow:0 0 0 8px rgba(139,69,19,0), 0 0 0 16px rgba(255,215,0,0)}
                                100%{box-shadow:0 0 0 0 rgba(139,69,19,0), 0 0 0 0 rgba(255,215,0,0)}
                            }
                            @keyframes pulseCristianoGlow{
                                0%{box-shadow:0 0 0 0 rgba(220,38,38,.4), 0 0 0 0 rgba(22,163,74,.4)}
                                70%{box-shadow:0 0 0 8px rgba(220,38,38,0), 0 0 0 16px rgba(22,163,74,0)}
                                100%{box-shadow:0 0 0 0 rgba(220,38,38,0), 0 0 0 0 rgba(22,163,74,0)}
                            }
                            @keyframes pulseHudsonGlow{
                                0%{box-shadow:0 0 0 0 rgba(233,30,99,.4), 0 0 0 0 rgba(63,81,181,.4)}
                                70%{box-shadow:0 0 0 8px rgba(233,30,99,0), 0 0 0 16px rgba(63,81,181,0)}
                                100%{box-shadow:0 0 0 0 rgba(233,30,99,0), 0 0 0 0 rgba(63,81,181,0)}
                            }

                            /* CAPTION ANIMATION STYLES */
                            @keyframes captionFade {
                                0% { opacity: 0; }
                                100% { opacity: 1; }
                            }
                            @keyframes captionSlideFromTop {
                                0% { transform: translateX(-50%) translateY(-100%); opacity: 0; }
                                100% { transform: translateX(-50%) translateY(0); opacity: 1; }
                            }
                            @keyframes captionSlideFromBottom {
                                0% { transform: translateX(-50%) translateY(100%); opacity: 0; }
                                100% { transform: translateX(-50%) translateY(0); opacity: 1; }
                            }
                            @keyframes captionSlideFromLeft {
                                0% { transform: translateX(-150%) translateY(0); opacity: 0; }
                                100% { transform: translateX(-50%) translateY(0); opacity: 1; }
                            }
                            @keyframes captionSlideFromRight {
                                0% { transform: translateX(50%) translateY(0); opacity: 0; }
                                100% { transform: translateX(-50%) translateY(0); opacity: 1; }
                            }
                            @keyframes captionBounce {
                                0% { transform: translateX(-50%) scale(0); opacity: 0; }
                                50% { transform: translateX(-50%) scale(1.1); opacity: 1; }
                                100% { transform: translateX(-50%) scale(1); opacity: 1; }
                            }
                            @keyframes captionZoom {
                                0% { transform: translateX(-50%) scale(0); opacity: 0; }
                                100% { transform: translateX(-50%) scale(1); opacity: 1; }
                            }
                            @keyframes captionFadeOut {
                                0% { opacity: 1; }
                                100% { opacity: 0; }
                            }

                            .slot .cool{
                                position:absolute; left:0; top:0; bottom:0; width:0%;
                                background:linear-gradient(90deg, rgba(102,126,234,.8), rgba(237,100,166,.8));
                                opacity:.2; border-radius: 8px;
                            }
                            .slot.robsan .cool {
                                 background:linear-gradient(90deg, var(--robsan-dark-primary), var(--robsan-dark-secondary));
                            }
                            .slot.robsan.eclipse-cool .cool {
                                 background:linear-gradient(90deg, var(--eclipse-line-color), var(--eclipse-line-glow));
                            }
                            .slot.robsan.void-cool .cool {
                                 background:linear-gradient(90deg, var(--void-dash-primary), var(--void-dash-secondary));
                            }
                            .slot.xdrake .cool {
                                 background:linear-gradient(90deg, var(--xdrake-green-primary), var(--xdrake-green-secondary));
                            }
                            .slot.xdrake.footwork-cool .cool {
                                 background:linear-gradient(90deg, var(--xdrake-footwork-color), var(--xdrake-green-secondary));
                            }
                            .slot.xdrake.apex-cool .cool {
                                 background:linear-gradient(90deg, var(--xdrake-apex-aura-start), var(--xdrake-apex-aura-end));
                            }
                            .slot.gojo.gojo-red-cool .cool { background: linear-gradient(90deg, var(--gojo-red-primary), var(--gojo-red-secondary)); }
                            .slot.gojo.gojo-blue-cool .cool { background: linear-gradient(90deg, var(--gojo-blue-primary), var(--gojo-blue-secondary)); }
                            .slot.gojo.gojo-purple-cool .cool { background: linear-gradient(90deg, var(--gojo-purple-primary), var(--gojo-purple-secondary)); }
                            .slot.eddie .cool { background: linear-gradient(90deg, var(--eddie-primary), var(--eddie-secondary)); }
                            .slot.zeus .cool { background: linear-gradient(90deg, var(--zeus-primary), var(--zeus-secondary)); } /* NEW ZEUS */
                            .slot.asher .cool { background: linear-gradient(90deg, var(--asher-primary), var(--asher-secondary)); } /* NEW ASHER */
                    .slot.leonardo .cool { background: linear-gradient(90deg, var(--leonardo-primary), var(--leonardo-secondary)); }
                            .slot.angus .cool { background: linear-gradient(90deg, var(--angus-primary), var(--angus-secondary)); }
                            .slot.diddy .cool { background: linear-gradient(90deg, var(--diddy-primary), var(--diddy-secondary)); }

                            .slot .coolText{position:absolute; right:8px; top:50%; transform:translateY(-50%); font-size:0.75rem; opacity:.7;}

                            .modal-backdrop{
                                position:fixed; inset:0; background:rgba(0,0,0,.7);
                                backdrop-filter:blur(6px); z-index:100;
                                display:flex; align-items:center; justify-content:center;
                                opacity:0; visibility:hidden; transition:opacity 0.2s ease-in-out;
                            }
                            .modal-backdrop.open{opacity:1; visibility:visible;}
                            .modal-content{
                                background:var(--panel); border:1px solid rgba(255,255,255,.08);
                                border-radius:12px; padding:32px; width:400px; max-width:90%;
                                transform:scale(0.95) translateY(10px); transition:transform 0.3s cubic-bezier(.36,.07,.19,.97);
                                box-shadow:0 10px 25px rgba(0,0,0,.5);
                                color: var(--line);
                                position: relative;
                            }
                            .modal-backdrop.open .modal-content{transform:scale(1) translateY(0);}
                            .modal-content h2{margin-top:0; font-size:2.2rem; letter-spacing:.4px; color: var(--accent-light); text-shadow: 0 0 8px var(--glow);}
                            .modal-content p{line-height:1.6; opacity:0.85; font-size:1rem; margin-bottom:0; color: var(--line);}
                            .modal-content .close-button{
                                position:absolute; top:10px; right:10px;
                                padding:6px; background:none; border:none;
                                color:rgba(255,255,255,0.7); font-size:1.4rem; cursor:pointer;
                                transition:transform 0.15s ease-in-out, color 0.15s ease-in-out;
                            }
                            .modal-content .close-button:hover{color:var(--danger); transform:rotate(90deg);}
                            .modal-content .toggle-container{
                                display:flex; flex-direction:column; gap:10px; margin-top:20px;
                            }
                            .toggle-group{
                                display:flex; flex-wrap: wrap; gap:8px;
                                background:rgba(255,255,255,0.03); padding:5px; border-radius:8px;
                                justify-content: center;
                            }
                            .toggle-button{
                                flex:1; padding:10px 16px; border-radius:6px; cursor:pointer;
                                background:transparent; transition:background 0.15s ease-in-out, color 0.15s ease-in-out, border-color 0.15s ease-in-out;
                                border:1px solid transparent; font-weight:500; text-align:center; color: var(--line);
                                min-width: 120px;
                            }
                            .toggle-button.active{background:var(--accent); color:var(--panel); border-color:var(--accent-light);}
                            .toggle-button.robsan.active{background:var(--robsan-dark-primary); color:white; border-color:var(--robsan-dark-secondary);}
                            .toggle-button.xdrake.active{background:var(--xdrake-green-primary); color:white; border-color:var(--xdrake-green-secondary);}
                            .toggle-button.gojo.active{background:var(--gojo-blue-primary); color:white; border-color:var(--gojo-purple-primary);}
                            .toggle-button.eddie.active{background:var(--eddie-primary); color:white; border-color:var(--eddie-secondary);}
                            .toggle-button.zeus.active{background:var(--zeus-primary); color:white; border-color:var(--zeus-secondary);} /* NEW ZEUS */
                            .toggle-button.asher.active{background:var(--asher-primary); color:white; border-color:var(--asher-secondary);} /* NEW ASHER */
                            .toggle-button.leonardo.active{background:var(--leonardo-primary); color:white; border-color:var(--leonardo-secondary);}
                            .toggle-button.angus.active{background:var(--angus-primary); color:black; border-color:var(--angus-secondary);}
                            .toggle-button.diddy.active{background:var(--diddy-primary); color:white; border-color:var(--diddy-secondary);}
                            .toggle-button:hover:not(.active){border-color: rgba(255,255,255,0.2);}

                            .exit-icon-button {
                                position: absolute;
                                top: 20px;
                                right: 20px;
                                width: 40px;
                                height: 40px;
                                border-radius: 50%;
                                background: rgba(229, 62, 62, 0.8);
                                border: 2px solid var(--danger);
                                color: var(--line);
                                font-size: 1.8rem;
                                font-weight: bold;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                cursor: pointer;
                                transition: transform 0.15s ease-in-out, background 0.15s ease-in-out, border-color 0.15s ease-in-out, color 0.15s ease-in-out;
                                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                                z-index: 10;
                            }

                            .exit-icon-button:hover {
                                background: var(--danger);
                                color: white;
                                transform: scale(1.05);
                            }

                            .exit-icon-button:active {
                                transform: scale(0.95);
                            }

                            .notification {
                                position: fixed;
                                top: 20px;
                                left: 50%;
                                transform: translateX(-50%);
                                background: rgba(26, 32, 44, 0.95);
                                border: 2px solid var(--danger);
                                border-radius: 8px;
                                padding: 12px 20px;
                                color: var(--line);
                                font-size: 0.9rem;
                                font-weight: 600;
                                text-align: center;
                                z-index: 1000;
                                box-shadow: 0 6px 15px rgba(0,0,0,0.4);
                                backdrop-filter: blur(8px);
                                opacity: 0;
                                visibility: hidden;
                                transition: opacity 0.3s ease, visibility 0.3s ease;
                            }
                            
                            /* EDDIE AWAKENING BAR STYLES */
                            .awakening-bar {
                                position: absolute;
                                left: 50%;
                                bottom: -15px; /* Very bottom, below movesbar */
                                transform: translateX(-50%);
                                width: 40%;
                                height: 12px;
                                border-radius: 8px;
                                background: var(--eddie-awakening-bg);
                                border: 1px solid rgba(255,255,255,0.1);
                                overflow: hidden;
                                box-shadow: 0 3px 8px rgba(0,0,0,0.4);
                                display: none; /* Hidden by default, shown only for Eddie */
                                z-index: 5;
                            }
                            
                            .awakening-fill {
                                height: 100%;
                                width: 0%;
                                background: var(--eddie-awakening-fill);
                                border-radius: 8px;
                                transition: width 0.3s ease-out;
                                box-shadow: 0 0 6px rgba(34, 197, 94, 0.6);
                            }
                            
                            .awakening-bar.full .awakening-fill {
                                animation: pulseAwakeningGlow 1.5s ease-in-out infinite;
                            }
                            
                            @keyframes pulseAwakeningGlow {
                                0% { box-shadow: 0 0 6px rgba(34, 197, 94, 0.6); }
                                50% { box-shadow: 0 0 15px rgba(34, 197, 94, 1), 0 0 25px rgba(34, 197, 94, 0.8); }
                                100% { box-shadow: 0 0 6px rgba(34, 197, 94, 0.6); }
                            }
                            
                            .awakening-label {
                                position: absolute;
                                top: -18px;
                                left: 50%;
                                transform: translateX(-50%);
                                font-size: 0.7rem;
                                font-weight: 600;
                                color: var(--eddie-awakening-fill);
                                text-shadow: 0 0 4px rgba(34, 197, 94, 0.8);
                                opacity: 0.9;
                            }

                            .notification.show {
                                opacity: 1;
                                visibility: visible;
                            }

                            .notification.success {
                                border-color: var(--accent);
                                background: rgba(72, 187, 120, 0.15);
                            }

                            .notification.warning {
                                border-color: var(--accent2);
                                background: rgba(246, 173, 85, 0.15);
                            }

                            @keyframes popIn{
                                0%{transform:scale(0.9); opacity:0;}
                                100%{transform:scale(1); opacity:1;}
                            }

                            #tutorial-modal .modal-content {
                                height: 60vh;
                                overflow-y: auto;
                                max-height: 80vh;
                                width: 500px;
                                padding-right: 20px;
                            }
                        </style>
                    </head>
                    <body>

                        <div id="main-menu" class="screen active main-menu">
                            <h1>mini Football, if u found a bug please refresh and tell san</h1>
                            <p style="color: white; font-size: 1rem; margin: 10px 0; text-shadow: 0 0 10px rgba(255,255,255,0.8), 0 0 20px rgba(255,255,255,0.6), 0 0 30px rgba(255,255,255,0.4); text-align: center;">THIS GAME IS NOT COMPLETELY COMPLETED YET YOU WILL FIND ALOT OF BUGS, EDDIE AWAKENING STILL IN DEVELOPMENT</p>
                            <button class="menu-button" id="play-btn">play</button>
                            <button class="menu-button" id="tutorial-btn">tutorial</button>
                            <button class="menu-button" id="styles-btn">styles</button>
                            <button class="menu-button" id="credits-btn">credits</button>
                        </div>

                        <div id="game-screen" class="screen game-screen">
                            <button class="exit-icon-button" id="exit-game-btn">&times;</button>
                            <div id="notification" class="notification"></div>
                            <div class="wrap">
                                <canvas id="game" width="960" height="560"></canvas>
                                <div class="hud">
                                    <div class="card">
                                        <div class="title">mini football<span class="badge">wasd to move mouse to aim click to shoot</span></div>
                                        <div class="row small" style="margin-top:6px">
                                            <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span style="opacity:.6">D</span>
                                            <span style="opacity:.6">move</span>
                                            <span class="kbd">Click</span> <span style="opacity:.6">shoot</span>
                                            <span style="opacity:.6">hold auto shoot @ 3s</span>
                                            <span style="opacity:.6">c hudson impact (need ball)</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="powerbar" id="powerbar" aria-hidden="true"><div class="fill" id="powerfill"></div></div>

                                <!-- Baby Oil Guy Subtitles System -->
                                <div id="baby-oil-guy-subtitles" style="position: absolute; top: 30px; left: 50%; transform: translateX(-50%); background: black; color: white; padding: 12px 24px; border-radius: 8px; font-size: 1.6rem; font-family: 'Nunito', sans-serif; font-weight: 900; text-align: center; z-index: 1000; display: none; min-width: 400px; border: 2px solid #3b82f6; box-shadow: 0 0 20px rgba(59, 130, 246, 0.5), 0 0 40px rgba(59, 130, 246, 0.3);">
                                    <span id="subtitle-text"></span>
                                </div>
                            </div>
                            <div class="movesbar">
                                <div id="slotC" class="slot" aria-label="Special Ability C">
                                    <div class="ready"></div>
                                    <div class="pulse"></div>
                                    <div class="cool" id="coolC"></div>
                                    <div class="label">
                                        <span class="key">C</span>
                                        <span class="name" id="ability-name-C">Hudson Impact</span>
                                        <span class="coolText" id="coolCText"></span>
                                    </div>
                                </div>
                                <div id="slotV" class="slot" aria-label="Special Ability V">
                                    <div class="ready"></div>
                                    <div class="pulse"></div>
                                    <div class="cool" id="coolV"></div>
                                    <div class="label">
                                        <span class="key">V</span>
                                        <span class="name" id="ability-name-V">Eclipse Grasp</span>
                                        <span class="coolText" id="coolVText"></span>
                                    </div>
                                </div>
                                <div id="slotX" class="slot" aria-label="Special Ability X">
                                    <div class="ready"></div>
                                    <div class="pulse"></div>
                                    <div class="cool" id="coolX"></div>
                                    <div class="label">
                                        <span class="key">X</span>
                                        <span class="name" id="ability-name-X">Void Dash</span>
                                        <span class="coolText" id="coolXText"></span>
                                    </div>
                                </div>
                            </div>
                            <!-- Eddie Awakening Bar -->
                            <div id="awakening-bar" class="awakening-bar">
                                <div class="awakening-label">AWAKENING</div>
                                <div id="awakening-fill" class="awakening-fill"></div>
                            </div>
                        </div>

                        <div id="credits-modal" class="modal-backdrop">
                            <div class="modal-content">
                                <button class="close-button" id="close-credits">&times;</button>
                                <h2>credits</h2>
                                <p>this game was diddiled by san, on a more serious note this game will continue getting new updates and i take my time making these typa stuff..</p>
                                <p style="margin-top:12px;">everything wa made by me except the images, but i made the ball, player, and the field. i scripted it all, Frooty24 on youtube helped me with some of the style designs, like gojo, XDrake, etc he also makes the images. well not the ball or the player or the field </p>
                            </div>
                        </div>

                        <div id="styles-modal" class="modal-backdrop">
                            <div class="modal-content">
                                <button class="close-button" id="close-styles">&times;</button>
                                <h2>styles</h2>
                                <div class="toggle-container">
                                    <div class="toggle-group">
                                        <button class="toggle-button" id="style-none">none</button>
                                        <button class="toggle-button" id="style-gojo">satoru gojo</button>
                                        <button class="toggle-button" id="style-hudson">hudson</button>
                                        <button class="toggle-button" id="style-robsan">robsan</button>
                                        <button class="toggle-button" id="style-xdrake">xdrake</button>
                                        <button class="toggle-button" id="style-eddie">eddie</button>
                                        <button class="toggle-button" id="style-zeus">zeus</button>
                                        <button class="toggle-button" id="style-asher">asher</button> <!-- NEW ASHER BUTTON -->
                                        <button class="toggle-button" id="style-leonardo">leonardo</button>
                                        <button class="toggle-button" id="style-angus">angus</button>
                                        <button class="toggle-button" id="style-diddy">baby oil guy</button>
                                        <button class="toggle-button" id="style-cristiano">cristiano</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div id="tutorial-modal" class="modal-backdrop">
                            <div class="modal-content">
                                <button class="close-button" id="close-tutorial">&times;</button>
                                <h2>how to play mini Football</h2>
                                <p>welcome to mini FootBall heres a quick guide to get you started</p>
                                <h3>objective</h3>
                                <p>the goal is simple control your player get the ball and shoot it into the opponents goal</p>
                                <h3>controls</h3>
                                <ul>
                                    <li>movement use the <span class="kbd">W</span> <span class="kbd">A</span> <span class="kbd">S</span> <span class="kbd">D</span> keys to move your player around the field your player has some momentum so anticipate your movements</li>
                                    <li>aiming move your <span class="kbd">mouse</span> to aim where you want to kick the ball</li>
                                    <li>shooting
                                        <ul>
                                            <li><span class="kbd">Click</span> and release the mouse button to shoot the longer you hold it the more powerful your shot will be</li>
                                            <li><span class="kbd">Hold</span> the mouse button for 3 seconds and your player will automatically unleash a powerful shot</li>
                                        </ul>
                                    </li>
                                </ul>
                                <h3>special abilities</h3>
                                <p>depending on your chosen style youll have unique special abilities</p>
                                <ul>
                                    <li>Hudson Impact (Hudson Style) press the <span class="kbd">C</span> key when you have possession of the ball to launch it with incredible speed and visual effects</li>
                                    <li>Robsan Style
                                        <ul>
                                            <li>Shadow Spiral press the <span class="kbd">C</span> key with the ball to perform a spinning dark aura move for 2 seconds followed by a 2-second charge then a powerful shadowy shot</li>
                                            <li>Eclipse Grasp press the <span class="kbd">V</span> key when you do not have the ball your player will emit a dark aura for 02 seconds then a wiggly black line will draw the ball directly to you in 05 seconds no matter its distance</li>
                                            <li>Void Dash press the <span class="kbd">X</span> key to instantly dash a short distance in the direction of your mouse cursor can be used with or without the ball for quick repositioning</li>
                                        </ul>
                                    </li>
                                    <li>XDRAKE Style
                                        <ul>
                                            <li>Supernova press the <span class="kbd">C</span> key to instantly dash a medium distance in the direction of your mouse cursor your player will turn green and leave a bright green trail no ball required</li>
                                            <li>Fossilised Footwork press the <span class="kbd">V</span> key when you have the ball perform a quick short forward burst with earthy visual effects and a unique trail</li>
                                            <li>Ancient Apex press the <span class="kbd">X</span> key when you have the ball your player glows green and unleashes an extremely powerful shot with a fierce green aura</li>
                                        </ul>
                                    </li>
                                    <li>Satoru Gojo Style harness cursed energy for devastating effects
                                        <ul>
                                            <li>Red press the <span class="kbd">C</span> key when you have the ball after a short charge the ball turns vibrant red and is launched with immense power</li>
                                            <li>Lapse Blue press the <span class="kbd">V</span> key when you do not have the ball a large blue cursed energy ball appears and orbits you rapidly if it touches the main soccer ball you instantly gain possession</li>
                                            <li>Purple press the <span class="kbd">X</span> key when you have the ball two powerful cursed energy spheres red and blue are launched outwards for 15 seconds then converge in the middle to create a massive 'Purple' attack unleashing the most powerful shot imaginable towards your cursor</li>
                                        </ul>
                                    </li>
                                    <li>Eddie Style:
                                        <ul>
                                            <li>We Are: press the <span class="kbd">C</span> key to turn black for 10 seconds and gain increased speed</li>
                                            <li>Venom Strike: press the <span class="kbd">V</span> key when you **do not have the ball** to instantly grab it from a large range and immediately shoot with all your might (extremely fast retrieval, with a powerful tendril aura)</li>
                                            <li>Symbiote Montage: press the <span class="kbd">X</span> key when you **have the ball** to rapidly teleport to 3 random locations on the field, leaving black puddles behind. After the third teleport, you'll instantly appear in the center of the field with the ball. You'll then have 1 second to aim with your cursor before automatically unleashing a powerful shot.</li>
                                        </ul>
                                    </li>
                                    <li>Zeus Style:
                                        <ul>
                                            <li>Lightning Bolt: Press the <span class="kbd">C</span> key when you have the ball to charge and unleash a super-fast, precise shot with an electrifying trail.</li>
                                            <li>Heavenly Shield: Press the <span class="kbd">V</span> key to activate a protective aura around you for 1.5 seconds. Any soccer ball entering this aura will have its velocity significantly reduced, making it easier to gain possession.</li>
                                            <li>Olympus' Fury: Press the <span class="kbd">X</span> key to generate a powerful pull that draws the ball directly to you for 3 seconds (if you don't have it). Once you have possession, you'll have 1.5 seconds to aim before unleashing an ultra-powerful, arcing lightning shot.</li>
                                        </ul>
                                    </li>
                                    <li>Asher Style:
                                        <ul>
                                            <li>Starfall Shot: Press the <span class="kbd">C</span> key when you have the ball to launch a shot that automatically homes in on the opponent's goal, leaving a starry trail.</li>
                                            <li>Celestial Pull: Press the <span class="kbd">V</span> key when you do not have the ball to instantly teleport it to your position with a burst of light.</li>
                                        </ul>
                                    </li>
                                    <li>all abilities have a cooldown period use them strategically</li>
                                </ul>
                                <h3>game interface</h3>
                                <ul>
                                    <li>power bar located at the top of the screen this shows you the power of your shot when youre charging it</li>
                                    <li>moves bar at the bottom this bar displays the cooldown status and name of your active special abilityies watch for the ready indicator</li>
                                </ul>
                                <p>have fun and enjoy the game</p>
                            </div>
                        </div>

                        <div id="ai-modal" class="modal-backdrop">
                            <div class="modal-content">
                                <button class="close-button" id="close-ai">&times;</button>
                                <h2>Choose Game Mode</h2>
                                <p>Select how you want to play</p>
                                <div class="toggle-container">
                                    <div class="toggle-group" style="flex-direction: column; gap: 15px;">
                                        <button class="menu-button" id="play-with-ai" style="width: 100%;">Play with AI, Does not fully work.</button>
                                        <button class="menu-button" id="play-without-ai" style="width: 100%;">Play without AI Reccomended.</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <script>
                            /*
                             * TRYCAPTION STYLES AVAILABLE:
                             * - 'Fade': Simple fade in and out
                             * - 'SlideFromTop': Slides down from above
                             * - 'SlideFromBottom': Slides up from below
                             * - 'SlideFromLeft': Slides in from left
                             * - 'SlideFromRight': Slides in from right
                             * - 'Bounce': Bounces in with spring effect
                             * - 'Zoom': Scales in and out
                             * - 'Typewriter': Classic typewriter effect
                             */

                            // Universal Subtitle Function - Available everywhere
                            function TrySubtitle(text, callback) {
                                const subtitleEl = document.getElementById('baby-oil-guy-subtitles');
                                const textEl = document.getElementById('subtitle-text');

                                subtitleEl.style.display = 'block';
                                textEl.textContent = '';

                                let charIndex = 0;
                                const typeInterval = setInterval(() => {
                                    if (charIndex < text.length) {
                                        textEl.textContent += text[charIndex];
                                        charIndex++;
                                    } else {
                                        clearInterval(typeInterval);
                                        setTimeout(() => {
                                            subtitleEl.style.display = 'none';
                                            if (callback) callback();
                                        }, 1000); // Fade out after 1 second when finished writing
                                    }
                                }, 50); // 50ms per character for typewriter effect
                            }

                            function Trycaption(text, style = 'Fade', callback) {
                                const subtitleEl = document.getElementById('baby-oil-guy-subtitles');
                                const textEl = document.getElementById('subtitle-text');

                                // Clear any existing animations
                                subtitleEl.style.animation = '';
                                subtitleEl.style.display = 'block';
                                textEl.textContent = text;

                                // Apply entrance animation based on style
                                switch(style.toLowerCase()) {
                                    case 'fade':
                                        subtitleEl.style.animation = 'captionFade 0.5s ease-in-out';
                                        break;
                                    case 'slidefromtop':
                                        subtitleEl.style.animation = 'captionSlideFromTop 0.6s ease-out';
                                        break;
                                    case 'slidefrombottom':
                                        subtitleEl.style.animation = 'captionSlideFromBottom 0.6s ease-out';
                                        break;
                                    case 'slidefromleft':
                                        subtitleEl.style.animation = 'captionSlideFromLeft 0.6s ease-out';
                                        break;
                                    case 'slidefromright':
                                        subtitleEl.style.animation = 'captionSlideFromRight 0.6s ease-out';
                                        break;
                                    case 'bounce':
                                        subtitleEl.style.animation = 'captionBounce 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
                                        break;
                                    case 'zoom':
                                        subtitleEl.style.animation = 'captionZoom 0.5s ease-out';
                                        break;
                                    case 'typewriter':
                                        // Special typewriter effect
                                        textEl.textContent = '';
                                        subtitleEl.style.animation = 'captionFade 0.3s ease-in-out';
                                        let charIndex = 0;
                                        const typeInterval = setInterval(() => {
                                            if (charIndex < text.length) {
                                                textEl.textContent += text[charIndex];
                                                charIndex++;
                                            } else {
                                                clearInterval(typeInterval);
                                            }
                                        }, 40);
                                        break;
                                    default:
                                        subtitleEl.style.animation = 'captionFade 0.5s ease-in-out';
                                }

                                // Hide after 2.5 seconds with fade out
                                setTimeout(() => {
                                    subtitleEl.style.animation = 'captionFadeOut 0.5s ease-in-out';
                                    setTimeout(() => {
                                        subtitleEl.style.display = 'none';
                                        if (callback) callback();
                                    }, 500);
                                }, 2500);
                            }

                            const canvas = document.getElementById('game');
                            const ctx = canvas.getContext('2d');
                            const W = canvas.width, H = canvas.height;

                            // NEW DIDDY OIL IMAGE SYSTEM
                            const oilImage = new Image();
                            let oilImageLoaded = false;
                            oilImage.onload = function() {
                                oilImageLoaded = true;
                                console.log('Oil image loaded successfully!');
                            };
                            oilImage.onerror = function() {
                                console.warn('Failed to load oil.png, using fallback effects');
                            };
                            oilImage.src = 'oil.png';

                            let gameState = 'menu';
                            let isPlaying = false;
                            let currentStyle = 'hudson';
                            let aiEnabled = false;

                            const mainMenuScreen = document.getElementById('main-menu');
                            const gameScreen = document.getElementById('game-screen');
                            const playBtn = document.getElementById('play-btn');
                            const tutorialBtn = document.getElementById('tutorial-btn');
                            const stylesBtn = document.getElementById('styles-btn');
                            const creditsBtn = document.getElementById('credits-btn');
                            const exitBtn = document.getElementById('exit-game-btn');

                            const creditsModal = document.getElementById('credits-modal');
                            const closeCreditsBtn = document.getElementById('close-credits');
                            const stylesModal = document.getElementById('styles-modal');
                            const closeStylesBtn = document.getElementById('close-styles');
                            const tutorialModal = document.getElementById('tutorial-modal');
                            const closeTutorialBtn = document.getElementById('close-tutorial');
                            const aiModal = document.getElementById('ai-modal');
                            const closeAiBtn = document.getElementById('close-ai');
                            const playWithAiBtn = document.getElementById('play-with-ai');
                            const playWithoutAiBtn = document.getElementById('play-without-ai');

                            const styleNoneBtn = document.getElementById('style-none');
                            const styleHudsonBtn = document.getElementById('style-hudson');
                            const styleRobsanBtn = document.getElementById('style-robsan');
                            const styleXDrakeBtn = document.getElementById('style-xdrake');
                            const styleGojoBtn = document.getElementById('style-gojo');
                            const styleEddieBtn = document.getElementById('style-eddie');
                            const styleZeusBtn = document.getElementById('style-zeus');
                            const styleAsherBtn = document.getElementById('style-asher'); // NEW ASHER BUTTON
                            const styleLeonardoBtn = document.getElementById('style-leonardo');
                            const styleAngusBtn = document.getElementById('style-angus');
                            const styleDiddyBtn = document.getElementById('style-diddy');
                            const styleCristianoBtn = document.getElementById('style-cristiano');


                            const slotC = document.getElementById('slotC');
                            const abilityNameCEl = document.getElementById('ability-name-C');
                            const slotV = document.getElementById('slotV');
                            const abilityNameVEl = document.getElementById('ability-name-V');
                            const slotX = document.getElementById('slotX');
                            const abilityNameXEl = document.getElementById('ability-name-X');
                            
                            // Eddie Awakening Elements
                            const awakeningBar = document.getElementById('awakening-bar');
                            const awakeningFill = document.getElementById('awakening-fill');

                            const margin = 40;
                            const goalW = 140, goalDepth = 18;

                            const player = {
                                x:W*0.25, y:H*0.5, r:18, speed:0, vx:0, vy:0, maxSpd:3.2, accel:0.6, drag:0.85, hasBall:false,
                                spinning:false, spinTimer:0, charging:false, chargeTimer:0, telekinising:false,
                                dashing:false, dashTimer:0,
                                xdrakeSupernovaDashing: false, xdrakeSupernovaDashTimer: 0,
                                xdrakeFossilFootworking: false, xdrakeFossilFootworkTimer: 0,
                                xdrakeAncientApexCharging: false, xdrakeAncientApexChargeTimer: 0,
                                // NEW ASHER PROPERTIES

                                gojoRedCharging: false,
                                gojoRedChargeStartTime: 0,
                                gojoRedActive: false,
                                gojoLapseBlueActive: false,
                                gojoLapseBlueBall: null,
                                gojoPurpleActive: false,
                                gojoPurpleConverging: false,
                                gojoPurpleConvergenceStartTime: 0,
                                gojoPurpleLeftBall: null,
                                gojoPurpleRightBall: null,
                                gojoPurpleInitialDir: 0,
                                gojoPurpleShotFired: false,

                                eddieWeAreActive: false,
                                eddieWeAreOriginalMaxSpd: 3.2, // Initialized correctly
                                eddieWeAreEndTime: 0,
                                eddieVenomStrikeActive: false,
                                eddieVenomStrikeEndTime: 0,
                                eddieSymbioteMontageActive: false,
                                eddieSymbioteMontagePhase: '', // 'teleporting', 'aiming'
                                eddieSymbioteMontageTeleportCount: 0,
                                eddieSymbioteMontageCurrentTeleportTarget: {x:0, y:0},
                                eddieSymbioteMontageTeleportStartTime: 0,
                                eddieSymbioteMontageTeleportEndTime: 0,
                                eddieSymbioteMontageStartPlayerPos: {x:0, y:0},
                                eddieSymbioteMontageAimStartTime: 0,
                                eddieSymbioteMontageShotFired: false,
                                // EDDIE AWAKENING PROPERTIES
                                eddieAwakeningProgress: 0, // 0-100%
                                eddieAwakeningActive: false,
                                eddieAwakeningEndTime: 0,
                                eddieAwakeningVideoPlaying: false,

                                zeusLightningCharging: false,
                                zeusLightningChargeStartTime: 0,
                                zeusLightningActive: false,
                                zeusHeavenlyShieldActive: false,
                                zeusHeavenlyShieldEndTime: 0,
                                zeusHeavenlyShieldRadius: 0,
                                zeusOlympusFuryActive: false,
                                zeusOlympusFuryPhase: '', // 'pulling', 'aiming'
                                zeusOlympusFuryPullStartTime: 0,
                                zeusOlympusFuryAimStartTime: 0,
                                zeusOlympusFuryShotFired: false,
                                zeusOlympusFuryOrigHasBall: false,
                                // NEW ASHER PROPERTIES
                    // NEW ASHER PROPERTIES
                                asherAutoGoalActive: false,
                                asherStarfallCharging: false,
                                asherStarfallChargeStartTime: 0,
                                // NEW LEONARDO PROPERTIES
                    // NEW LEONARDO PROPERTIES
                                leonardoFocusShotActive: false,
                                leonardoShieldActive: false,
                                leonardoShieldEndTime: 0,
                                leonardoDashing: false,
                                leonardoDashTimer: 0,
                                leonardoDashEndX: 0, // For the new Pattern Weave VFX
                                leonardoDashEndY: 0,
                                // NEW ANGUS PROPERTIES
                                angusCharging: false,
                                angusChargeStartTime: 0,
                                angusBurstUsesLeft: 3, // Can only use 3 times per game
                                angusTimeStopActive: false,
                                angusTimeStopEndTime: 0,
                                angusTeleportActive: false,
                                // NEW DIDDY PROPERTIES
                                diddyBabyOilActive: false,
                                diddyBabyOilPhase: '', // 'subtitle1', 'running', 'ascension', 'subtitle2'
                                diddyBabyOilStartTime: 0,
                                diddySlickShotActive: false,
                                diddyOilSlickActive: false,
                                diddyOilSlickEndTime: 0,
                                // NEW DRIBBLING PROPERTIES
                                isDribbling: false,
                                dribbleEndTime: 0,
                                // HUDSON EMPEROR DRIBBLE PROPERTIES
                                hudsonEmperorDribbling: false,
                                hudsonEmperorDribbleStartTime: 0,
                                hudsonEmperorDribblePhase: '', // 'left', 'right'
                                hudsonEmperorDribbleStartX: 0,
                                hudsonEmperorDribbleStartY: 0,
                                hudsonEmperorDribbleMouseDir: 0, // Store mouse direction when ability is triggered
                                    };

                            const ball = {
                                x:W*0.5, y:H*0.5, r:10, vx:0, vy:0, friction:0.988, maxSpeed:12,
                                bounceDamping: 0.75, // Enhanced bounce physics
                                // NEW ASHER BALL PROPERTIES
                                isHoming: false,
                                homingTargetX: 0,
                                homingTargetY: 0,
                                homingEndTime: 0,
                            };

                            // AI Player
                            const aiPlayer = {
                                x: W*0.75, y: H*0.5, r: 18, speed: 0, vx: 0, vy: 0, maxSpd: 2.8, accel: 0.5, drag: 0.85, hasBall: false,
                                // AI behavior properties
                                targetX: 0, targetY: 0,
                                lastThinkTime: 0,
                                thinkInterval: 150, // AI thinks every 150ms (not super fast)
                                state: 'chase', // 'chase', 'defend', 'shoot', 'position'
                                shootPower: 0,
                                shootCharging: false,
                                shootStartTime: 0,
                                lastShotTime: 0,
                                shotCooldown: 1000, // 1 second between shots
                                defensiveX: W*0.8, // AI defends closer to right goal
                                skill: 0.8, // AI skill level (0-1), affects accuracy and decision making - IMPROVED!
                                // NEW AI PROPERTIES FOR STUNNING AND BALL PICKUP
                                isDribbling: false,
                                isStunned: false,
                                stunEndTime: 0,
                                ballPickupAttemptTime: 0,
                                lastBallPickupAttempt: 0,
                            };

                            const keys = {};
                            let mouse = {x:W/2, y:H/2, down:false};

                            let chargeStart = 0; let autoShotFired = false; let autoTimer = null;
                            const powerBar = document.getElementById('powerbar');
                            const powerFill = document.getElementById('powerfill');
                            const AUTO_MS = 2500; // Faster auto-shot for more dynamic gameplay

                            const ABILITY_COOLDOWN = 5500; // Slightly faster cooldowns for smoother gameplay
                            const ROBSAN_SPIN_DURATION = 2000;
                            const ROBSAN_CHARGE_DURATION = 2000;
                            const ECLIPSE_AURA_DURATION = 200;
                            const ECLIPSE_RETRIEVAL_DURATION = 500;
                            const VOID_DASH_DURATION = 200;
                            const VOID_DASH_SPEED = 25;

                            const XDRAKE_SUPERNOVA_DASH_DURATION = 250;
                            const XDRAKE_SUPERNOVA_DASH_SPEED = 30;
                            const XDRAKE_FOSSIL_FOOTWORK_DURATION = 150;
                            const XDRAKE_FOSSIL_FOOTWORK_SPEED = 18;
                            const XDRAKE_ANCIENT_APEX_CHARGE_DURATION = 1000;
                            const XDRAKE_ANCIENT_APEX_SHOT_POWER = 32;

                            const GOJO_RED_CHARGE_DURATION = 500;
                            const GOJO_RED_SHOT_POWER = 28;
                            const GOJO_LAPSE_BLUE_BALL_RADIUS = ball.r * 3;
                            const GOJO_LAPSE_BLUE_ORBIT_RADIUS = player.r * 4;
                            const GOJO_LAPSE_BLUE_ORBIT_SPEED = 10;
                            const GOJO_PURPLE_SPREAD_DISTANCE = 100;
                            const GOJO_PURPLE_CONVERGE_DURATION = 1500;
                            const GOJO_PURPLE_FINAL_SHOT_POWER = 40;
                            const GOJO_PURPLE_SHOCKWAVE_DURATION = 200;
                            let gojoPurpleShockwaveEndTime = 0;

                            const EDDIE_WE_ARE_DURATION = 10000;
                            const EDDIE_WE_ARE_SPEED_BOOST = 2; // Multiplier for speed
                            const EDDIE_VENOM_STRIKE_PULL_SPEED = 300; // Significantly faster
                            const EDDIE_VENOM_STRIKE_SHOT_POWER = 35;
                            const EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION = 1000; // 1 second aiming
                            const EDDIE_SYMBIOTE_MONTAGE_SHOT_POWER = 25; // Adjusted shot power
                            const EDDIE_SYMBIOTE_MONTAGE_TELEPORT_SPEED = 100; // Pixels per second for teleport
                            const PUDDLE_DURATION = 1500; // Duration for black puddles

                            const ZEUS_LIGHTNING_CHARGE_DURATION = 300;
                            const ZEUS_LIGHTNING_SHOT_POWER = 28;
                            const ZEUS_HEAVENLY_SHIELD_DURATION = 1500;
                            const ZEUS_HEAVENLY_SHIELD_RADIUS = player.r * 3.5;
                            const ZEUS_OLYMPUS_FURY_PULL_DURATION = 3000;
                            const ZEUS_OLYMPUS_FURY_AIM_DURATION = 1500;
                            const ZEUS_OLYMPUS_FURY_SHOT_POWER = 45;

                            // NEW ASHER ABILITY CONSTANTS
                            const ASHER_HOMING_SHOT_DURATION = 4000; // 4 seconds for the ball to home in
                            const ASHER_HOMING_SHOT_POWER = 18;
                            const ASHER_HOMING_TURN_RATE = 0.08; // How quickly the ball adjusts its course
                            const ASHER_STARFALL_CHARGE_DURATION = 800; // 0.8 seconds
                            const ASHER_STARFALL_ORBIT_SPEED = 25; // Radians per second
                            const ASHER_STARFALL_ORBIT_RADIUS = player.r + ball.r + 15;


                            // NEW LEONARDO ABILITY CONSTANTS
                    // NEW LEONARDO ABILITY CONSTANTS
                            const LEONARDO_FOCUS_SHOT_POWER = 26;
                            const LEONARDO_SHIELD_DURATION = 2500; // Increased duration to 2.5s
                            const LEONARDO_SHIELD_RADIUS = player.r * 4.5; // Slightly larger shield
                            const LEONARDO_SHIELD_PULL_STRENGTH = 0.03; // Slow pull effect
                            const LEONARDO_DASH_DURATION = 200;
                            const LEONARDO_DASH_SPEED = 28;
                            const LEONARDO_PATTERN_FIELD_DURATION = 1000; // Field lasts for 1s after dash
                            // NEW ANGUS ABILITY CONSTANTS
                            const ANGUS_CHARGE_DURATION = 2000; // 2 second charge time
                            const ANGUS_BURST_POWER = 45; // Very powerful shot
                            const ANGUS_TIME_STOP_DURATION = 3000; // 3 seconds of time stop
                            const ANGUS_TELEPORT_RANGE = 200; // Teleport range

                            // NEW BABY OIL GUY ABILITY CONSTANTS
                            const DIDDY_BABY_OIL_DURATION = 4000; // Total duration for baby oil sequence
                            const DIDDY_SUBTITLE_DURATION = 1500; // Time for each subtitle
                            const DIDDY_RUN_SPEED = 35; // Speed when running to ball
                            const DIDDY_ASCENSION_SPEED = 25; // Speed of ball ascension
                            const DIDDY_SLICK_SHOT_POWER = 30; // Slippery shot power
                            const DIDDY_OIL_SLICK_DURATION = 5000; // Oil slick duration

                            // CRISTIANO ABILITY CONSTANTS
                            const CRISTIANO_POWER_SHOT_POWER = 35; // Extremely powerful unblockable shot
                            const CRISTIANO_GOAT_TACKLE_RANGE = 200; // Extended range for teleporting to ball/AI
                            const CRISTIANO_PORTUGUESE_SPIRIT_DURATION = 12000; // 12 seconds boost
                            const CRISTIANO_PORTUGUESE_SPIRIT_SPEED_MULTIPLIER = 2.2; // Much higher speed boost
                            const CRISTIANO_PORTUGUESE_SPIRIT_SHOT_POWER_BONUS = 25; // Much higher shot power bonus

                            // HUDSON EMPEROR DRIBBLE CONSTANTS
                            const HUDSON_EMPEROR_DRIBBLE_DURATION = 800;
                            const HUDSON_EMPEROR_DRIBBLE_SPEED = 20; // Speed during dribble
                            const HUDSON_EMPEROR_DRIBBLE_DISTANCE = W * 0.5; // Half field distance

                            let abilityReadyAt = 0;
                            let shadowSpiralReadyAt = 0;
                            let eclipseGraspReadyAt = 0;
                            let voidDashReadyAt = 0;

                            let supernovaReadyAt = 0;
                            let fossilFootworkReadyAt = 0;
                            let ancientApexReadyAt = 0;

                            let gojoRedReadyAt = 0;
                            let gojoLapseBlueReadyAt = 0;
                            let gojoPurpleReadyAt = 0;

                            let eddieWeAreReadyAt = 0;
                            let eddieVenomStrikeReadyAt = 0;
                            let eddieSymbioteMontageReadyAt = 0;

                            let zeusLightningReadyAt = 0;
                            let zeusHeavenlyShieldReadyAt = 0;
                            let zeusOlympusFuryReadyAt = 0;

                            // NEW ASHER ABILITY TIMERS
                            let asherAutoGoalReadyAt = 0;
                            let asherBallTeleportReadyAt = 0;

                            // NEW LEONARDO ABILITY TIMERS
                            let leonardoFocusShotReadyAt = 0;
                            let leonardoShieldReadyAt = 0;
                            let leonardoDashReadyAt = 0;
                            // NEW ANGUS ABILITY TIMERS
                            let angusTimeStopReadyAt = 0;
                            let angusTeleportReadyAt = 0;

                            // NEW DIDDY ABILITY TIMERS
                            let diddyBabyOilReadyAt = 0;
                            let diddySlickShotReadyAt = 0;
                            let diddyOilSlickReadyAt = 0;

                            // CRISTIANO ABILITY TIMERS
                            let cristianoPowerShotReadyAt = 0;
                            let cristianoGoatTackleReadyAt = 0;
                            let cristianoPortugueseSpiritReadyAt = 0;

                            // HUDSON ABILITY TIMERS
                            let hudsonEmperorDribbleReadyAt = 0;
            const HUDSON_EMPEROR_DRIBBLE_COOLDOWN = 10000;

                            let vfx = {
                                trail:[], sparks:[], shockwaves:[], flashes:[], lines:[], 
                                robsanParticles:[], robsanAura:[], shadowTrails:[], robsanChargeAura:[],
                                eclipseAura:[], eclipseLines:[], voidTrails:[],
                                xdrakeSupernovaTrails: [], xdrakeFootworkDust: [], xdrakeApexAura: [],

                                gojoRedTrail: [],
                                gojoBlueOrbitParticles: [],
                                gojoPurpleCombineVFX: [],
                                gojoPurpleTrail: [],

                    // NEW LEONARDO VFX
                                leonardoFocusText: [],
                                leonardoFocusParticles: [],
                                leonardoShieldAura: [],
                                leonardoShieldParticles: [],
                                leonardoDashTrail: [],
                                leonardoDashParticles: [],
                                leonardoPatternField: [], // For the new dash utility
                                leonardoFocusTrail: [], // Fix: add missing array for focus shot trail
                                // NEW ANGUS VFX
                                angusChargeParticles: [],
                                angusBurstVFX: [],
                                angusTimeStopField: [],
                                angusTeleportTrail: [],
                                // NEW DIDDY VFX
                                diddyOilParticles: [],
                                diddyAscensionVFX: [],
                                diddyOilSlicks: [],
                                diddySlickTrail: [],

                                // CRISTIANO VFX
                                cristianoPowerShotTrail: [],
                                cristianoGoatTackleParticles: [],
                                cristianoPortugueseSpiritAura: [],
                                cristianoMovementTrail: [],

                                eddieWeAreAura: [],
                                eddieWeAreParticles: [],
                                eddieVenomTendrils: [],
                                eddieVenomShotTrail: [],
                                eddieSymbioteMontageAimAura: [],
                                blackPuddles: [],

                                zeusLightningParticles: [],
                                zeusLightningTrail: [],
                                zeusHeavenlyShieldWaves: [],
                                zeusHeavenlyShieldAura: [],
                                zeusOlympusFuryAura: [],
                                zeusOlympusFuryBallTrail: [],
                                zeusLightningChargeEffect: [],
                                zeusOlympusFuryPullLines: [],
                                zeusGroundScorches: [],

                                // NEW ASHER VFX
                                asherStarTrail: [],
                                asherTeleportBurst: [],
                                asherArrivalGlimmer: [],

                                hudsonEmperorDribbleTrail: [],
                                hudsonEmperorDribbleParticles: [],
                                hudsonEmperorDribbleAura: [],
                                robsanGroundRupture: [],
                                robsanEclipseWisps: [],
                                robsanVoidPuffs: [],
                                xdrakeSupernovaGroundCrack: [],
                                xdrakeFootworkLeaves: [],
                                xdrakeAncientApexGroundBurst: [],
                                gojoRedExplosion: [],
                                gojoLapseBluePullEffect: [],
                                gojoPurpleArcs: [],
                                eddieWeAreRipples: [],
                                eddieVenomBallSwirl: [],
                                eddieTeleportFlicker: [],

                                hudsonSpeedLines: [],
                                hudsonEnergyWaves: [],
                                robsanShadowClones: [],
                                robsanVoidRifts: [],
                                xdrakeNatureSpirits: [],
                                xdrakeTerraforms: [],
                                gojoInfinityBarriers: [],
                                gojoDomainExpansions: [],
                                eddieSymbioteSpikes: [],
                                eddieVenomDrops: [],
                                zeusThunderClouds: [],
                                zeusLightningBolts: [],

                                playerMovementTrail: [],

                                fieldCracks: [],
                                energyResidue: [],
                                shockwaveRings: [],

                                // NEW EPIC VFX SYSTEMS
                                epicExplosions: [],
                                massiveShockwaves: [],
                                screenDistortions: [],
                                energyNovas: [],
                                particleStorms: [],
                                chromaticAberrations: [],
                                timeRipples: [],
                                cosmicRifts: [],
                                elementalBursts: [],
                                dimensionalTears: [],
                                powerSurges: [],
                                mysticalRunes: [],
                                energyMatrixes: [],
                                celestialBeams: [],
                                quantumFluctuations: [],
                                vortexes: [],
                                hyperTrails: [],
                                auraExplosions: [],
                                realityBreaks: [],
                                cosmicWinds: []
                            }; 

                            let scoreL = 0;
                            let scoreR = 0;
                            let lastGoalTime = 0;

                            let last = performance.now(); 

                            let loopId = null;

                            function setGameState(state) {
                                gameState = state;
                                mainMenuScreen.classList.remove('active');
                                gameScreen.classList.remove('active');
                                isPlaying = false;
                                if (loopId) cancelAnimationFrame(loopId);

                                if (state === 'menu') {
                                    mainMenuScreen.classList.add('active');

                                    const movesbarContainer = slotC.closest('.movesbar');
                                    if (movesbarContainer) movesbarContainer.style.display = 'none';
                                } else if (state === 'game') {
                                    gameScreen.classList.add('active');
                                    const movesbarContainer = slotC.closest('.movesbar');
                                    if (movesbarContainer) movesbarContainer.style.display = 'flex';


                                    if (currentStyle === 'none') {
                                        if (movesbarContainer) movesbarContainer.style.display = 'none';
                                    } else if (currentStyle === 'hudson') { 
                                        slotC.style.display = 'flex';
                                        slotV.style.display = 'none'; 
                                        slotX.style.display = 'none'; 
                                    } else if (currentStyle === 'asher') {
                                        slotC.style.display = 'flex';
                                        slotV.style.display = 'flex';
                                        slotX.style.display = 'none';
                                    } else if (currentStyle === 'eddie' || currentStyle === 'zeus') {
                                        slotC.style.display = 'flex';
                                        slotV.style.display = 'flex';
                                        slotX.style.display = 'flex';
                                    } else if (currentStyle === 'robsan' || currentStyle === 'xdrake' || currentStyle === 'gojo') {
                                        slotC.style.display = 'flex';
                                        slotV.style.display = 'flex';
                                        slotX.style.display = 'flex';
                                    }
                                    resetGame();
                                    isPlaying = true;
                                    loop();
                                }
                            }

                            function showModal(modal) {
                                modal.classList.add('open');
                            }

                            function hideModal(modal) {
                                modal.classList.remove('open');
                            }

                            function setPlayerStyle(style) {
                                currentStyle = style;

                                styleNoneBtn.classList.toggle('active', style === 'none');
                                styleHudsonBtn.classList.toggle('active', style === 'hudson');
                                styleRobsanBtn.classList.toggle('active', style === 'robsan');
                                styleXDrakeBtn.classList.toggle('active', style === 'xdrake');
                                styleGojoBtn.classList.toggle('active', style === 'gojo');
                                styleEddieBtn.classList.toggle('active', style === 'eddie');
                                styleZeusBtn.classList.toggle('active', style === 'zeus');
                                styleAsherBtn.classList.toggle('active', style === 'asher'); // NEW ASHER BUTTON
                                styleLeonardoBtn.classList.toggle('active', style === 'leonardo'); // NEW LEONARDO BUTTON
                                styleAngusBtn.classList.toggle('active', style === 'angus'); // NEW ANGUS BUTTON
                                styleDiddyBtn.classList.toggle('active', style === 'diddy'); // NEW DIDDY BUTTON
                                styleCristianoBtn.classList.toggle('active', style === 'cristiano');




                                slotC.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher','leonardo', 'angus', 'diddy', 'cristiano', 'ready', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool');
                                slotV.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher','leonardo', 'angus', 'diddy', 'cristiano', 'ready', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool');
                                slotX.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher','leonardo', 'angus', 'diddy', 'cristiano', 'ready', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool');

                                if (style === 'hudson') {
                                    abilityNameCEl.textContent = 'Hudson Impact';
                                    abilityNameVEl.textContent = 'dribble like an emperor';
                                    abilityNameXEl.textContent = 'None';
                                    slotC.classList.add('hudson');
                                    slotV.classList.add('hudson');
                                    slotC.style.display = 'flex';
                                    slotV.style.display = 'flex';
                                    slotX.style.display = 'none';
                                } else if (style === 'robsan') {
                                    abilityNameCEl.textContent = 'Shadow Spiral';
                                    abilityNameVEl.textContent = 'Eclipse Grasp';
                                    abilityNameXEl.textContent = 'Void Dash';
                                    slotC.classList.add('robsan');
                                    slotV.classList.add('robsan');
                                    slotX.classList.add('robsan');
                                    slotC.style.display = 'flex';
                                    slotV.style.display = 'flex';
                                    slotX.style.display = 'flex';
                                } else if (style === 'xdrake') {
                                    abilityNameCEl.textContent = 'Supernova';
                                    abilityNameVEl.textContent = 'Fossilised Footwork';
                                    abilityNameXEl.textContent = 'Ancient Apex';
                                    slotC.classList.add('xdrake');
                                    slotV.classList.add('xdrake');
                                    slotX.classList.add('xdrake');
                                    slotC.style.display = 'flex';
                                    slotV.style.display = 'flex';
                                    slotX.style.display = 'flex';
                                } else if (style === 'gojo') {
                                    abilityNameCEl.textContent = 'Red';
                                    abilityNameVEl.textContent = 'Lapse Blue';
                                    abilityNameXEl.textContent = 'Purple';
                                    slotC.classList.add('gojo');
                                    slotV.classList.add('gojo');
                                    slotX.classList.add('gojo');
                                    slotC.style.display = 'flex';
                                    slotV.style.display = 'flex';
                                    slotX.style.display = 'flex';
                                } else if (style === 'eddie') {
                                    slotC.classList.add('eddie');
                                    slotV.classList.add('eddie');
                                    slotX.classList.add('eddie');
                                    slotC.style.display = 'flex';
                                    slotV.style.display = 'flex';
                                    slotX.style.display = 'flex';
                                    // Show awakening bar for Eddie
                                    awakeningBar.style.display = 'block';
                                    updateAwakeningBar();
                                    // Update move names based on awakening state
                                    updateEddieAwakeningMoves();
                                } else if (style === 'zeus') {
                                    abilityNameCEl.textContent = 'Lightning Bolt';
                                    abilityNameVEl.textContent = 'Heavenly Shield';
                                    abilityNameXEl.textContent = 'Olympus\' Fury';
                                    slotC.classList.add('zeus');
                                    slotV.classList.add('zeus');
                                    slotX.classList.add('zeus');
                                    slotC.style.display = 'flex';
                                    slotV.style.display = 'flex';
                                    slotX.style.display = 'flex';
                                } else if (style === 'asher') { // NEW ASHER STYLE BLOCK
                                    abilityNameCEl.textContent = 'Starfall Shot';
                                    abilityNameVEl.textContent = 'Celestial Pull';
                                    abilityNameXEl.textContent = 'None';
                                    slotC.classList.add('asher');
                                    slotV.classList.add('asher');
                                    slotC.style.display = 'flex';
                                    slotV.style.display = 'flex';
                                    slotX.style.display = 'none';
                                    } else if (style === 'leonardo') {
                                    abilityNameCEl.textContent = 'Focus Shot';
                                    abilityNameVEl.textContent = 'Sensory Shield';
                                    abilityNameXEl.textContent = 'Pattern Weave';
                                    slotC.classList.add('leonardo');
                                    slotV.classList.add('leonardo');
                                    slotX.classList.add('leonardo');
                                    slotC.style.display = 'flex';
                                    slotV.style.display = 'flex';
                                    slotX.style.display = 'flex';
                                    } else if (style === 'angus') {
                                    abilityNameCEl.textContent = `Power Burst (${player.angusBurstUsesLeft}/3)`;
                                    abilityNameVEl.textContent = 'Time Stop';
                                    abilityNameXEl.textContent = 'Shadow Teleport';
                                    slotC.classList.add('angus');
                                    slotV.classList.add('angus');
                                    slotX.classList.add('angus');
                                    slotC.style.display = 'flex';
                                    slotV.style.display = 'flex';
                                    slotX.style.display = 'flex';
                                } else if (style === 'diddy') {
                                    abilityNameCEl.textContent = 'Baby Oil Ascension';
                                    abilityNameVEl.textContent = 'Slick Shot';
                                    abilityNameXEl.textContent = 'Baby oil Blindness';
                                    slotC.classList.add('diddy');
                                    slotV.classList.add('diddy');
                                    slotX.classList.add('diddy');
                                    slotC.style.display = 'flex';
                                    slotV.style.display = 'flex';
                                    slotX.style.display = 'flex';
                                } else if (style === 'cristiano') {
                                    abilityNameCEl.textContent = 'Power Shot';
                                    abilityNameVEl.textContent = "GOAT's Tackle";
                                    abilityNameXEl.textContent = 'Portuguese Spirit';
                                    slotC.classList.add('cristiano');
                                    slotV.classList.add('cristiano');
                                    slotX.classList.add('cristiano');
                                    slotC.style.display = 'flex';
                                    slotV.style.display = 'flex';
                                    slotX.style.display = 'flex';
                                }
                                else {
                                    abilityNameCEl.textContent = 'no ability';
                                    abilityNameVEl.textContent = 'no ability';
                                    abilityNameXEl.textContent = 'no ability';
                                    slotC.style.display = 'none';
                                    slotV.style.display = 'none';
                                    slotX.style.display = 'none';
                                }

                                // Hide awakening bar for all characters except Eddie
                                if (style !== 'eddie') {
                                    awakeningBar.style.display = 'none';
                                }

                                const movesbarContainer = slotC.closest('.movesbar');
                                movesbarContainer.style.display = (style === 'none') ? 'none' : 'flex';


                                abilityReadyAt = 0;
                                shadowSpiralReadyAt = 0;
                                eclipseGraspReadyAt = 0;
                                voidDashReadyAt = 0;
                                supernovaReadyAt = 0;
                                fossilFootworkReadyAt = 0;
                                ancientApexReadyAt = 0;
                                gojoRedReadyAt = 0;
                                gojoLapseBlueReadyAt = 0;
                                gojoPurpleReadyAt = 0;
                                eddieWeAreReadyAt = 0;
                                eddieVenomStrikeReadyAt = 0;
                                eddieSymbioteMontageReadyAt = 0;
                                zeusLightningReadyAt = 0;
                                zeusHeavenlyShieldReadyAt = 0;
                                zeusOlympusFuryReadyAt = 0;
                                asherAutoGoalReadyAt = 0; // NEW ASHER
                                asherBallTeleportReadyAt = 0; // NEW ASHER
                                // Reset Cristiano ability timers
                                cristianoPowerShotReadyAt = 0;
                                cristianoGoatTackleReadyAt = 0;
                                cristianoPortugueseSpiritReadyAt = 0;
                            }



                            window.onload = function() {
                                setGameState('menu');
                                setPlayerStyle('hudson');
                            };



                            playBtn.addEventListener('click', () => showModal(aiModal));
                            tutorialBtn.addEventListener('click', () => showModal(tutorialModal));
                            creditsBtn.addEventListener('click', () => showModal(creditsModal));
                            stylesBtn.addEventListener('click', () => showModal(stylesModal));
                            exitBtn.addEventListener('click', () => setGameState('menu'));
                            closeCreditsBtn.addEventListener('click', () => hideModal(creditsModal));
                            closeStylesBtn.addEventListener('click', () => hideModal(stylesModal));
                            closeTutorialBtn.addEventListener('click', () => hideModal(tutorialModal));
                            closeAiBtn.addEventListener('click', () => hideModal(aiModal));
                            playWithAiBtn.addEventListener('click', () => {
                                aiEnabled = true;
                                hideModal(aiModal);
                                setGameState('game');
                            });
                            playWithoutAiBtn.addEventListener('click', () => {
                                aiEnabled = false;
                                hideModal(aiModal);
                                setGameState('game');
                            });

                            styleNoneBtn.addEventListener('click', () => setPlayerStyle('none'));
                            styleHudsonBtn.addEventListener('click', () => setPlayerStyle('hudson'));
                            styleRobsanBtn.addEventListener('click', () => setPlayerStyle('robsan'));
                            styleXDrakeBtn.addEventListener('click', () => setPlayerStyle('xdrake'));
                            styleGojoBtn.addEventListener('click', () => setPlayerStyle('gojo'));
                            styleEddieBtn.addEventListener('click', () => setPlayerStyle('eddie'));
                            styleZeusBtn.addEventListener('click', () => setPlayerStyle('zeus'));
                            styleAsherBtn.addEventListener('click', () => setPlayerStyle('asher')); // NEW ASHER LISTENER
                            styleLeonardoBtn.addEventListener('click', () => setPlayerStyle('leonardo'));
                            styleAngusBtn.addEventListener('click', () => setPlayerStyle('angus'));
                            styleDiddyBtn.addEventListener('click', () => setPlayerStyle('diddy'));
                            styleCristianoBtn.addEventListener('click', () => setPlayerStyle('cristiano'));

                            window.addEventListener('keydown', e => {
                                if (gameState !== 'game') return;
                                const k = e.key.toLowerCase();
                                keys[k] = true;

                                if (k === 'e') {
                                    // E button now specifically for stealing ball from AI
                                    const d = Math.hypot(ball.x - player.x, ball.y - player.y);
                                    if (aiEnabled && aiPlayer.hasBall && d < player.r + ball.r + 20 && !player.hasBall && !player.eddieSymbioteMontageActive) {
                                        // STEAL BALL FROM AI
                                        aiPlayer.hasBall = false;
                                        player.hasBall = true;
                                        ball.vx = 0;
                                        ball.vy = 0;
                                        showNotification('yoink got the ball lol', 'success');
                                    } else if (!aiEnabled || !aiPlayer.hasBall) {
                                        showNotification('e is for stealing from ai step on ball to pick up', 'info');
                                    } else if (d >= player.r + ball.r + 20) {
                                        showNotification('too far from ai to steal smh', 'warning');
                                    } else if (player.hasBall) {
                                        showNotification('you already got the ball bestie', 'info');
                                    }
                                } else if (k === 'q') {
                                    // Dribbling mechanic
                                    if (player.hasBall && !player.isDribbling) {
                                        player.isDribbling = true;
                                        player.dribbleEndTime = performance.now() + 3000; // 3 seconds of dribbling
                                        player.maxSpd *= 1.2; // Slight speed boost while dribbling
                                        showNotification('dribbling activated fr', 'success');
                                    }
                                } else if (k === 'c') {
                                    if (currentStyle === 'hudson') {
                                        tryKaiser();
                                    } else if (currentStyle === 'robsan') {
                                        tryRobsanShadowSpiral();
                                    } else if (currentStyle === 'xdrake') {
                                        tryXDrakeSupernova();
                                    } else if (currentStyle === 'gojo') {
                                        tryGojoRed();
                                    } else if (currentStyle === 'eddie') {
                                        if (player.eddieAwakeningActive) {
                                            tryEddieVenomDevastation();
                                        } else {
                                            tryEddieWeAre();
                                        }
                                    } else if (currentStyle === 'zeus') {
                                        tryZeusLightningBolt();
                                    } else if (currentStyle === 'leonardo') {
                                        tryLeonardoFocusShot();
                                    } else if (currentStyle === 'asher') { // NEW ASHER
                                        tryAsherAutoGoal();
                                    } else if (currentStyle === 'angus') { // NEW ANGUS
                                        tryAngusPowerBurst();
                                    } else if (currentStyle === 'diddy') { // NEW DIDDY
                                        tryDiddyBabyOilAscension();
                                    } else if (currentStyle === 'cristiano') {
                                        tryCristianoPowerShot();
                                    }
                                } else if (k === 'v') {
                                    if (currentStyle === 'hudson') {
                                        tryHudsonEmperorDribble();
                                    } else if (currentStyle === 'robsan') {
                                        tryRobsanEclipseGrasp();
                                    } else if (currentStyle === 'xdrake') {
                                        tryXDrakeFossilFootwork();
                                    } else if (currentStyle === 'gojo') {
                                        tryGojoLapseBlue();
                                    } else if (currentStyle === 'eddie') {
                                        if (player.eddieAwakeningActive) {
                                            tryEddieShadowRealm();
                                        } else {
                                            tryEddieVenomStrike();
                                        }
                                    } else if (currentStyle === 'zeus') {
                                        tryZeusHeavenlyShield();
                                    } else if (currentStyle === 'leonardo') {
                                        tryLeonardoSensoryShield();

                                    } else if (currentStyle === 'asher') { // NEW ASHER
                                        tryAsherBallTeleport();
                                    } else if (currentStyle === 'leonardo') {
                                        tryLeonardoSensoryShield();
                                    } else if (currentStyle === 'angus') { // NEW ANGUS
                                        tryAngusTimeStop();
                                    } else if (currentStyle === 'diddy') { // NEW DIDDY
                                        tryDiddySlickShot();
                                    } else if (currentStyle === 'cristiano') {
                                        tryCristianoGoatTackle();
                                    }
                                } else if (k === 'x') {
                                    if (currentStyle === 'robsan') {
                                        tryRobsanVoidDash();
                                    } else if (currentStyle === 'xdrake') {
                                        tryXDrakeAncientApex();
                                    } else if (currentStyle === 'gojo') {
                                        tryGojoPurple();
                                    } else if (currentStyle === 'eddie') {
                                        tryEddieSymbioteMontage();
                                    } else if (currentStyle === 'zeus') {
                                        tryZeusOlympusFury();
                                    } else if (currentStyle === 'leonardo') {
                                        tryLeonardoPatternWeave();
                                    } else if (currentStyle === 'angus') { // NEW ANGUS
                                        tryAngusShadowTeleport();
                                    } else if (currentStyle === 'diddy') { // NEW DIDDY
                                        tryDiddyOilSlickTrap();
                                    } else if (currentStyle === 'cristiano') {
                                        tryCristianoPortugueseSpirit();
                                    }
                                } else if (k === 'g') {
                                    // Eddie Awakening Trigger
                                    if (currentStyle === 'eddie' && player.eddieAwakeningProgress >= 100 && player.hasBall && !player.eddieAwakeningActive) {
                                        triggerEddieAwakening();
                                    }
                                }
                            });
                            window.addEventListener('keyup', e => {
                                if (gameState !== 'game') return;
                                keys[e.key.toLowerCase()] = false;
                            });
                            canvas.addEventListener('mousemove', e => {
                                if (gameState !== 'game') return;
                                const rect = canvas.getBoundingClientRect();
                                mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
                                mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
                            });
                            canvas.addEventListener('mousedown', () => {
                                if (gameState !== 'game') return;

                                if (!player.spinning && !player.charging && !player.telekinising && !player.dashing &&
                                    !player.xdrakeSupernovaDashing && !player.xdrakeFossilFootworking && !player.xdrakeAncientApexCharging &&
                                    !player.gojoPurpleActive && !player.gojoRedCharging && !player.eddieVenomStrikeActive && !player.eddieSymbioteMontageActive &&
                                    !player.zeusLightningCharging && !player.zeusOlympusFuryActive && !player.asherAutoGoalActive &&
                                    player.hasBall) {
                                    mouse.down = true;
                                    chargeStart = performance.now();
                                    autoShotFired = false;
                                    powerBar.style.opacity = 1;
                                    autoTimer = setTimeout(() => {
                                        if (mouse.down && player.hasBall && !autoShotFired) {
                                            autoShotFired = true;
                                            shoot(1.25);
                                            endCharge();
                                        }
                                    }, AUTO_MS);
                                } else if (currentStyle === 'xdrake' && player.xdrakeAncientApexCharging) {
                                     mouse.down = true;
                                     powerBar.style.opacity = 1;
                                } else if (currentStyle === 'gojo' && player.gojoRedCharging) {
                                    mouse.down = true;
                                    powerBar.style.opacity = 1;
                                } else if (currentStyle === 'zeus' && player.zeusLightningCharging) {
                                     mouse.down = true;
                                     powerBar.style.opacity = 1;
                                } else if (currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming') {
                                     mouse.down = true;
                                     powerBar.style.opacity = 1;
                                }
                            });
                            window.addEventListener('mouseup', () => {
                                if (gameState !== 'game') return;

                                if (!player.spinning && !player.charging && !player.telekinising && !player.dashing &&
                                    !player.xdrakeSupernovaDashing && !player.xdrakeFossilFootworking && !player.xdrakeAncientApexCharging &&
                                    !player.gojoPurpleActive && !player.gojoRedCharging && !player.asherAutoGoalActive &&
                                    mouse.down && player.hasBall && !autoShotFired && !player.zeusLightningCharging) {
                                    const held = (performance.now() - chargeStart);
                                    const t = clamp(held / AUTO_MS, 0, 1);
                                    const scale = lerp(0.55, 1.0, t);
                                    shoot(scale);
                                } else if (currentStyle === 'xdrake' && player.xdrakeAncientApexCharging && mouse.down) {
                                     xdrakeAncientApexShoot(1.0);
                                     player.xdrakeAncientApexCharging = false;
                                     endCharge();
                                } else if (currentStyle === 'gojo' && player.gojoRedCharging) {
                                    if ((performance.now() - player.gojoRedChargeStartTime) < GOJO_RED_CHARGE_DURATION) {
                                        player.gojoRedCharging = false;
                                        clearTimeout(autoTimer);
                                        endCharge();
                                    }
                                } else if (currentStyle === 'zeus' && player.zeusLightningCharging) {
                                     if ((performance.now() - player.zeusLightningChargeStartTime) < ZEUS_LIGHTNING_CHARGE_DURATION) {
                                        player.zeusLightningCharging = false;
                                        clearTimeout(autoTimer);
                                        endCharge();
                                    }
                                } else if (currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming' && mouse.down) {
                                     zeusOlympusFuryShoot();
                                }
                                endCharge();
                            });

                            const clamp=(n,min,max)=>Math.max(min,Math.min(max,n));
                            const lerp=(a,b,t)=>a+(b-a)*t;

                            function showNotification(message, type = 'error') {
                                const notification = document.getElementById('notification');
                                notification.textContent = message;
                                notification.className = `notification ${type}`;
                                notification.classList.add('show');

                                setTimeout(() => {
                                    notification.classList.remove('show');
                                }, 2000);
                            }

                            function getRGBA(colorStr, alpha) {
                                if (colorStr.startsWith('#')) {
                                    const hex = colorStr.slice(1);
                                    const r = parseInt(hex.substring(0, 2), 16);
                                    const g = parseInt(hex.substring(2, 4), 16);
                                    const b = parseInt(hex.substring(4, 6), 16);
                                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                                } else if (colorStr.startsWith('rgb(')) {
                                    const parts = colorStr.slice(4, -1).split(',').map(s => s.trim());
                                    return `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${alpha})`;
                                } else if (colorStr.startsWith('rgba(')) {
                                    const parts = colorStr.slice(5, -1).split(',').map(s => s.trim());
                                    const a = parseFloat(parts[3]);
                                    return `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${alpha * a})`;
                                }

                                return `rgba(0, 0, 0, ${alpha})`;
                            }

                            function endCharge(){
                                mouse.down=false;
                                chargeStart=0;
                                clearTimeout(autoTimer); autoTimer=null;
                                powerBar.style.opacity=0.6;
                                powerFill.style.width='0%';
                                // Smooth power bar reset
                                powerFill.style.transition = 'width 0.3s ease-out';
                                setTimeout(() => {
                                    powerFill.style.transition = 'width 0.06s ease-out';
                                }, 300);
                                player.gojoRedCharging = false;
                                player.zeusLightningCharging = false;
                            }


                            function updatePlayer(dt){
                                const now = performance.now();

                                // Handle dribbling timeout
                                if (player.isDribbling && now > player.dribbleEndTime) {
                                    player.isDribbling = false;
                                    player.maxSpd = player.maxSpd / 1.2; // Restore original speed
                                    showNotification('dribbling ended', 'info');
                                }

                                // Handle Hudson Emperor Dribble
                                if (player.hudsonEmperorDribbling) {
                                    const dribbleDuration = now - player.hudsonEmperorDribbleStartTime;
                                    const halfDuration = HUDSON_EMPEROR_DRIBBLE_DURATION / 2;
                                    
                                    if (dribbleDuration <= halfDuration) {
                                        // Left curve phase - use mouse direction with left offset
                                        player.hudsonEmperorDribblePhase = 'left';
                                        const progress = dribbleDuration / halfDuration;
                                        const angle = player.hudsonEmperorDribbleMouseDir - Math.PI/3; // 60 degrees left of mouse direction
                                        const targetX = player.hudsonEmperorDribbleStartX + Math.cos(angle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE * progress;
                                        const targetY = player.hudsonEmperorDribbleStartY + Math.sin(angle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE * progress;
                                        
                                        player.vx = (targetX - player.x) * 0.2;
                                        player.vy = (targetY - player.y) * 0.2;
                                    } else if (dribbleDuration <= HUDSON_EMPEROR_DRIBBLE_DURATION) {
                                        // Right curve phase - use mouse direction with right offset
                                        player.hudsonEmperorDribblePhase = 'right';
                                        const progress = (dribbleDuration - halfDuration) / halfDuration;
                                        const leftAngle = player.hudsonEmperorDribbleMouseDir - Math.PI/3;
                                        const midX = player.hudsonEmperorDribbleStartX + Math.cos(leftAngle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE;
                                        const midY = player.hudsonEmperorDribbleStartY + Math.sin(leftAngle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE;
                                        
                                        const angle = player.hudsonEmperorDribbleMouseDir + Math.PI/3; // 60 degrees right of mouse direction
                                        const targetX = midX + Math.cos(angle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE * progress;
                                        const targetY = midY + Math.sin(angle) * HUDSON_EMPEROR_DRIBBLE_DISTANCE * progress;
                                        
                                        player.vx = (targetX - player.x) * 0.2;
                                        player.vy = (targetY - player.y) * 0.2;
                                    } else {
                                        // End emperor dribble
                                        player.hudsonEmperorDribbling = false;
                                        player.hudsonEmperorDribblePhase = '';
                                        player.vx = 0;
                                        player.vy = 0;
                                        showNotification('emperor dribble complete fr', 'success');
                                    }
                                    
                                    // Generate emperor dribble effects during movement
                                    if (Math.random() < 0.6) {
                                        vfx.hudsonEmperorDribbleTrail.push(newHudsonEmperorTrail(player.x, player.y, player.hudsonEmperorDribblePhase));
                                        vfx.hudsonEmperorDribbleParticles.push(newHudsonEmperorParticle(player.x, player.y, player.hudsonEmperorDribblePhase));
                                    }
                                    if (Math.random() < 0.3) {
                                        vfx.hudsonEmperorDribbleAura.push(newHudsonEmperorAura(player.x, player.y));
                                    }
                                }

                                let ax=0, ay=0;
                                if(keys['w']||keys['arrowup']) ay-=player.accel;
                                if(keys['s']||keys['arrowdown']) ay+=player.accel;
                                if(keys['a']||keys['arrowleft']) ax-=player.accel;
                                if(keys['d']||keys['arrowright']) ax+=player.accel;


                                const isPlayerMovementRestricted = player.spinning || player.charging || player.telekinising || player.dashing ||
                                                                   player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking ||
                                                                   player.xdrakeAncientApexCharging || player.gojoPurpleActive || player.gojoRedCharging ||
                                                                   player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                                                   player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive;

                                if (!isPlayerMovementRestricted) {

                                    // Smoother acceleration with interpolation
                                    const accelSmoothing = 0.8;
                                    player.vx = player.vx * accelSmoothing + (player.vx + ax) * (1 - accelSmoothing);
                                    player.vy = player.vy * accelSmoothing + (player.vy + ay) * (1 - accelSmoothing);

                                    const sp=Math.hypot(player.vx, player.vy);
                                    let currentMaxSpd = player.maxSpd;
                                    if (currentStyle === 'eddie' && player.eddieWeAreActive) {
                                        currentMaxSpd = player.eddieWeAreOriginalMaxSpd * EDDIE_WE_ARE_SPEED_BOOST;
                                    }
                                    if(sp>currentMaxSpd){ player.vx*=currentMaxSpd/sp; player.vy*=currentMaxSpd/sp; }

                                    if(ax===0 && ay===0){ 
                                        // Enhanced drag with smoother deceleration
                                        const smoothDrag = player.drag * 0.98;
                                        player.vx *= smoothDrag; 
                                        player.vy *= smoothDrag; 
                                        // Stop very small movements to prevent jitter
                                        if (Math.abs(player.vx) < 0.01) player.vx = 0;
                                        if (Math.abs(player.vy) < 0.01) player.vy = 0;
                                    }
                                } else {

                                    player.vx *= player.drag;
                                    player.vy *= player.drag;
                                }

                                // Symbiote Montage logic
                                if (currentStyle === 'eddie' && player.eddieSymbioteMontageActive) {
                                    if (player.eddieSymbioteMontagePhase === 'teleporting') {
                                        const progress = clamp((now - player.eddieSymbioteMontageTeleportStartTime) / (player.eddieSymbioteMontageTeleportEndTime - player.eddieSymbioteMontageTeleportStartTime), 0, 1);
                                        player.x = lerp(player.eddieSymbioteMontageStartPlayerPos.x, player.eddieSymbioteMontageCurrentTeleportTarget.x, progress);
                                        player.y = lerp(player.eddieSymbioteMontageStartPlayerPos.y, player.eddieSymbioteMontageCurrentTeleportTarget.y, progress);

                                        if (player.hasBall) {
                                            const ballOffsetDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                                            ball.x = player.x + Math.cos(ballOffsetDir) * (player.r + ball.r + 4);
                                            ball.y = player.y + Math.sin(ballOffsetDir) * (player.r + ball.r + 4);
                                            ball.vx = player.vx;
                                            ball.vy = player.vy;
                                        }

                                        if (progress >= 1) {
                                            vfx.blackPuddles.push(newBlackPuddle(player.x, player.y));
                                            player.eddieSymbioteMontageTeleportCount++;
                                            if (player.eddieSymbioteMontageTeleportCount < 3) {
                                                startNewSymbioteMontageTeleport();
                                            } else {
                                                player.x = W / 2;
                                                player.y = H / 2;
                                                player.vx = 0;
                                                player.vy = 0;
                                                const ballOffsetDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                                                ball.x = player.x + Math.cos(ballOffsetDir) * (player.r + ball.r + 4);
                                                ball.y = player.y + Math.sin(ballOffsetDir) * (player.r + ball.r + 4);
                                                player.hasBall = true;

                                                player.eddieSymbioteMontagePhase = 'aiming';
                                                player.eddieSymbioteMontageAimStartTime = now;

                                                vfx.eddieSymbioteMontageAimAura.push({
                                                    x: player.x, y: player.y,
                                                    end: now + EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION,
                                                    radius: player.r * 2.5,
                                                    t: 0, life: EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION
                                                });
                                            }
                                        }
                                    } else if (player.eddieSymbioteMontagePhase === 'aiming') {
                                        player.vx = 0;
                                        player.vy = 0;

                                        if (!player.eddieSymbioteMontageShotFired && (now - player.eddieSymbioteMontageAimStartTime) >= EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION) {

                                            const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                                            ball.vx = Math.cos(dir) * EDDIE_SYMBIOTE_MONTAGE_SHOT_POWER;
                                            ball.vy = Math.sin(dir) * EDDIE_SYMBIOTE_MONTAGE_SHOT_POWER;
                                            ball.maxSpeed = 100000;
                                            player.hasBall = false;
                                            player.eddieSymbioteMontageShotFired = true;


                                            vfx.eddieVenomShotTrail.push({
                                                end: performance.now() + 600,
                                                w: 20,
                                                colorStart: getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-trail-start'),
                                                colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-trail-end')
                                            });
                                            shockwave(player.x, player.y, 25, 'eddie-venom');

                                            const origFric = ball.friction;
                                            ball.friction = 0.99;
                                            setTimeout(() => { ball.friction = origFric; ball.maxSpeed = 18; }, 600);

                                            player.eddieSymbioteMontageActive = false;
                                            player.eddieSymbioteMontageAimStartTime = 0;
                                            player.eddieSymbioteMontageShotFired = false;
                                        }
                                    }
                                }


                                // Store previous position for movement trails
                                const prevX = player.x;
                                const prevY = player.y;
                                
                                player.x+=player.vx; player.y+=player.vy;
                                
                                // Generate movement trail for Cristiano when Portuguese Spirit is active
                                if (currentStyle === 'cristiano' && player.cristianoPortugueseSpiritActive) {
                                    const moveDistance = Math.hypot(player.x - prevX, player.y - prevY);
                                    if (moveDistance > 2) { // Only create trail when moving fast enough
                                        vfx.cristianoMovementTrail.push({
                                            startX: prevX,
                                            startY: prevY,
                                            endX: player.x,
                                            endY: player.y,
                                            life: 400,
                                            t: 0
                                        });
                                    }
                                }

                                const left=margin, right=W-margin, top=margin, bottom=H-margin;
                                const currentR = player.r;
                                if(player.x-currentR<left){ player.x=left+currentR; player.vx*=-0.2; }
                                if(player.x+currentR>right){ player.x=right-currentR; player.vx*=-0.2; }
                                if(player.y-currentR<top){ player.y=top+currentR; player.vy*=-0.2; }
                                if(player.y+currentR>bottom){ player.y=bottom-currentR; player.vy*=-0.2; }


                                if (player.spinning) {
                                    player.spinTimer -= dt;
                                    if (player.spinTimer <= 0) {
                                        player.spinning = false;
                                        player.spinTimer = 0;
                                        player.charging = true;
                                        player.chargeTimer = ROBSAN_CHARGE_DURATION;
                                        vfx.robsanChargeAura.push({x:player.x, y:player.y, end:performance.now() + ROBSAN_CHARGE_DURATION, radius:player.r*1.2, t:0, life:ROBSAN_CHARGE_DURATION});
                                    }
                                }
                                if (player.charging) {
                                    player.chargeTimer -= dt;
                                    if (player.chargeTimer <= 0) {
                                        player.charging = false;
                                        player.chargeTimer = 0;
                                    }
                                }

                                if (player.dashing) {
                                    player.dashTimer -= dt;
                                    if (player.dashTimer <= 0) {
                                        player.dashing = false;
                                        player.dashTimer = 0;
                                        vfx.robsanVoidPuffs.push(newRobsanVoidPuff(player.x, player.y, 'end'));
                                    }
                                }

                                if (player.xdrakeSupernovaDashing) {
                                    player.xdrakeSupernovaDashTimer -= dt;
                                    if (player.xdrakeSupernovaDashTimer <= 0) {
                                        player.xdrakeSupernovaDashing = false;
                                        player.xdrakeSupernovaDashTimer = 0;
                                    }
                                }

                                if (player.xdrakeFossilFootworking) {
                                    player.xdrakeFossilFootworkTimer -= dt;
                                    if (player.xdrakeFossilFootworkTimer <= 0) {
                                        player.xdrakeFossilFootworking = false;
                                        player.xdrakeFossilFootworkTimer = 0;
                                    }
                                }

                                if (player.xdrakeAncientApexCharging) {
                                    const chargeDuration = now - player.ancientApexChargeTimer;
                                    if (chargeDuration >= XDRAKE_ANCIENT_APEX_CHARGE_DURATION && player.hasBall && mouse.down) {
                                         xdrakeAncientApexShoot(1.0);
                                         player.xdrakeAncientApexCharging = false;
                                         endCharge();
                                    }
                                }


                                if (player.gojoLapseBlueActive && player.gojoLapseBlueBall) {
                                    player.gojoLapseBlueBall.angle += player.gojoLapseBlueBall.speed * (dt / 1000);
                                    player.gojoLapseBlueBall.x = player.x + Math.cos(player.gojoLapseBlueBall.angle) * player.gojoLapseBlueBall.orbitRadius;
                                    player.gojoLapseBlueBall.y = player.y + Math.sin(player.gojoLapseBlueBall.angle) * player.gojoLapseBlueBall.orbitRadius;


                                    vfx.gojoBlueOrbitParticles.push({
                                        x: player.gojoLapseBlueBall.x,
                                        y: player.gojoLapseBlueBall.y,
                                        life: 200 + Math.random() * 200, t: 0, r: 2 + Math.random() * 3,
                                        vx: -player.vx * 0.2 + (Math.random() - 0.5) * 0.5,
                                        vy: -player.vy * 0.2 + (Math.random() - 0.5) * 0.5,
                                        color: 'rgba(49, 130, 206,'
                                    });
                                }


                                if (player.gojoPurpleActive && player.gojoPurpleConverging) {

                                    const convergenceProgress = clamp((now - player.gojoPurpleConvergenceStartTime) / GOJO_PURPLE_CONVERGE_DURATION, 0, 1);


                                    const dir = player.gojoPurpleInitialDir;
                                    const spreadDist = GOJO_PURPLE_SPREAD_DISTANCE;
                                    const leftSpreadX = player.x + Math.cos(dir - Math.PI/2) * spreadDist;
                                    const leftSpreadY = player.y + Math.sin(dir - Math.PI/2) * spreadDist;
                                    const rightSpreadX = player.x + Math.cos(dir + Math.PI/2) * spreadDist;
                                    const rightSpreadY = player.y + Math.sin(dir + Math.PI/2) * spreadDist;


                                    const targetX = player.x;
                                    const targetY = player.y;

                                    player.gojoPurpleLeftBall.x = lerp(leftSpreadX, targetX, convergenceProgress);
                                    player.gojoPurpleLeftBall.y = lerp(leftSpreadY, targetY, convergenceProgress);

                                    player.gojoPurpleRightBall.x = lerp(rightSpreadX, targetX, convergenceProgress);
                                    player.gojoPurpleRightBall.y = lerp(rightSpreadY, targetY, convergenceProgress);


                                    if (convergenceProgress >= 1 && !player.gojoPurpleShotFired) {

                                        const finalX = (player.gojoPurpleLeftBall.x + player.gojoPurpleRightBall.x) / 2;
                                        const finalY = (player.gojoPurpleLeftBall.y + player.gojoPurpleRightBall.y) / 2;

                                        vfx.gojoPurpleCombineVFX.push({x: finalX, y: finalY, t: 0, life: GOJO_PURPLE_SHOCKWAVE_DURATION, radius: GOJO_LAPSE_BLUE_BALL_RADIUS * 1.5});
                                        shockwave(finalX, finalY, GOJO_LAPSE_BLUE_BALL_RADIUS * 1.5, 'gojo-purple');

                                        gojoPurpleShockwaveEndTime = now + GOJO_PURPLE_SHOCKWAVE_DURATION;
                                        player.gojoPurpleShotFired = true;

                                        for(let i=0; i<8; i++) {
                                            vfx.gojoPurpleArcs.push(newGojoPurpleArc(finalX, finalY, i * (Math.PI / 4)));
                                        }
                                    }
                                }


                                if (player.gojoPurpleShotFired && now >= gojoPurpleShockwaveEndTime && gojoPurpleShockwaveEndTime !== 0) {
                                     if (player.gojoPurpleLeftBall && player.gojoPurpleRightBall) {
                                         const finalX = (player.gojoPurpleLeftBall.x + player.gojoPurpleRightBall.x) / 2;
                                         const finalY = (player.gojoPurpleLeftBall.y + player.gojoPurpleRightBall.y) / 2;
                                         shootPurpleShot(finalX, finalY, player.gojoPurpleInitialDir);
                                     }

                                     player.gojoPurpleActive = false;
                                     player.gojoPurpleConverging = false;
                                     player.gojoPurpleConvergenceStartTime = 0;
                                     player.gojoPurpleLeftBall = null;
                                     player.gojoPurpleRightBall = null;
                                     player.gojoPurpleInitialDir = 0;
                                     player.gojoPurpleShotFired = false;
                                     gojoPurpleShockwaveEndTime = 0;


                                     player.x = W * 0.25;
                                     player.y = H * 0.5;
                                     player.vx = 0;
                                     player.vy = 0;
                                }


                                if (currentStyle === 'eddie' && player.eddieWeAreActive && now >= player.eddieWeAreEndTime) {
                                    player.eddieWeAreActive = false;
                                    player.maxSpd = player.eddieWeAreOriginalMaxSpd;
                                    const currentSpeed = Math.hypot(player.vx, player.vy);
                                    if (currentSpeed > player.maxSpd) {
                                        player.vx *= player.maxSpd / currentSpeed;
                                        player.vy *= player.maxSpd / currentSpeed;
                                    }
                                }

                                // Check if Cristiano's Portuguese Spirit boost should end
                                if (currentStyle === 'cristiano' && player.cristianoPortugueseSpiritActive && now >= player.cristianoPortugueseSpiritEndTime) {
                                    player.cristianoPortugueseSpiritActive = false;
                                    player.maxSpd = player.maxSpd / CRISTIANO_PORTUGUESE_SPIRIT_SPEED_MULTIPLIER;
                                    const currentSpeed = Math.hypot(player.vx, player.vy);
                                    if (currentSpeed > player.maxSpd) {
                                        player.vx *= player.maxSpd / currentSpeed;
                                        player.vy *= player.maxSpd / currentSpeed;
                                    }
                                    showNotification('portuguese spirit ended', 'info');
                                }

                                if (currentStyle === 'zeus' && player.zeusHeavenlyShieldActive) {
                                    if (now >= player.zeusHeavenlyShieldEndTime) {
                                        player.zeusHeavenlyShieldActive = false;
                                        vfx.zeusHeavenlyShieldAura = [];
                                    } else {
                                        if (Math.random() < 0.2) {
                                            vfx.zeusHeavenlyShieldWaves.push(newZeusShieldWave(player.x, player.y));
                                        }
                                    }
                                }

                                if (currentStyle === 'zeus' && player.zeusLightningCharging) {
                                    const chargeDuration = now - player.zeusLightningChargeStartTime;
                                    if (chargeDuration >= ZEUS_LIGHTNING_CHARGE_DURATION && player.hasBall && mouse.down) {
                                        zeusLightningShoot();
                                        player.zeusLightningCharging = false;
                                        vfx.zeusLightningChargeEffect = [];
                                        endCharge();
                                    } else {
                                        if (Math.random() < 0.3) {
                                            vfx.zeusLightningChargeEffect.push(newZeusLightningChargeParticle(player.x, player.y));
                                        }
                                    }
                                }

                                if (currentStyle === 'leonardo' && player.leonardoShieldActive && now >= player.leonardoShieldEndTime) {
                                    player.leonardoShieldActive = false;
                                }
                                if (currentStyle === 'leonardo' && player.leonardoDashing) {
                                    player.leonardoDashTimer -= dt;
                                    if (player.leonardoDashTimer <= 0) {
                                        player.leonardoDashing = false;
                                    }
                                }

                                if (currentStyle === 'zeus' && player.zeusOlympusFuryActive) {
                                    if (player.zeusOlympusFuryPhase === 'pulling') {
                                        const pullTimeElapsed = now - player.zeusOlympusFuryPullStartTime;
                                        if (pullTimeElapsed >= ZEUS_OLYMPUS_FURY_PULL_DURATION || player.hasBall) {
                                            player.zeusOlympusFuryPhase = 'aiming';
                                            player.zeusOlympusFuryAimStartTime = now;
                                            player.hasBall = true;

                                            vfx.zeusOlympusFuryPullLines = [];

                                            vfx.zeusOlympusFuryAura.push({
                                                x: player.x, y: player.y,
                                                end: now + ZEUS_OLYMPUS_FURY_AIM_DURATION,
                                                radius: player.r * 2.5,
                                                t: 0, life: ZEUS_OLYMPUS_FURY_AIM_DURATION
                                            });
                                        } else {
                                            vfx.zeusOlympusFuryPullLines.push(newZeusOlympusFuryPullLine(player.x, player.y, ball.x, ball.y));
                                        }
                                    } else if (player.zeusOlympusFuryPhase === 'aiming') {
                                        player.vx = 0;
                                        player.vy = 0;

                                        if (!player.zeusOlympusFuryShotFired && (now - player.zeusOlympusFuryAimStartTime) >= ZEUS_OLYMPUS_FURY_AIM_DURATION) {
                                            zeusOlympusFuryShoot();
                                        }
                                    }
                                }
                            }

                    function updateBall(dt){
                                const currentR = player.r;
                                if (player.asherStarfallCharging) {
                                    const elapsed = performance.now() - player.asherStarfallChargeStartTime;
                                    const angle = (elapsed / 1000) * ASHER_STARFALL_ORBIT_SPEED;

                                    ball.x = player.x + Math.cos(angle) * ASHER_STARFALL_ORBIT_RADIUS;
                                    ball.y = player.y + Math.sin(angle) * ASHER_STARFALL_ORBIT_RADIUS;
                                    ball.vx = 0;
                                    ball.vy = 0;

                                    // Add sparkling VFX during orbit
                                    if (Math.random() < 0.5) {
                                        vfx.sparks.push({
                                            x: ball.x, y: ball.y,
                                            vx: (Math.random() - 0.5) * 1.5,
                                            vy: (Math.random() - 0.5) * 1.5,
                                            life: 150 + Math.random() * 150,
                                            t: 0, r: 1 + Math.random() * 1.5,
                                            color: 'rgba(233, 213, 255,'
                                        });
                                    }
                                    return; // Skip the rest of the ball update logic
                                }

                                if (ball.isHoming) {
                                    const now = performance.now();
                                    if (now > ball.homingEndTime) {
                                        ball.isHoming = false;
                                        player.asherAutoGoalActive = false;
                                        ball.maxSpeed = 18; // Reset max speed
                                    } else {
                                        const targetDir = Math.atan2(ball.homingTargetY - ball.y, ball.homingTargetX - ball.x);
                                        const currentDir = Math.atan2(ball.vy, ball.vx);

                                        let angleDiff = targetDir - currentDir;
                                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                                        const newDir = currentDir + clamp(angleDiff, -ASHER_HOMING_TURN_RATE, ASHER_HOMING_TURN_RATE);

                                        const currentSpeed = Math.hypot(ball.vx, ball.vy);
                                        ball.vx = Math.cos(newDir) * currentSpeed;
                                        ball.vy = Math.sin(newDir) * currentSpeed;
                                    }
                                }

                                if(player.hasBall && !player.gojoPurpleActive && !player.gojoRedCharging && !player.eddieVenomStrikeActive && !(currentStyle === 'eddie' && player.eddieSymbioteMontageActive) &&
                                   !player.zeusLightningCharging && !(player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming')){
                                    const dir=Math.atan2(mouse.y-player.y, mouse.x-player.x);
                                    let dist = currentR + ball.r + 4;

                                    ball.x=player.x+Math.cos(dir)*dist;
                                    ball.y=player.y+Math.sin(dir)*dist;
                                    ball.vx=player.vx; ball.vy=player.vy;
                                } else if (player.telekinising || (currentStyle === 'eddie' && player.eddieVenomStrikeActive) ||
                                           (currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'pulling' && !player.hasBall)) {

                                    const dt_s = dt / 1000;

                                    const dx = player.x - ball.x;
                                    const dy = player.y - ball.y;
                                    const dist = Math.hypot(dx, dy);
                                    const dir = Math.atan2(dy, dx);

                                    let pullSpeed = EDDIE_VENOM_STRIKE_PULL_SPEED;
                                    if (currentStyle === 'zeus' && player.zeusOlympusFuryActive) {
                                        pullSpeed = 400;
                                    }

                                    ball.vx = Math.cos(dir) * pullSpeed;
                                    ball.vy = Math.sin(dir) * pullSpeed;

                                    ball.x += ball.vx * dt_s;
                                    ball.y += ball.vy * dt_s;


                                    if(dist < currentR + ball.r + 6){ 
                                        player.hasBall = true;
                                        player.telekinising = false;
                                        vfx.eclipseLines = [];

                                        if (currentStyle === 'eddie' && player.eddieVenomStrikeActive) {

                                            const shootDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                                            ball.vx = Math.cos(shootDir) * EDDIE_VENOM_STRIKE_SHOT_POWER + player.vx * 0.3;
                                            ball.vy = Math.sin(shootDir) * EDDIE_VENOM_STRIKE_SHOT_POWER + player.vy * 0.3;
                                            player.hasBall = false;
                                            player.eddieVenomStrikeActive = false;
                                            vfx.eddieVenomBallSwirl = [];

                                            vfx.eddieVenomShotTrail.push({
                                                end: performance.now() + 600,
                                                w: 20,
                                                colorStart: getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-trail-start'),
                                                colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-trail-end')
                                            });
                                            shockwave(player.x, player.y, 25, 'eddie-venom');
                                            const origFric = ball.friction;
                                            ball.friction = 0.99;
                                            setTimeout(() => { ball.friction = origFric; ball.maxSpeed = 18; }, 600);
                                        } else if (currentStyle === 'zeus' && player.zeusOlympusFuryActive) {
                                            ball.vx = player.vx;
                                            ball.vy = player.vy;
                                        }
                                    } else if ((currentStyle === 'eddie' && player.eddieVenomStrikeActive) || (currentStyle === 'zeus' && player.zeusOlympusFuryActive)) {
                                         vfx.eddieVenomBallSwirl.push(newEddieVenomBallSwirlParticle(ball.x, ball.y, dir + Math.PI));
                                    }
                                }
                                else{
                                    ball.vx*=ball.friction; ball.vy*=ball.friction;
                                    const sp=Math.hypot(ball.vx, ball.vy);
                                    if(sp>ball.maxSpeed){ ball.vx*=ball.maxSpeed/sp; ball.vy*=ball.maxSpeed/sp; }
                                    ball.x+=ball.vx; ball.y+=ball.vy;

                                    const left=margin+2, right=W-margin-2, top=margin+2, bottom=H-margin-2;

                                    // Enhanced ball collision with better bounce physics
                                    if(ball.x-ball.r<left){ ball.x=left+ball.r; ball.vx*=-(ball.bounceDamping || 0.75); impactWave(ball.x, ball.y, 10); }
                                    if(ball.x+ball.r>right){ ball.x=right-ball.r; ball.vx*=-(ball.bounceDamping || 0.75); impactWave(ball.x, ball.y, 10); }
                                    if(ball.y-ball.r<top){ ball.y=top+ball.r; ball.vy*=-(ball.bounceDamping || 0.75); impactWave(ball.x, ball.y, 10); }
                                    if(ball.y+ball.r>bottom){ ball.y=bottom-ball.r; ball.vy*=-(ball.bounceDamping || 0.75); impactWave(ball.x, ball.y, 10); }


                                    // Ball pickup: automatic on collision OR manual with 'E' key
                                    const d=Math.hypot(ball.x-player.x, ball.y-player.y);
                                    
                                    // Auto pickup by stepping on the ball (collision detection)
                                    if (d < player.r + ball.r + 3 && !player.hasBall && !aiPlayer.hasBall && 
                                        !player.eddieSymbioteMontageActive && !player.spinning && !player.charging && 
                                        !player.telekinising && !player.dashing) {
                                        player.hasBall = true;
                                        ball.vx = 0;
                                        ball.vy = 0;
                                    }

                                    if (currentStyle === 'gojo' && player.gojoLapseBlueActive && player.gojoLapseBlueBall) {
                                        const orbitingBall = player.gojoLapseBlueBall;
                                        const distToOrbitingBall = Math.hypot(ball.x - orbitingBall.x, ball.y - orbitingBall.y);
                                        if (distToOrbitingBall < orbitingBall.r + ball.r) {
                                            player.hasBall = true;
                                            ball.vx = player.vx;
                                            ball.vy = player.vy;
                                            const snapDir = Math.atan2(player.y - ball.y, player.x - ball.x);
                                            ball.x = player.x + Math.cos(snapDir) * (player.r + ball.r + 4);
                                            ball.y = player.y + Math.sin(snapDir) * (player.r + ball.r + 4);

                                            for(let i=0; i<10; i++) vfx.gojoLapseBluePullEffect.push(newGojoLapseBluePullParticle(ball.x, ball.y, player.x, player.y));
                                            shockwave(ball.x, ball.y, ball.r * 1.5, 'gojo-blue');

                                            player.gojoLapseBlueActive = false;
                                            player.gojoLapseBlueBall = null;
                                        }
                                    }


                                    if (currentStyle === 'robsan' && player.eclipseGraspActive && player.telekinising) {
                        const dt_s = dt / 1000;
                        const dx = player.x - ball.x;
                        const dy = player.y - ball.y;
                        const dist = Math.hypot(dx, dy);

                        const speed = lerp(24, 8, Math.min(1, dist / 180));
                        const moveAmount = speed * dt_s;

                        ball.x += (dx / dist) * moveAmount;
                        ball.y += (dy / dist) * moveAmount;

                        if(Math.random() < 0.3) {
                            vfx.robsanVoidPuffs.push(newRobsanVoidPuff(ball.x, ball.y, 'eclipse'));
                        }

                        if (dist < player.r + ball.r + 4) {
                            player.hasBall = true;
                            player.telekinising = false;
                            player.eclipseGraspActive = false;
                            ball.vx = 0;
                            ball.vy = 0;

                            shockwave(player.x, player.y, 20, 'eclipse');
                            for(let i=0; i<12; i++) {
                                vfx.sparks.push(newRobsanParticle(player.x, player.y));
                            }
                        }
                        return;
                    }

                                    if (currentStyle === 'zeus' && player.zeusHeavenlyShieldActive) {
                                        const distToPlayer = Math.hypot(ball.x - player.x, ball.y - player.y);
                                        if (distToPlayer < ZEUS_HEAVENLY_SHIELD_RADIUS + ball.r) {
                                            ball.vx *= 0.05;
                                            ball.vy *= 0.05;
                                        }
                                    }

                                    if (currentStyle === 'leonardo' && player.leonardoShieldActive) {
                                        const distToPlayer = Math.hypot(ball.x - player.x, ball.y - player.y);
                                        if (distToPlayer < LEONARDO_SHIELD_RADIUS + ball.r) {
                                            // Slowly pull the ball towards the player
                                            const pullDir = Math.atan2(player.y - ball.y, player.x - ball.x);
                                            ball.vx += Math.cos(pullDir) * LEONARDO_SHIELD_PULL_STRENGTH;
                                            ball.vy += Math.sin(pullDir) * LEONARDO_SHIELD_PULL_STRENGTH;
                                        }
                                    }
                                    // Check for Pattern Weave field
                                    for (const field of vfx.leonardoPatternField) {
                                        const distToField = Math.hypot(ball.x - field.x, ball.y - field.y);
                                        if (distToField < field.radius + ball.r) {
                                            ball.vx *= 0.95; // Slow the ball down
                                            ball.vy *= 0.95;
                                        }
                                    }
                                }
                            }


                            function shoot(scale){
                                if(!player.hasBall) return;
                                const dir=Math.atan2(mouse.y-player.y, mouse.x-player.x);
                                const base=10;
                                const power=base*scale;
                                ball.vx=Math.cos(dir)*power + player.vx*0.3;
                                ball.vy=Math.sin(dir)*power + player.vy*0.3;
                                player.hasBall=false;
                            }

                            function tryKaiser(){
                                if(currentStyle !== 'hudson') return;
                                const now=performance.now();
                                if(now < abilityReadyAt) return;
                                if(!player.hasBall) {
                                    showNotification('hudson impact needs the ball bestie', 'warning');
                                    return;
                                }


                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

                                const dir=Math.atan2(mouse.y-player.y, mouse.x-player.x);
                                const launch=22;

                                ball.vx = Math.cos(dir)*launch + player.vx*0.25;
                                ball.vy = Math.sin(dir)*launch + player.vy*0.25;
                                ball.maxSpeed = 100000;
                                player.hasBall=false;

                                const endTime = now + 450;
                                vfx.trail.push({end:endTime, w:16});
                                for(let i=0;i<10;i++) vfx.lines.push(newLineBurst(player.x, player.y, dir));
                                shockwave(player.x, player.y, 18);
                                kaiserSparks(player.x, player.y, dir);

                                const newTrails = newHudsonImpactBurst(player.x, player.y, dir);
                                vfx.hudsonEmperorDribbleTrail.push(...newTrails);
                                vfx.hudsonSpeedLines.push(...newHudsonSpeedLines(player.x, player.y, dir));
                                vfx.hudsonEnergyWaves.push(newHudsonEnergyWave(player.x, player.y));

                                for(let i = 0; i < 3; i++) {
                                    setTimeout(() => {
                                        if(gameState === 'game') {
                                            shockwave(player.x, player.y, 15 + i * 5, 'hudson');
                                            vfx.energyResidue.push({
                                                x: player.x + (Math.random() - 0.5) * 40,
                                                y: player.y + (Math.random() - 0.5) * 40,
                                                t: 0, life: 800, r: 3 + Math.random() * 4,
                                                color: 'rgba(79, 209, 197,'
                                            });
                                        }
                                    }, i * 100);
                                }

                                const origFric = ball.friction;
                                ball.friction = 0.994;
                                setTimeout(()=>{ ball.friction = origFric; ball.maxSpeed=18; }, 450);

                                abilityReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function tryHudsonEmperorDribble() {
                                if (currentStyle !== 'hudson') return;
                                const now = performance.now();
                                if (now < hudsonEmperorDribbleReadyAt) return;
                                
                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive || player.hudsonEmperorDribbling) return;
                                
                                // Start emperor dribble
                                hudsonEmperorDribbleReadyAt = now + HUDSON_EMPEROR_DRIBBLE_COOLDOWN;
                                player.hudsonEmperorDribbling = true;
                                player.hudsonEmperorDribbleStartTime = now;
                                player.hudsonEmperorDribblePhase = 'left';
                                player.hudsonEmperorDribbleStartX = player.x;
                                player.hudsonEmperorDribbleStartY = player.y;
                                // Capture mouse direction when ability is triggered
                                player.hudsonEmperorDribbleMouseDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                                
                                // Stun AI player during the dribble
                                if (aiEnabled) {
                                    aiPlayer.isStunned = true;
                                    aiPlayer.stunEndTime = now + HUDSON_EMPEROR_DRIBBLE_DURATION;
                                    showNotification('ai got stunned lmao', 'success');
                                }
                                
                                showNotification('dribbling like an emperor activated', 'success');
                                
                                // Initial emperor aura burst
                                vfx.hudsonEmperorDribbleAura.push({
                                    x: player.x, y: player.y,
                                    life: 300, t: 0,
                                    radius: player.r * 3,
                                    phase: 'burst'
                                });
                            }

                            function tryRobsanShadowSpiral(){
                                if(currentStyle !== 'robsan') return;
                                const now=performance.now();
                                if(now < shadowSpiralReadyAt) return;
                                if(!player.hasBall) {
                                    showNotification('shadow spiral needs the ball bestie', 'warning');
                                    return;
                                }


                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;


                                player.spinning = true;
                                player.spinTimer = ROBSAN_SPIN_DURATION;
                                player.hasBall = false;

                                const dir=Math.atan2(mouse.y-player.y, mouse.x-player.x);

                                vfx.robsanAura.push({x:player.x, y:player.y, end:now + ROBSAN_SPIN_DURATION * 2, radius:player.r*1.5, t:0, life:ROBSAN_SPIN_DURATION * 2});
                                for(let i=0; i<30; i++) {
                                    const angleOffset = Math.random() * Math.PI * 2;
                                    const radiusOffset = player.r * (0.5 + Math.random() * 0.5);
                                    vfx.robsanParticles.push(newRobsanParticle(player.x + Math.cos(angleOffset) * radiusOffset, player.y + Math.sin(angleOffset) * radiusOffset));
                                }

                                vfx.robsanShadowClones.push(...newRobsanShadowClones(player.x, player.y));
                                vfx.robsanVoidRifts.push(newRobsanVoidRift(player.x, player.y));
                                
                                // EPIC NEW SHADOW SPIRAL VFX
                                vfx.epicExplosions.push({
                                    x: player.x, y: player.y, t: 0, life: 1500,
                                    startRadius: 15, endRadius: 120, maxOpacity: 0.9
                                });
                                vfx.massiveShockwaves.push({
                                    x: player.x, y: player.y, t: 0, life: 2000,
                                    startRadius: 20, endRadius: 200, maxOpacity: 0.8
                                });
                                vfx.particleStorms.push({
                                    x: player.x, y: player.y, t: 0, life: 3000, intensity: 1.2,
                                    particles: Array.from({length: 80}, () => ({
                                        x: player.x + (Math.random() - 0.5) * 60,
                                        y: player.y + (Math.random() - 0.5) * 60,
                                        vx: (Math.random() - 0.5) * 8,
                                        vy: (Math.random() - 0.5) * 8,
                                        r: 2 + Math.random() * 4,
                                        color: {r: 68 + Math.random() * 30, g: 10 + Math.random() * 20, b: 107 + Math.random() * 50}
                                    }))
                                });

                                for(let i = 0; i < 50; i++) {
                                    const angle = (i / 50) * Math.PI * 4;
                                    const radius = i * 2;
                                    vfx.robsanParticles.push({
                                        x: player.x + Math.cos(angle) * radius,
                                        y: player.y + Math.sin(angle) * radius,
                                        vx: -Math.sin(angle) * 3,
                                        vy: Math.cos(angle) * 3,
                                        t: 0, life: 800 + Math.random() * 400,
                                        r: 2 + Math.random() * 3,
                                        color: 'rgba(68, 10, 107,'
                                    });
                                }

                                setTimeout(() => {
                                    if(gameState !== 'game') return;
                                    player.spinning = false;
                                    player.charging = true;
                                    player.chargeTimer = ROBSAN_CHARGE_DURATION;
                                    vfx.robsanChargeAura.push({x:player.x, y:player.y, end:performance.now() + ROBSAN_CHARGE_DURATION, radius:player.r*1.2, t:0, life:ROBSAN_CHARGE_DURATION});
                                }, ROBSAN_SPIN_DURATION);


                                setTimeout(() => {
                                    if(gameState !== 'game') return;
                                    player.charging = false;

                                    const launch = 28;
                                    ball.vx = Math.cos(dir)*launch + player.vx*0.2;
                                    ball.vy = Math.sin(dir)*launch + player.vy*0.2;
                                    ball.maxSpeed = 100000;

                                    const endTime = performance.now() + 600;
                                    vfx.shadowTrails.push({end:endTime, w:20}); 
                                    shockwave(player.x, player.y, 25, 'robsan');

                                    for(let i=0; i<5; i++) vfx.robsanGroundRupture.push(newRobsanGroundRupture(player.x, player.y, dir + (Math.random()-0.5)*Math.PI/2));
                                    
                                    // EPIC SHADOW SPIRAL LAUNCH VFX
                                    vfx.energyNovas.push({
                                        x: player.x, y: player.y, t: 0, life: 1200,
                                        startRadius: 10, endRadius: 100, maxOpacity: 0.8
                                    });
                                    vfx.cosmicRifts.push({
                                        x: player.x, y: player.y, t: 0, life: 2500,
                                        radius: 60, angle: dir
                                    });

                                    const origFric = ball.friction;
                                    ball.friction = 0.992;
                                    setTimeout(()=>{ ball.friction = origFric; ball.maxSpeed=18; }, 600);

                                    player.hasBall = false; 

                                }, ROBSAN_SPIN_DURATION + ROBSAN_CHARGE_DURATION);

                                shadowSpiralReadyAt = now + ABILITY_COOLDOWN;
                            }

                    function tryRobsanEclipseGrasp(){
                        if(currentStyle !== 'robsan') return;
                        const now = performance.now();
                        if(now < eclipseGraspReadyAt) return;
                        if(player.hasBall) {
                            showNotification('eclipse grasp needs you to not have the ball', 'warning');
                            return;
                        }

                        if (player.spinning || player.charging || player.telekinising || player.dashing ||
                            player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                            player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                            player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

                        player.telekinising = true;
                        player.eclipseGraspActive = true;
                        player.hasBall = false;

                        vfx.eclipseAura.push({x:player.x, y:player.y, end:now + ECLIPSE_AURA_DURATION * 2, radius:player.r*2, t:0, life:ECLIPSE_AURA_DURATION * 2});
                        for(let i=0; i<20; i++) {
                            vfx.robsanEclipseWisps.push(newRobsanEclipseWisp(player.x, player.y));
                            if(i % 2 === 0) {
                                vfx.robsanVoidPuffs.push(newRobsanVoidPuff(player.x, player.y, 'eclipse'));
                            }
                        }

                        const pulseInterval = setInterval(() => {
                            if(!player.telekinising || gameState !== 'game') {
                                clearInterval(pulseInterval);
                                return;
                            }
                            vfx.robsanVoidPuffs.push(newRobsanVoidPuff(ball.x, ball.y, 'eclipse'));
                        }, 100);

                        setTimeout(() => {
                            clearInterval(pulseInterval);
                            if(player.telekinising) {
                                player.telekinising = false;
                                player.eclipseGraspActive = false;
                            }
                        }, 3000);

                        eclipseGraspReadyAt = now + ABILITY_COOLDOWN;
                    }
                            function tryRobsanVoidDash(){
                                if(currentStyle !== 'robsan') return;
                                const now = performance.now();
                                if(now < voidDashReadyAt) return;

                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

                                player.dashing = true;
                                player.dashTimer = VOID_DASH_DURATION;

                                const dashDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);

                                player.vx = Math.cos(dashDir) * VOID_DASH_SPEED;
                                player.vy = Math.sin(dashDir) * VOID_DASH_SPEED;

                                vfx.voidTrails.push({
                                    x: player.x, y: player.y,
                                    end: now + VOID_DASH_DURATION + 100,
                                    trailColorStart: getComputedStyle(document.documentElement).getPropertyValue('--void-trail-color-start'),
                                    trailColorEnd: getComputedStyle(document.documentElement).getPropertyValue('--void-trail-color-end'),
                                    w: player.r * 1.5
                                });
                                vfx.robsanVoidPuffs.push(newRobsanVoidPuff(player.x, player.y, 'start'));
                                
                                // EPIC VOID DASH VFX  
                                vfx.dimensionalTears.push({
                                    x: player.x, y: player.y, t: 0, life: 800,
                                    width: 80, height: 15, angle: dashDir
                                });
                                vfx.epicExplosions.push({
                                    x: player.x, y: player.y, t: 0, life: 600,
                                    startRadius: 8, endRadius: 40, maxOpacity: 0.7
                                });
                                vfx.particleStorms.push({
                                    x: player.x, y: player.y, t: 0, life: 1000, intensity: 0.8,
                                    particles: Array.from({length: 40}, () => ({
                                        x: player.x + (Math.random() - 0.5) * 30,
                                        y: player.y + (Math.random() - 0.5) * 30,
                                        vx: (Math.random() - 0.5) * 12,
                                        vy: (Math.random() - 0.5) * 12,
                                        r: 1 + Math.random() * 2,
                                        color: {r: 30 + Math.random() * 20, g: 27 + Math.random() * 20, b: 75 + Math.random() * 30}
                                    }))
                                });

                                setTimeout(() => {
                                    if(gameState !== 'game') return;
                                    player.dashing = false;
                                    player.vx *= 0.2;
                                    player.vy *= 0.2;
                                }, VOID_DASH_DURATION);

                                voidDashReadyAt = now + ABILITY_COOLDOWN;
                            }


                            function tryXDrakeSupernova() {
                                if (currentStyle !== 'xdrake') return;
                                const now = performance.now();
                                if (now < supernovaReadyAt) return;

                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

                                player.xdrakeSupernovaDashing = true;
                                player.xdrakeSupernovaDashTimer = XDRAKE_SUPERNOVA_DASH_DURATION;

                                const dashDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                                player.vx = Math.cos(dashDir) * XDRAKE_SUPERNOVA_DASH_SPEED;
                                player.vy = Math.sin(dashDir) * XDRAKE_SUPERNOVA_DASH_SPEED;


                                vfx.xdrakeSupernovaTrails.push({
                                    x: player.x, y: player.y,
                                    end: now + XDRAKE_SUPERNOVA_DASH_DURATION + 100,
                                    trailColorStart: getComputedStyle(document.documentElement).getPropertyValue('--xdrake-dash-trail-start'),
                                    trailColorEnd: getComputedStyle(document.documentElement).getPropertyValue('--xdrake-dash-trail-end'),
                                    w: player.r * 1.8
                                });
                                shockwave(player.x, player.y, player.r, 'xdrake-supernova');

                                vfx.xdrakeSupernovaGroundCrack.push(newXDrakeGroundCrack(player.x, player.y));
                                vfx.xdrakeNatureSpirits.push(...newXDrakeNatureSpirits(player.x, player.y));
                                vfx.xdrakeTerraforms.push(...newXDrakeTerraform(player.x, player.y, dashDir));

                                for(let i = 0; i < 20; i++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const speed = 2 + Math.random() * 4;
                                    vfx.sparks.push({
                                        x: player.x, y: player.y,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed,
                                        life: 400 + Math.random() * 300,
                                        t: 0, r: 2 + Math.random() * 3,
                                        color: 'rgba(34, 197, 94,'
                                    });
                                }

                                setTimeout(() => {
                                    if (gameState !== 'game') return;
                                    player.xdrakeSupernovaDashing = false;
                                    player.vx *= 0.2;
                                    player.vy *= 0.2;
                                }, XDRAKE_SUPERNOVA_DASH_DURATION);

                                supernovaReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function tryXDrakeFossilFootwork() {
                                if (currentStyle !== 'xdrake') return;
                                const now = performance.now();
                                if (now < fossilFootworkReadyAt) return;
                                if (!player.hasBall) {
                                    showNotification('fossilised footwork needs the ball bestie', 'warning');
                                    return;
                                }

                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

                                player.xdrakeFossilFootworking = true;
                                player.xdrakeFossilFootworkTimer = XDRAKE_FOSSIL_FOOTWORK_DURATION;

                                const footworkDir = Math.atan2(mouse.y - player.y, mouse.x - player.x - 0.001);
                                player.vx = Math.cos(footworkDir) * XDRAKE_FOSSIL_FOOTWORK_SPEED;
                                player.vy = Math.sin(footworkDir) * XDRAKE_FOSSIL_FOOTWORK_SPEED;


                                for(let i = 0; i < 8; i++) {
                                    vfx.xdrakeFootworkDust.push(newXDrakeFootworkParticle(player.x, player.y));
                                }
                                shockwave(player.x, player.y, player.r * 0.8, 'xdrake-footwork');

                                for(let i=0; i<6; i++) vfx.xdrakeFootworkLeaves.push(newXDrakeFootworkLeaf(player.x, player.y, footworkDir));
                                impactWave(player.x, player.y, player.r * 0.7);

                                setTimeout(() => {
                                    if (gameState !== 'game') return;
                                    player.xdrakeFossilFootworking = false;
                                    player.vx *= 0.3;
                                    player.vy *= 0.3;
                                }, XDRAKE_FOSSIL_FOOTWORK_DURATION);

                                fossilFootworkReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function tryXDrakeAncientApex() {
                                if (currentStyle !== 'xdrake') return;
                                const now = performance.now();
                                if (now < ancientApexReadyAt) return;
                                if (!player.hasBall) {
                                    showNotification('ancient apex needs the ball bestie', 'warning');
                                    return;
                                }

                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

                                player.xdrakeAncientApexCharging = true;
                                player.ancientApexChargeTimer = now;


                                powerBar.style.opacity = 1;



                                ancientApexReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function xdrakeAncientApexShoot(chargeProgress) {
                                if (currentStyle !== 'xdrake' || !player.xdrakeAncientApexCharging) return;
                                if (!player.hasBall) {
                                    player.xdrakeAncientApexCharging = false;
                                    return;
                                }

                                const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                                const launchPower = XDRAKE_ANCIENT_APEX_SHOT_POWER * chargeProgress;

                                ball.vx = Math.cos(dir) * launchPower + player.vx * 0.2;
                                ball.vy = Math.sin(dir) * launchPower + player.vy * 0.2;
                                ball.maxSpeed = 100000;

                                player.hasBall = false;
                                player.xdrakeAncientApexCharging = false;

                                const endTime = performance.now() + 800;
                                vfx.xdrakeApexAura.push({
                                    x: player.x, y: player.y,
                                    end: endTime,
                                    radius: player.r * 2,
                                    t: 0, life: 800
                                });
                                shockwave(player.x, player.y, 30, 'xdrake-apex');

                                for(let i=0; i<10; i++) vfx.xdrakeAncientApexGroundBurst.push(newXDrakeAncientApexGroundBurst(player.x, player.y));

                                const origFric = ball.friction;
                                ball.friction = 0.99;
                                setTimeout(() => { ball.friction = origFric; ball.maxSpeed = 18; }, 800);
                                endCharge();
                            }


                            function tryGojoRed() {
                                if (currentStyle !== 'gojo') return;
                                const now = performance.now();
                                if (now < gojoRedReadyAt) return;
                                if (!player.hasBall) {
                                    showNotification('red needs the ball bestie', 'warning');
                                    return;
                                }


                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

                                player.gojoRedCharging = true;
                                player.gojoRedChargeStartTime = now;


                                powerBar.style.opacity = 1;


                                autoTimer = setTimeout(() => {
                                    if (gameState !== 'game' || !player.gojoRedCharging) return;

                                    const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);

                                    ball.vx = Math.cos(dir) * GOJO_RED_SHOT_POWER + player.vx * 0.2;
                                    ball.vy = Math.sin(dir) * GOJO_RED_SHOT_POWER + player.vy * 0.2;
                                    ball.maxSpeed = 100000;

                                    player.hasBall = false;
                                    player.gojoRedCharging = false;
                                    player.gojoRedActive = true;

                                    vfx.gojoRedTrail.push({
                                        end: now + 500,
                                        w: 18,
                                        colorStart: getComputedStyle(document.documentElement).getPropertyValue('--gojo-red-trail-start'),
                                        colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--gojo-red-trail-end')
                                    });
                                    shockwave(player.x, player.y, player.r, 'gojo-red');

                                    vfx.gojoRedExplosion.push(newGojoRedExplosion(player.x, player.y));

                                    const origFric = ball.friction;
                                    ball.friction = 0.99;
                                    setTimeout(() => {
                                        if (gameState !== 'game') return;
                                        ball.friction = origFric;
                                        ball.maxSpeed = 18;
                                        player.gojoRedActive = false;
                                    }, 500);
                                    endCharge();
                                }, GOJO_RED_CHARGE_DURATION);

                                gojoRedReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function tryGojoLapseBlue() {
                                if (currentStyle !== 'gojo') return;
                                const now = performance.now();
                                if (now < gojoLapseBlueReadyAt) return;
                                if (player.hasBall) {
                                    showNotification('lapse blue needs you to not have the ball', 'warning');
                                    return;
                                }


                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

                                player.gojoLapseBlueActive = true;
                                player.gojoLapseBlueBall = {
                                    x: player.x + GOJO_LAPSE_BLUE_ORBIT_RADIUS,
                                    y: player.y,
                                    r: GOJO_LAPSE_BLUE_BALL_RADIUS,
                                    angle: 0,
                                    orbitRadius: GOJO_LAPSE_BLUE_ORBIT_RADIUS,
                                    speed: GOJO_LAPSE_BLUE_ORBIT_SPEED,
                                    originTime: now,
                                    lifeTime: ABILITY_COOLDOWN * 0.8
                                };


                                for(let i=0; i<15; i++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const speed = 0.5 + Math.random() * 1.5;
                                    const life = 200 + Math.random() * 300;
                                    vfx.sparks.push({x: player.x, y: player.y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life, t:0, r:2+Math.random()*2, color:'rgba(49, 130, 206,'});
                                }
                                shockwave(player.x, player.y, player.r * 1.2, 'gojo-blue');

                                vfx.gojoInfinityBarriers.push(...newGojoInfinityBarrier(player.x, player.y));
                                vfx.gojoDomainExpansions.push(newGojoDomainExpansion(player.x, player.y));

                                setTimeout(() => {
                                    if(gameState !== 'game') return;
                                    player.gojoLapseBlueActive = false;
                                    player.gojoLapseBlueBall = null;
                                }, player.gojoLapseBlueBall.lifeTime);

                                gojoLapseBlueReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function tryGojoPurple() {
                                if (currentStyle !== 'gojo') return;
                                const now = performance.now();
                                if (now < gojoPurpleReadyAt) return;
                                if (!player.hasBall) {
                                    showNotification('purple needs the ball bestie', 'warning');
                                    return;
                                }


                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

                                player.gojoPurpleActive = true;
                                player.hasBall = false;

                                player.gojoPurpleInitialDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);


                                const dir = player.gojoPurpleInitialDir;
                                const spreadDist = GOJO_PURPLE_SPREAD_DISTANCE;
                                const leftSpreadX = player.x + Math.cos(dir - Math.PI/2) * spreadDist;
                                const leftSpreadY = player.y + Math.sin(dir - Math.PI/2) * spreadDist;
                                const rightSpreadX = player.x + Math.cos(dir + Math.PI/2) * spreadDist;
                                const rightSpreadY = player.y + Math.sin(dir + Math.PI/2) * spreadDist;

                                player.gojoPurpleLeftBall = {
                                    x: leftSpreadX,
                                    y: leftSpreadY,
                                    r: GOJO_LAPSE_BLUE_BALL_RADIUS * 0.8,
                                    vx: 0, vy: 0,
                                    color: 'var(--gojo-red-primary)'
                                };

                                player.gojoPurpleRightBall = {
                                    x: rightSpreadX,
                                    y: rightSpreadY,
                                    r: GOJO_LAPSE_BLUE_BALL_RADIUS * 0.8,
                                    vx: 0, vy: 0,
                                    color: 'var(--gojo-blue-primary)'
                                };
                                player.gojoPurpleConverging = true;
                                player.gojoPurpleConvergenceStartTime = now;
                                player.gojoPurpleShotFired = false;

                                gojoPurpleReadyAt = now + ABILITY_COOLDOWN * 2;
                            }

                            function shootPurpleShot(x, y, initialMouseDir) {
                                const dir = initialMouseDir;
                                ball.vx = Math.cos(dir) * GOJO_PURPLE_FINAL_SHOT_POWER;
                                ball.vy = Math.sin(dir) * GOJO_PURPLE_FINAL_SHOT_POWER;
                                ball.maxSpeed = 100000;


                                ball.x = x;
                                ball.y = y;


                                player.hasBall = false;

                                vfx.gojoPurpleTrail.push({
                                    x: x, y: y,
                                    end: performance.now() + 1000,
                                    colorStart: getComputedStyle(document.documentElement).getPropertyValue('--gojo-purple-trail-start'),
                                    colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--gojo-purple-trail-end'),
                                    w: 30
                                });

                                const origFric = ball.friction;
                                ball.friction = 0.99;
                                setTimeout(() => {
                                    if (gameState !== 'game') return;
                                    ball.friction = origFric;
                                    ball.maxSpeed = 18;
                                }, 1000);
                            }

                            function tryEddieWeAre() {
                                if (currentStyle !== 'eddie') return;
                                const now = performance.now();
                                if (now < eddieWeAreReadyAt) return;

                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;


                                player.eddieWeAreActive = true;
                                player.eddieWeAreOriginalMaxSpd = player.maxSpd;
                                player.maxSpd *= EDDIE_WE_ARE_SPEED_BOOST;
                                player.eddieWeAreEndTime = now + EDDIE_WE_ARE_DURATION;

                                vfx.eddieWeAreAura.push({
                                    x: player.x, y: player.y,
                                    end: player.eddieWeAreEndTime,
                                    radius: player.r * 1.5,
                                    t: 0, life: EDDIE_WE_ARE_DURATION
                                });
                                for(let i=0; i<20; i++) {
                                    vfx.eddieWeAreParticles.push(newEddieWeAreParticle(player.x, player.y));
                                }

                                vfx.eddieWeAreRipples.push(newEddieWeAreRipple(player.x, player.y));
                                vfx.eddieSymbioteSpikes.push(...newEddieSymbioteSpikes(player.x, player.y));
                                vfx.eddieVenomDrops.push(...newEddieVenomDrops(player.x, player.y));

                                for(let i = 0; i < 8; i++) {
                                    const angle = (i / 8) * Math.PI * 2;
                                    vfx.eddieVenomTendrils.push({
                                        startX: player.x,
                                        startY: player.y,
                                        endX: player.x + Math.cos(angle) * 40,
                                        endY: player.y + Math.sin(angle) * 40,
                                        t: 0, life: 600,
                                        wiggleFreq: 0.2, wiggleAmp: 5
                                    });
                                }

                                eddieWeAreReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function tryEddieVenomStrike() {
                                if (currentStyle !== 'eddie') return;
                                const now = performance.now();
                                if (now < eddieVenomStrikeReadyAt) return;
                                if (player.hasBall) {
                                    showNotification('venom strike needs you to not have the ball', 'warning');
                                    return;
                                }

                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;


                                player.eddieVenomStrikeActive = true;

                                vfx.eddieVenomTendrils.push({
                                    startX: player.x, startY: player.y,
                                    endX: ball.x, endY: ball.y,
                                    t: 0, life: 1000,
                                    wiggleFreq: 0.1, wiggleAmp: 8
                                });

                                eddieVenomStrikeReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function startNewSymbioteMontageTeleport() {
                                const now = performance.now();
                                const minX = margin + player.r;
                                const maxX = W - margin - player.r;
                                const minY = margin + player.r;
                                const maxY = H - margin - player.r;

                                const targetX = minX + Math.random() * (maxX - minX);
                                const targetY = minY + Math.random() * (maxY - minY);

                                player.eddieSymbioteMontageCurrentTeleportTarget = {x: targetX, y: targetY};
                                player.eddieSymbioteMontageTeleportStartTime = now;

                                const dist = Math.hypot(player.x - targetX, player.y - targetY);
                                const teleportDuration = Math.max(100, Math.min(500, dist / EDDIE_SYMBIOTE_MONTAGE_TELEPORT_SPEED * 1000));
                                player.eddieSymbioteMontageTeleportEndTime = now + teleportDuration;
                                player.eddieSymbioteMontageStartPlayerPos = {x: player.x, y: player.y};
                                player.hasBall = true;

                                shockwave(player.x, player.y, player.r, 'eddie-montage');
                                vfx.eddieTeleportFlicker.push(newEddieTeleportFlicker(player.x, player.y));
                            }


                            function tryEddieSymbioteMontage() {
                                if (currentStyle !== 'eddie') return;
                                const now = performance.now();
                                if (now < eddieSymbioteMontageReadyAt) return;
                                if (!player.hasBall) {
                                    showNotification('symbiote montage needs the ball bestie', 'warning');
                                    return;
                                }

                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieWeAreActive || player.eddieVenomStrikeActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

                                player.eddieSymbioteMontageActive = true;
                                player.eddieSymbioteMontagePhase = 'teleporting';
                                player.eddieSymbioteMontageTeleportCount = 0;
                                player.eddieSymbioteMontageAimStartTime = 0;
                                player.eddieSymbioteMontageShotFired = false;

                                startNewSymbioteMontageTeleport();

                                eddieSymbioteMontageReadyAt = now + ABILITY_COOLDOWN * 2;
                            }

                            // EDDIE AWAKENING MOVES - SUPER POWERFUL VERSIONS
                            function tryEddieVenomDevastation() {
                                if (currentStyle !== 'eddie' || !player.eddieAwakeningActive) return;
                                const now = performance.now();
                                if (now < eddieWeAreReadyAt) return;

                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

                                // Super powerful speed boost and area devastation
                                player.eddieWeAreActive = true;
                                player.eddieWeAreOriginalMaxSpd = player.maxSpd;
                                player.maxSpd *= EDDIE_WE_ARE_SPEED_BOOST * 2; // Double the normal speed boost
                                player.eddieWeAreEndTime = now + EDDIE_WE_ARE_DURATION * 2; // Double duration

                                // Massive black venom aura
                                vfx.eddieWeAreAura.push({
                                    x: player.x, y: player.y,
                                    end: player.eddieWeAreEndTime,
                                    radius: player.r * 4, // Larger radius
                                    t: 0, life: EDDIE_WE_ARE_DURATION * 2,
                                    awakening: true
                                });

                                // Triple the particles for devastating effect
                                for(let i=0; i<60; i++) {
                                    vfx.eddieWeAreParticles.push(newEddieWeAreParticle(player.x, player.y));
                                }

                                // Multiple ripples for devastation
                                for(let i=0; i<5; i++) {
                                    setTimeout(() => {
                                        vfx.eddieWeAreRipples.push(newEddieWeAreRipple(player.x, player.y));
                                    }, i * 200);
                                }

                                vfx.eddieSymbioteSpikes.push(...newEddieSymbioteSpikes(player.x, player.y));
                                vfx.eddieVenomDrops.push(...newEddieVenomDrops(player.x, player.y));

                                // More powerful tendrils in all directions
                                for(let i = 0; i < 16; i++) {
                                    const angle = (i / 16) * Math.PI * 2;
                                    vfx.eddieVenomTendrils.push({
                                        startX: player.x,
                                        startY: player.y,
                                        endX: player.x + Math.cos(angle) * 80, // Longer reach
                                        endY: player.y + Math.sin(angle) * 80,
                                        t: 0, life: 1200, // Longer lasting
                                        wiggleFreq: 0.3, wiggleAmp: 10,
                                        awakening: true
                                    });
                                }

                                eddieWeAreReadyAt = now + ABILITY_COOLDOWN * 0.5; // Faster cooldown
                            }

                            function tryEddieShadowRealm() {
                                if (currentStyle !== 'eddie' || !player.eddieAwakeningActive) return;
                                const now = performance.now();
                                if (now < eddieVenomStrikeReadyAt) return;
                                if (player.hasBall) {
                                    showNotification('shadow realm needs you to not have the ball', 'warning');
                                    return;
                                }

                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

                                player.eddieVenomStrikeActive = true;

                                // Create multiple shadow tendrils to ball
                                for(let i = 0; i < 8; i++) {
                                    const offsetX = (Math.random() - 0.5) * 20;
                                    const offsetY = (Math.random() - 0.5) * 20;
                                    vfx.eddieVenomTendrils.push({
                                        startX: player.x + offsetX, startY: player.y + offsetY,
                                        endX: ball.x, endY: ball.y,
                                        t: 0, life: 1500, // Longer lasting
                                        wiggleFreq: 0.2, wiggleAmp: 12,
                                        awakening: true
                                    });
                                }

                                // Instantly teleport ball to goal with immense force
                                setTimeout(() => {
                                    if (gameState !== 'game') return;
                                    ball.x = W - margin - goalDepth + 5; // Right into the goal
                                    ball.y = H/2; // Center of goal
                                    ball.vx = 15; // Powerful shot
                                    ball.vy = 0;
                                    
                                    // Massive explosion effect at goal
                                    shockwave(ball.x, ball.y, 50, 'eddie-venom');
                                    for(let i=0; i<30; i++) {
                                        vfx.eddieWeAreParticles.push(newEddieWeAreParticle(ball.x, ball.y));
                                    }
                                }, 500);

                                eddieVenomStrikeReadyAt = now + ABILITY_COOLDOWN * 0.3; // Much faster cooldown
                            }

                            function tryZeusLightningBolt() {
                                if (currentStyle !== 'zeus') return;
                                const now = performance.now();
                                if (now < zeusLightningReadyAt) return;
                                if (!player.hasBall) {
                                    showNotification('lightning bolt needs the ball bestie', 'warning');
                                    return;
                                }

                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieWeAreActive || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusHeavenlyShieldActive || player.zeusOlympusFuryActive || player.asherAutoGoalActive) return;

                                player.zeusLightningCharging = true;
                                player.zeusLightningChargeStartTime = now;
                                powerBar.style.opacity = 1;

                                autoTimer = setTimeout(() => {
                                    if (gameState !== 'game' || !player.zeusLightningCharging) return;
                                    zeusLightningShoot();
                                    player.zeusLightningCharging = false;
                                    vfx.zeusLightningChargeEffect = [];
                                    endCharge();
                                }, ZEUS_LIGHTNING_CHARGE_DURATION);

                                zeusLightningReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function zeusLightningShoot() {
                                if (currentStyle !== 'zeus' || !player.zeusLightningCharging) return;
                                if (!player.hasBall) {
                                    player.zeusLightningCharging = false;
                                    return;
                                }

                                const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                                ball.vx = Math.cos(dir) * ZEUS_LIGHTNING_SHOT_POWER + player.vx * 0.2;
                                ball.vy = Math.sin(dir) * ZEUS_LIGHTNING_SHOT_POWER + player.vy * 0.2;
                                ball.maxSpeed = 100000;
                                player.hasBall = false;
                                player.zeusLightningActive = true;

                                vfx.zeusLightningTrail.push({
                                    end: performance.now() + 400,
                                    w: 18,
                                    colorStart: getComputedStyle(document.documentElement).getPropertyValue('--zeus-lightning-trail-start'),
                                    colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--zeus-lightning-trail-end')
                                });
                                shockwave(player.x, player.y, player.r, 'zeus-lightning');

                                for (let i = 0; i < 15; i++) {
                                    vfx.zeusLightningParticles.push(newZeusLightningParticle(player.x, player.y, dir));
                                }

                                vfx.zeusThunderClouds.push(...newZeusThunderClouds(player.x, player.y));
                                vfx.zeusLightningBolts.push(...newZeusLightningBolts(player.x, player.y));

                                for(let i = 0; i < 25; i++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const distance = 20 + Math.random() * 60;
                                    vfx.zeusLightningParticles.push({
                                        x: player.x + Math.cos(angle) * distance,
                                        y: player.y + Math.sin(angle) * distance,
                                        vx: (Math.random() - 0.5) * 4,
                                        vy: (Math.random() - 0.5) * 4,
                                        life: 300 + Math.random() * 200,
                                        t: 0, r: 1 + Math.random() * 2,
                                        color: 'rgba(255, 255, 255,'
                                    });
                                }
                                vfx.zeusLightningChargeEffect = [];

                                const origFric = ball.friction;
                                ball.friction = 0.99;
                                setTimeout(() => {
                                    if (gameState !== 'game') return;
                                    ball.friction = origFric;
                                    ball.maxSpeed = 18;
                                    player.zeusLightningActive = false;
                                }, 400);

                                player.zeusLightningCharging = false;
                                endCharge();
                            }

                            function tryZeusHeavenlyShield() {
                                if (currentStyle !== 'zeus') return;
                                const now = performance.now();
                                if (now < zeusHeavenlyShieldReadyAt) return;

                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieWeAreActive || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.asherAutoGoalActive) return;

                                player.zeusHeavenlyShieldActive = true;
                                player.zeusHeavenlyShieldEndTime = now + ZEUS_HEAVENLY_SHIELD_DURATION;
                                player.zeusHeavenlyShieldRadius = ZEUS_HEAVENLY_SHIELD_RADIUS;

                                shockwave(player.x, player.y, player.r * 1.5, 'zeus-shield');
                                vfx.zeusHeavenlyShieldAura.push({
                                    x: player.x, y: player.y,
                                    end: player.zeusHeavenlyShieldEndTime,
                                    radius: ZEUS_HEAVENLY_SHIELD_RADIUS,
                                    t: 0, life: ZEUS_HEAVENLY_SHIELD_DURATION
                                });
                                for(let i=0; i<10; i++) vfx.zeusHeavenlyShieldWaves.push(newZeusShieldWave(player.x, player.y));

                                zeusHeavenlyShieldReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function tryZeusOlympusFury() {
                                if (currentStyle !== 'zeus') return;
                                const now = performance.now();
                                if (now < zeusOlympusFuryReadyAt) return;

                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieWeAreActive || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

                                player.zeusOlympusFuryActive = true;
                                player.zeusOlympusFuryPhase = 'pulling';
                                player.zeusOlympusFuryPullStartTime = now;
                                player.zeusOlympusFuryAimStartTime = 0;
                                player.zeusOlympusFuryShotFired = false;
                                player.zeusOlympusFuryOrigHasBall = player.hasBall;

                                if (player.hasBall) {
                                    player.zeusOlympusFuryPhase = 'aiming';
                                    player.zeusOlympusFuryAimStartTime = now;
                                    vfx.zeusOlympusFuryAura.push({
                                        x: player.x, y: player.y,
                                        end: now + ZEUS_OLYMPUS_FURY_AIM_DURATION,
                                        radius: player.r * 2.5,
                                        t: 0, life: ZEUS_OLYMPUS_FURY_AIM_DURATION
                                    });
                                } else {
                                    shockwave(player.x, player.y, player.r * 1.5, 'zeus-olympus-pull');
                                }

                                zeusOlympusFuryReadyAt = now + ABILITY_COOLDOWN * 2;
                            }

                            function zeusOlympusFuryShoot() {
                                if (currentStyle !== 'zeus' || !player.zeusOlympusFuryActive || player.zeusOlympusFuryPhase !== 'aiming') return;
                                if (!player.hasBall) {
                                    player.zeusOlympusFuryActive = false;
                                    return;
                                }
                                if (player.zeusOlympusFuryShotFired) return;

                                const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                                ball.vx = Math.cos(dir) * ZEUS_OLYMPUS_FURY_SHOT_POWER + player.vx * 0.1;
                                ball.vy = Math.sin(dir) * ZEUS_OLYMPUS_FURY_SHOT_POWER + player.vy * 0.1;
                                ball.maxSpeed = 100000;
                                player.hasBall = false;
                                player.zeusOlympusFuryShotFired = true;

                                vfx.zeusOlympusFuryBallTrail.push({
                                    end: performance.now() + 800,
                                    w: 30,
                                    colorStart: getComputedStyle(document.documentElement).getPropertyValue('--zeus-olympus-ball-trail-start'),
                                    colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--zeus-olympus-ball-trail-end')
                                });
                                shockwave(player.x, player.y, player.r * 2, 'zeus-olympus-shot');

                                vfx.zeusGroundScorches.push(newZeusGroundScorch(ball.x, ball.y));


                                const origFric = ball.friction;
                                ball.friction = 0.99;
                                setTimeout(() => {
                                    if (gameState !== 'game') return;
                                    ball.friction = origFric;
                                    ball.maxSpeed = 18;
                                }, 800);

                                player.zeusOlympusFuryActive = false;
                                player.zeusOlympusFuryPhase = '';
                                player.zeusOlympusFuryPullStartTime = 0;
                                player.zeusOlympusFuryAimStartTime = 0;
                                player.zeusOlympusFuryShotFired = false;
                                player.zeusOlympusFuryOrigHasBall = false;
                                endCharge();
                            }

                            // NEW ASHER ABILITY FUNCTIONS
                    function tryAsherAutoGoal() {
                                if (currentStyle !== 'asher') return;
                                const now = performance.now();
                                if (now < asherAutoGoalReadyAt) return;
                                if (!player.hasBall) {
                                    showNotification('starfall shot needs the ball bestie', 'warning');
                                    return;
                                }

                                // Check if another ability is active
                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive) return;

                                // Start the circling charge
                                player.asherStarfallCharging = true;
                                player.asherStarfallChargeStartTime = now;
                                player.hasBall = false; // The ball is now controlled by the orbit logic

                                shockwave(player.x, player.y, player.r * 1.5, 'asher');

                                // Set a timer to launch the ball after the orbit duration
                                setTimeout(() => {
                                    // Ensure the game is still running and the charge is active
                                    if (gameState !== 'game' || !player.asherStarfallCharging) return;

                                    player.asherStarfallCharging = false;
                                    player.asherAutoGoalActive = true;

                                    // Shoot from the ball's current position
                                    const dir = Math.atan2((H / 2) - ball.y, (W - margin) - ball.x);
                                    ball.vx = Math.cos(dir) * ASHER_HOMING_SHOT_POWER;
                                    ball.vy = Math.sin(dir) * ASHER_HOMING_SHOT_POWER;
                                    ball.maxSpeed = ASHER_HOMING_SHOT_POWER * 1.5;

                                    ball.isHoming = true;
                                    ball.homingTargetX = W - margin - (goalDepth / 2);
                                    ball.homingTargetY = H / 2;
                                    ball.homingEndTime = performance.now() + ASHER_HOMING_SHOT_DURATION;

                                    vfx.asherStarTrail.push({
                                        end: ball.homingEndTime,
                                        w: 18,
                                        colorStart: getComputedStyle(document.documentElement).getPropertyValue('--asher-star-trail-start'),
                                        colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--asher-star-trail-end')
                                    });

                                    const origFric = ball.friction;
                                    ball.friction = 0.998;
                                    setTimeout(() => {
                                        if (gameState !== 'game') return;
                                        ball.friction = origFric;
                                        ball.maxSpeed = 18;
                                        ball.isHoming = false;
                                        player.asherAutoGoalActive = false;
                                    }, ASHER_HOMING_SHOT_DURATION);

                                }, ASHER_STARFALL_CHARGE_DURATION);

                                asherAutoGoalReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function tryAsherBallTeleport() {
                                if (currentStyle !== 'asher') return;
                                const now = performance.now();
                                if (now < asherBallTeleportReadyAt) return;
                                if (player.hasBall) {
                                    showNotification('celestial pull cant be used while you have the ball', 'warning');
                                    return;
                                }

                                if (player.spinning || player.charging || player.telekinising || player.dashing ||
                                    player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging ||
                                    player.gojoPurpleActive || player.gojoRedCharging || player.eddieVenomStrikeActive || player.eddieSymbioteMontageActive ||
                                    player.zeusLightningCharging || player.zeusOlympusFuryActive || player.zeusHeavenlyShieldActive || player.asherAutoGoalActive) return;

                                // VFX at ball's original position
                                for (let i = 0; i < 20; i++) {
                                    vfx.asherTeleportBurst.push(newAsherTeleportParticle(ball.x, ball.y));
                                }
                                shockwave(ball.x, ball.y, ball.r * 2, 'asher');

                                // Teleport the ball
                                const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                                ball.x = player.x + Math.cos(dir) * (player.r + ball.r + 4);
                                ball.y = player.y + Math.sin(dir) * (player.r + ball.r + 4);
                                ball.vx = 0;
                                ball.vy = 0;
                                player.hasBall = true;

                                // VFX at ball's new position
                                for (let i = 0; i < 15; i++) {
                                    vfx.asherArrivalGlimmer.push(newAsherArrivalParticle(ball.x, ball.y));
                                }
                                shockwave(player.x, player.y, player.r, 'asher');

                                asherBallTeleportReadyAt = now + ABILITY_COOLDOWN;
                            }


                            // NEW LEONARDO ABILITY FUNCTIONS
                    // NEW LEONARDO ABILITY FUNCTIONS (UPGRADED)
                            function tryLeonardoFocusShot() {
                                if (currentStyle !== 'leonardo') return;
                                const now = performance.now();
                                if (now < leonardoFocusShotReadyAt) return;
                                if (!player.hasBall) {
                                    showNotification('focus shot needs the ball bestie', 'warning');
                                    return;
                                }

                                if (player.leonardoShieldActive || player.leonardoDashing) return;

                                const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                                ball.vx = Math.cos(dir) * LEONARDO_FOCUS_SHOT_POWER + player.vx * 0.25;
                                ball.vy = Math.sin(dir) * LEONARDO_FOCUS_SHOT_POWER + player.vy * 0.25;
                                ball.maxSpeed = 100000;
                                player.hasBall = false;
                                player.leonardoFocusShotActive = true;

                                // Trigger the new "double door" text VFX
                                vfx.leonardoFocusText.push({
                                    x: player.x, y: player.y,
                                    end: now + 1000,
                                    t: 0, life: 1000
                                });

                                // Add focus particles burst
                                for (let i = 0; i < 25; i++) {
                                    vfx.leonardoFocusParticles.push(newLeonardoFocusParticle(player.x, player.y, dir));
                                }

                                // Add a lens flare effect
                                vfx.flashes.push({
                                    x: player.x, y: player.y,
                                    t: 0, life: 400,
                                    radius: 80,
                                    color: 'rgba(165, 243, 252, 0.8)'
                                });

                                vfx.leonardoFocusTrail.push({
                                    end: performance.now() + 600,
                                    w: 22,
                                    colorStart: getComputedStyle(document.documentElement).getPropertyValue('--leonardo-focus-trail-start'),
                                    colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--leonardo-focus-trail-end')
                                });


                            Trycaption("AUTISM ATTACK!", "Zoom");
                                shockwave(player.x, player.y, 20, 'leonardo');

                                const origFric = ball.friction;
                                ball.friction = 0.993;
                                setTimeout(() => {
                                    ball.friction = origFric;
                                    ball.maxSpeed = 18;
                                    player.leonardoFocusShotActive = false;
                                }, 600);

                                leonardoFocusShotReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function tryLeonardoSensoryShield() {
                                if (currentStyle !== 'leonardo') return;
                                const now = performance.now();
                                if (now < leonardoShieldReadyAt) return;

                                if (player.leonardoFocusShotActive || player.leonardoDashing) return;

                                player.leonardoShieldActive = true;
                                player.leonardoShieldEndTime = now + LEONARDO_SHIELD_DURATION;

                                // Trigger the new geometric shield VFX
                                vfx.leonardoShieldAura.push({
                                    x: player.x, y: player.y,
                                    end: player.leonardoShieldEndTime,
                                    radius: LEONARDO_SHIELD_RADIUS,
                                    t: 0, life: LEONARDO_SHIELD_DURATION
                                });

                                // Add shield particles burst
                                for (let i = 0; i < 20; i++) {
                                    vfx.leonardoShieldParticles.push(newLeonardoShieldParticle(player.x, player.y));
                                }

                                shockwave(player.x, player.y, player.r * 1.2, 'leonardo');

                                leonardoShieldReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function tryLeonardoPatternWeave() {
                                if (currentStyle !== 'leonardo') return;
                                const now = performance.now();
                                if (now < leonardoDashReadyAt) return;

                                if (player.leonardoFocusShotActive || player.leonardoShieldActive) return;

                                player.leonardoDashing = true;
                                player.leonardoDashTimer = LEONARDO_DASH_DURATION;

                                const dashDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                                player.vx = Math.cos(dashDir) * LEONARDO_DASH_SPEED;
                                player.vy = Math.sin(dashDir) * LEONARDO_DASH_SPEED;

                                // Store the end position for the new VFX
                                player.leonardoDashEndX = player.x + Math.cos(dashDir) * LEONARDO_DASH_SPEED * (LEONARDO_DASH_DURATION / 16.67);
                                player.leonardoDashEndY = player.y + Math.sin(dashDir) * LEONARDO_DASH_SPEED * (LEONARDO_DASH_DURATION / 16.67);

                                vfx.leonardoDashTrail.push({
                                    end: now + LEONARDO_DASH_DURATION + 150,
                                    w: player.r * 1.6,
                                    colorStart: getComputedStyle(document.documentElement).getPropertyValue('--leonardo-trail-start'),
                                    colorEnd: getComputedStyle(document.documentElement).getPropertyValue('--leonardo-trail-end')
                                });

                                // Add dash particles burst
                                for (let i = 0; i < 15; i++) {
                                    vfx.leonardoDashParticles.push(newLeonardoDashParticle(player.x, player.y, dashDir));
                                }

                                setTimeout(() => {
                                    if (gameState !== 'game') return;
                                    player.leonardoDashing = false;
                                    player.vx *= 0.2;
                                    player.vy *= 0.2;
                                    // Leave the pattern field behind
                                    vfx.leonardoPatternField.push({
                                        x: player.x, y: player.y,
                                        t: 0, life: LEONARDO_PATTERN_FIELD_DURATION,
                                        radius: player.r * 3
                                    });
                                }, LEONARDO_DASH_DURATION);

                                leonardoDashReadyAt = now + ABILITY_COOLDOWN;
                            }

function tryAngusPowerBurst() {
    if (currentStyle !== 'angus') return;
    const now = performance.now();

    if (player.angusBurstUsesLeft <= 0) {
        showNotification('power burst uses exhausted', 'warning');
        return;
    }

    if (!player.hasBall) {
        showNotification('power burst needs the ball bestie', 'warning');
        return;
    }

    if (player.angusCharging) return;

    // Start charging
    player.angusCharging = true;
    player.angusChargeStartTime = now;
    TrySubtitle("AHH ITS COMING OUT");

    // Charging particles effect + white puddle
    const chargeInterval = setInterval(() => {
        if (!player.angusCharging) {
            clearInterval(chargeInterval);
            return;
        }

        // Add white charging particles around player
        for (let i = 0; i < 5; i++) {
            vfx.angusChargeParticles.push(newAngusChargeParticle(player.x, player.y));
        }

        // Add white puddle effect under player
        vfx.angusPuddles = vfx.angusPuddles || [];
        vfx.angusPuddles.push({
            x: player.x,
            y: player.y + 10, // slightly below player to look like a puddle
            t: 0,
            life: ANGUS_CHARGE_DURATION, // disappear when charging ends
            radius: 40, // size of puddle
            alpha: 0.3 // semi-transparent white
        });

    }, 50);

    setTimeout(() => {
        if (!player.angusCharging || !player.hasBall) return;

        player.angusCharging = false;
        player.angusBurstUsesLeft--;

        // Massive white burst effect
        vfx.angusBurstVFX.push({
            x: player.x, y: player.y,
            t: 0, life: 800,
            radius: 100
        });

        // Add burst particles
        for (let i = 0; i < 40; i++) {
            vfx.angusChargeParticles.push(newAngusBurstParticle(player.x, player.y));
        }
            TrySubtitle("oh.. it already did, jacob pls dont make it happen again");

        // Super powerful shot
        const dir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
        ball.vx = Math.cos(dir) * ANGUS_BURST_POWER + player.vx * 0.1;
        ball.vy = Math.sin(dir) * ANGUS_BURST_POWER + player.vy * 0.1;
        ball.maxSpeed = 100000;
        player.hasBall = false;


        shockwave(player.x, player.y, 40, 'angus');


        // Reset ball speed after some time
        setTimeout(() => {
            ball.maxSpeed = 18;
        }, 1000);

        clearInterval(chargeInterval);
    }, ANGUS_CHARGE_DURATION);
}


                            function tryAngusTimeStop() {
                                if (currentStyle !== 'angus') return;
                                const now = performance.now();
                                if (now < angusTimeStopReadyAt) return;

                                player.angusTimeStopActive = true;
                                player.angusTimeStopEndTime = now + ANGUS_TIME_STOP_DURATION;

                                // Time stop field effect
                                vfx.angusTimeStopField.push({
                                    x: player.x, y: player.y,
                                    t: 0, life: ANGUS_TIME_STOP_DURATION,
                                    radius: 200
                                });

                                // Freeze ball movement during time stop
                                const originalBallVx = ball.vx;
                                const originalBallVy = ball.vy;
                                ball.vx = 0;
                                ball.vy = 0;

                                setTimeout(() => {
                                    player.angusTimeStopActive = false;
                                    ball.vx = originalBallVx * 0.3; // Reduced speed when time resumes
                                    ball.vy = originalBallVy * 0.3;
                                }, ANGUS_TIME_STOP_DURATION);

                                angusTimeStopReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function tryAngusShadowTeleport() {
                                if (currentStyle !== 'angus') return;
                                const now = performance.now();
                                if (now < angusTeleportReadyAt) return;

                                const teleportDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                                const newX = player.x + Math.cos(teleportDir) * ANGUS_TELEPORT_RANGE;
                                const newY = player.y + Math.sin(teleportDir) * ANGUS_TELEPORT_RANGE;

                                // Clamp to field boundaries
                                const clampedX = clamp(newX, player.r + margin, W - player.r - margin);
                                const clampedY = clamp(newY, player.r + margin, H - player.r - margin);

                                // Teleport trail effect
                                vfx.angusTeleportTrail.push({
                                    startX: player.x, startY: player.y,
                                    endX: clampedX, endY: clampedY,
                                    t: 0, life: 600
                                });

                                // Teleport the player
                                player.x = clampedX;
                                player.y = clampedY;

                                shockwave(player.x, player.y, player.r * 1.5, 'angus');

                                angusTeleportReadyAt = now + ABILITY_COOLDOWN;
                            }


                            function kaiserSparks(x,y,dir){
                                for(let i=0;i<42;i++){
                                    const a = dir + (Math.random()*0.6-0.3);
                                    const sp = 4+Math.random()*6;
                                    const life = 300+Math.random()*500;
                                    vfx.sparks.push({x,y,vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life, t:0, r:2+Math.random()*2, color:'rgba(96,165,250,'});
                                }
                            }
                            function newRobsanParticle(x, y) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 0.5 + Math.random() * 2;
                                const life = 200 + Math.random() * 400;
                                return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 1 + Math.random() * 3, color: 'rgba(68, 10, 107,' };
                            }
                            function newXDrakeFootworkParticle(x, y) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 0.2 + Math.random() * 1.5;
                                const life = 150 + Math.random() * 250;
                                const size = 2 + Math.random() * 4;
                                return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: size, color: 'rgba(109, 75, 46,' };
                            }

                            function newEddieWeAreParticle(x, y) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 0.1 + Math.random() * 0.8;
                                const life = 500 + Math.random() * 500;
                                return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 2 + Math.random() * 3, color: 'rgba(20, 20, 20,' };
                            }

                            function newBlackPuddle(x, y) {
                                return {x, y, t: 0, life: PUDDLE_DURATION, r: player.r * 1.2, color: 'rgba(0,0,0,'};
                            }

                            function newZeusLightningParticle(x, y, dir) {
                                const angle = dir + (Math.random() * 0.8 - 0.4);
                                const speed = 2 + Math.random() * 5;
                                const life = 200 + Math.random() * 300;
                                return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(255, 255, 255,' };
                            }

                            function newZeusLightningChargeParticle(x, y) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 0.5 + Math.random() * 1.5;
                                const life = 150 + Math.random() * 250;
                                const offsetRadius = player.r * (0.5 + Math.random() * 0.5);
                                return {
                                    x: x + Math.cos(angle) * offsetRadius,
                                    y: y + Math.sin(angle) * offsetRadius,
                                    vx: Math.cos(angle) * speed * 0.5,
                                    vy: Math.sin(angle) * speed * 0.5,
                                    life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(59, 130, 246,'
                                };
                            }

                            function newZeusShieldWave(x, y) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 0.5 + Math.random() * 2;
                                const life = 300 + Math.random() * 400;
                                return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 2 + Math.random() * 3, color: 'rgba(59, 130, 246,' };
                            }

                            function newZeusOlympusFuryPullLine(playerX, playerY, ballX, ballY) {
                                const angle = Math.atan2(ballY - playerY, ballX - playerX);
                                const startX = playerX + Math.cos(angle) * player.r;
                                const startY = playerY + Math.sin(angle) * player.r;
                                const endX = ballX - Math.cos(angle) * ball.r;
                                const endY = ballY - Math.sin(angle) * ball.r;
                                return {
                                    startX, startY, endX, endY,
                                    t: 0, life: 200 + Math.random() * 100,
                                    thickness: 2 + Math.random() * 2,
                                    color: `rgba(255, 255, 255,`
                                };
                            }

                            function newZeusGroundScorch(x, y) {
                                return {
                                    x, y,
                                    t: 0, life: 1200 + Math.random() * 500,
                                    r: 10 + Math.random() * 10,
                                    startColor: 'rgba(253, 224, 71,',
                                    endColor: 'rgba(59, 130, 246,'
                                };
                            }

                            // NEW ASHER PARTICLE FUNCTIONS
                            function newAsherTeleportParticle(x, y) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 3 + Math.random() * 6;
                                const life = 300 + Math.random() * 400;
                                return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(233, 213, 255,' };
                            }

                            function newAsherArrivalParticle(x, y) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 1 + Math.random() * 2;
                                const life = 250 + Math.random() * 300;
                                return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 2 + Math.random() * 2, color: 'rgba(209, 213, 219,' };
                            }

                            function newHudsonSpeedLines(x, y, dir) {
                                const lines = [];
                                for(let i = 0; i < 8; i++) {
                                    lines.push({
                                        x: x + (Math.random() - 0.5) * 60,
                                        y: y + (Math.random() - 0.5) * 60,
                                        dir: dir + (Math.random() - 0.5) * 0.3,
                                        length: 40 + Math.random() * 30,
                                        t: 0, life: 300 + Math.random() * 200,
                                        color: 'rgba(79, 209, 197,'
                                    });
                                }
                                return lines;
                            }

                            function newHudsonEnergyWave(x, y) {
                                return {
                                    x, y, t: 0, life: 800,
                                    initialRadius: 5, maxRadius: 80,
                                    color: 'rgba(79, 209, 197,'
                                };
                            }

                            function newHudsonEmperorTrail(x, y, phase) {
                                const color = phase === 'left' ? 
                                    getComputedStyle(document.documentElement).getPropertyValue('--hudson-emperor-pink') :
                                    getComputedStyle(document.documentElement).getPropertyValue('--hudson-emperor-blue');
                                
                                return {
                                    x, y,
                                    life: 400, t: 0,
                                    width: 12,
                                    color: color,
                                    vx: (Math.random() - 0.5) * 2,
                                    vy: (Math.random() - 0.5) * 2
                                };
                            }

                            function newHudsonEmperorParticle(x, y, phase) {
                                const color = phase === 'left' ? 
                                    'rgba(233, 30, 99, 0.8)' :
                                    'rgba(63, 81, 181, 0.8)';
                                
                                return {
                                    x: x + (Math.random() - 0.5) * 30,
                                    y: y + (Math.random() - 0.5) * 30,
                                    life: 600, t: 0,
                                    r: 3 + Math.random() * 4,
                                    vx: (Math.random() - 0.5) * 8,
                                    vy: (Math.random() - 0.5) * 8,
                                    color: color
                                };
                            }

                            function newHudsonEmperorAura(x, y) {
                                return {
                                    x, y,
                                    life: 500, t: 0,
                                    radius: 25 + Math.random() * 15,
                                    phase: 'normal'
                                };
                            }

                            // NEW LEONARDO PARTICLE FUNCTIONS
                            function newLeonardoFocusParticle(x, y, dir) {
                                const angle = dir + (Math.random() - 0.5) * 0.4;
                                const speed = 3 + Math.random() * 8;
                                const life = 400 + Math.random() * 300;
                                return { 
                                    x, y, 
                                    vx: Math.cos(angle) * speed, 
                                    vy: Math.sin(angle) * speed, 
                                    life, t: 0, r: 1 + Math.random() * 3, 
                                    color: 'rgba(165, 243, 252,' 
                                };
                            }

                            function newLeonardoShieldParticle(x, y) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 0.5 + Math.random() * 2;
                                const life = 300 + Math.random() * 400;
                                return { 
                                    x, y, 
                                    vx: Math.cos(angle) * speed, 
                                    vy: Math.sin(angle) * speed, 
                                    life, t: 0, r: 2 + Math.random() * 2, 
                                    color: 'rgba(6, 182, 212,' 
                                };
                            }

                            function newLeonardoDashParticle(x, y, dir) {
                                const angle = dir + (Math.random() - 0.5) * 1.2;
                                const speed = 2 + Math.random() * 5;
                                const life = 250 + Math.random() * 200;
                                return { 
                                    x, y, 
                                    vx: Math.cos(angle) * speed, 
                                    vy: Math.sin(angle) * speed, 
                                    life, t: 0, r: 1 + Math.random() * 2, 
                                    color: 'rgba(165, 243, 252,' 
                                };
                            }

                            // NEW ANGUS PARTICLE FUNCTIONS
                            function newAngusChargeParticle(x, y) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 0.5 + Math.random() * 2;
                                const life = 400 + Math.random() * 300;
                                const offsetRadius = player.r * (1 + Math.random() * 2);
                                return { 
                                    x: x + Math.cos(angle) * offsetRadius,
                                    y: y + Math.sin(angle) * offsetRadius,
                                    vx: Math.cos(angle) * speed * 0.5,
                                    vy: Math.sin(angle) * speed * 0.5,
                                    life, t: 0, r: 2 + Math.random() * 3, 
                                    color: 'rgba(255, 255, 255,' 
                                };
                            }

                            function newAngusBurstParticle(x, y) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 3 + Math.random() * 8;
                                const life = 500 + Math.random() * 400;
                                return { 
                                    x, y, 
                                    vx: Math.cos(angle) * speed, 
                                    vy: Math.sin(angle) * speed, 
                                    life, t: 0, r: 2 + Math.random() * 4, 
                                    color: 'rgba(255, 255, 255,' 
                                };
                            }

                            function newRobsanShadowClones(x, y) {
                                const clones = [];
                                for(let i = 0; i < 5; i++) {
                                    const angle = (i / 5) * Math.PI * 2;
                                    clones.push({
                                        x: x + Math.cos(angle) * 25,
                                        y: y + Math.sin(angle) * 25,
                                        t: 0, life: 600 + Math.random() * 300,
                                        r: player.r * 0.8,
                                        opacity: 0.7
                                    });
                                }
                                return clones;
                            }

                            function newRobsanVoidRift(x, y) {
                                return {
                                    x, y, t: 0, life: 1000,
                                    width: 3, maxWidth: 15,
                                    height: 40, color: 'rgba(0, 0, 0,'
                                };
                            }

                            function newXDrakeNatureSpirits(x, y) {
                                const spirits = [];
                                for(let i = 0; i < 6; i++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    spirits.push({
                                        x: x + Math.cos(angle) * 20,
                                        y: y + Math.sin(angle) * 20,
                                        vx: Math.cos(angle) * 2,
                                        vy: Math.sin(angle) * 2,
                                        t: 0, life: 800 + Math.random() * 400,
                                        r: 2 + Math.random() * 3,
                                        color: 'rgba(34, 197, 94,'
                                    });
                                }
                                return spirits;
                            }

                            function newXDrakeTerraform(x, y, dir) {
                                const formations = [];
                                for(let i = 0; i < 4; i++) {
                                    formations.push({
                                        x: x + Math.cos(dir + i * 0.5) * (20 + i * 15),
                                        y: y + Math.sin(dir + i * 0.5) * (20 + i * 15),
                                        t: 0, life: 600 + i * 200,
                                        height: 5 + i * 3,
                                        color: 'rgba(109, 75, 46,'
                                    });
                                }
                                return formations;
                            }

                            function newGojoInfinityBarrier(x, y) {
                                const barriers = [];
                                for(let i = 0; i < 8; i++) {
                                    const angle = (i / 8) * Math.PI * 2;
                                    barriers.push({
                                        x: x + Math.cos(angle) * 30,
                                        y: y + Math.sin(angle) * 30,
                                        angle: angle,
                                        t: 0, life: 1200,
                                        length: 20,
                                        color: 'rgba(99, 102, 241,'
                                    });
                                }
                                return barriers;
                            }

                            function newGojoDomainExpansion(x, y) {
                                return {
                                    x, y, t: 0, life: 2000,
                                    initialRadius: 10, maxRadius: 150,
                                    intensity: 1, color: 'rgba(99, 102, 241,'
                                };
                            }

                            function newEddieSymbioteSpikes(x, y) {
                                const spikes = [];
                                for(let i = 0; i < 12; i++) {
                                    const angle = (i / 12) * Math.PI * 2;
                                    spikes.push({
                                        x: x + Math.cos(angle) * 15,
                                        y: y + Math.sin(angle) * 15,
                                        dir: angle,
                                        t: 0, life: 400 + Math.random() * 300,
                                        length: 15 + Math.random() * 10,
                                        color: 'rgba(0, 0, 0,'
                                    });
                                }
                                return spikes;
                            }

                            function newEddieVenomDrops(x, y) {
                                const drops = [];
                                for(let i = 0; i < 15; i++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const speed = 1 + Math.random() * 3;
                                    drops.push({
                                        x: x + (Math.random() - 0.5) * 40,
                                        y: y + (Math.random() - 0.5) * 40,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed,
                                        t: 0, life: 800 + Math.random() * 400,
                                        r: 2 + Math.random() * 3,
                                        color: 'rgba(100, 0, 150,'
                                    });
                                }
                                return drops;
                            }

                            function newZeusThunderClouds(x, y) {
                                const clouds = [];
                                for(let i = 0; i < 3; i++) {
                                    clouds.push({
                                        x: x + (Math.random() - 0.5) * 100,
                                        y: y - 30 - i * 20,
                                        t: 0, life: 1500 + Math.random() * 500,
                                        r: 15 + Math.random() * 10,
                                        opacity: 0.6,
                                        color: 'rgba(75, 85, 99,'
                                    });
                                }
                                return clouds;
                            }

                            function newZeusLightningBolts(x, y) {
                                const bolts = [];
                                for(let i = 0; i < 5; i++) {
                                    const segments = [];
                                    let currentX = x;
                                    let currentY = y - 50;

                                    for(let j = 0; j < 8; j++) {
                                        const nextX = currentX + (Math.random() - 0.5) * 20;
                                        const nextY = currentY + 15;
                                        segments.push({x: currentX, y: currentY, x2: nextX, y2: nextY});
                                        currentX = nextX;
                                        currentY = nextY;
                                    }

                                    bolts.push({
                                        segments: segments,
                                        t: 0, life: 200 + Math.random() * 200,
                                        thickness: 2 + Math.random() * 3,
                                        color: 'rgba(255, 255, 255,'
                                    });
                                }
                                return bolts;
                            }

                            function newHudsonImpactBurst(x, y, dir) {
                                const trails = [];
                                for(let i = 0; i < 12; i++) {
                                    const angle = dir + (Math.random() - 0.5) * 0.8;
                                    const phase = Math.random() > 0.5 ? 'left' : 'right';
                                    const color = phase === 'left' ? 
                                        getComputedStyle(document.documentElement).getPropertyValue('--hudson-emperor-pink') :
                                        getComputedStyle(document.documentElement).getPropertyValue('--hudson-emperor-blue');
                                    
                                    trails.push({
                                        x: x + Math.cos(angle) * (5 + Math.random() * 15),
                                        y: y + Math.sin(angle) * (5 + Math.random() * 15),
                                        life: 400, t: 0,
                                        width: 12,
                                        color: color,
                                        vx: Math.cos(angle) * 3,
                                        vy: Math.sin(angle) * 3
                                    });
                                }
                                return trails;
                            }

                            function newRobsanGroundRupture(x, y, dir) {
                                return {
                                    x, y,
                                    dir,
                                    t: 0, life: 500,
                                    length: 10 + Math.random() * 20,
                                    width: 2 + Math.random() * 3,
                                    color: 'rgba(20, 0, 40,'
                                };
                            }

                            function newRobsanEclipseWisp(x, y) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 0.1 + Math.random() * 0.5;
                                const life = 300 + Math.random() * 200;
                                return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(30, 0, 50,' };
                            }

                            function newRobsanVoidPuff(x, y, type) {
                                const life = 200 + Math.random() * 100;
                                const r = player.r * (0.5 + Math.random() * 0.3);
                                return { x, y, t: 0, life, r, type, color: 'rgba(0, 0, 0,' };
                            }

                            function newXDrakeGroundCrack(x, y) {
                                return {
                                    x, y,
                                    t: 0, life: 800 + Math.random() * 200,
                                    size: 15 + Math.random() * 10,
                                    color: 'rgba(5, 150, 105,'
                                };
                            }

                            function newXDrakeFootworkLeaf(x, y, dir) {
                                const angle = dir + (Math.random() * 0.8 - 0.4);
                                const speed = 1 + Math.random() * 2;
                                const life = 250 + Math.random() * 150;
                                return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 2 + Math.random() * 2, color: 'rgba(16, 185, 129,' };
                            }

                            function newXDrakeAncientApexGroundBurst(x, y) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 1 + Math.random() * 3;
                                const life = 400 + Math.random() * 200;
                                return { x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life, t: 0, r: 3 + Math.random() * 4, color: 'rgba(100, 200, 100,' };
                            }

                            function newGojoRedExplosion(x, y) {
                                return {
                                    x, y,
                                    t: 0, life: 300,
                                    radius: player.r * 1.5,
                                    color: 'rgba(229, 62, 62,'
                                };
                            }

                            function newGojoLapseBluePullParticle(startX, startY, endX, endY) {
                                const dir = Math.atan2(endY - startY, endX - startX);
                                const speed = 2 + Math.random() * 3;
                                const life = 200 + Math.random() * 100;
                                return {
                                    x: startX, y: startY,
                                    vx: Math.cos(dir) * speed * (0.8 + Math.random() * 0.4),
                                    vy: Math.sin(dir) * speed * (0.8 + Math.random() * 0.4),
                                    life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(49, 130, 206,'
                                };
                            }

                            function newGojoPurpleArc(x, y, initialAngle) {
                                return {
                                    x, y,
                                    initialAngle,
                                    t: 0, life: 600 + Math.random() * 200,
                                    radius: 10 + Math.random() * 20,
                                    color: 'rgba(128, 90, 213,'
                                };
                            }

                            function newEddieWeAreRipple(x, y) {
                                return {
                                    x, y,
                                    t: 0, life: 700 + Math.random() * 300,
                                    initialRadius: player.r * 1.5,
                                    maxRadius: player.r * 3,
                                    color: 'rgba(20, 20, 20,'
                                };
                            }

                            function newEddieVenomBallSwirlParticle(x, y, dir) {
                                const angleOffset = (Math.random() - 0.5) * Math.PI / 4;
                                const speed = 0.5 + Math.random() * 1.5;
                                const life = 150 + Math.random() * 100;
                                return {
                                    x, y,
                                    vx: Math.cos(dir + angleOffset) * speed,
                                    vy: Math.sin(dir + angleOffset) * speed,
                                    life, t: 0, r: 1 + Math.random() * 2, color: 'rgba(100, 0, 150,'
                                };
                            }

                            function newEddieTeleportFlicker(x, y) {
                                return {
                                    x, y,
                                    t: 0, life: 100,
                                    radius: player.r * 1.5,
                                    color: 'rgba(0, 0, 0,'
                                };
                            }


                            function shockwave(x,y,r0, style='hudson'){

                                let strokeColor1 = 'rgba(96,165,250,';
                                let strokeColor2 = 'rgba(244,114,182,';

                                if (style === 'robsan') {
                                    strokeColor1 = 'var(--robsan-dark-primary)';
                                    strokeColor2 = 'var(--robsan-dark-secondary)';
                                } else if (style === 'eclipse') {
                                    strokeColor1 = 'var(--eclipse-line-color)';
                                    strokeColor2 = 'var(--eclipse-line-glow)';
                                } else if (style === 'xdrake-supernova') {
                                    strokeColor1 = 'var(--xdrake-green-primary)';
                                    strokeColor2 = 'var(--xdrake-green-secondary)';
                                } else if (style === 'xdrake-footwork') {
                                    strokeColor1 = 'var(--xdrake-footwork-color)';
                                    strokeColor2 = 'var(--xdrake-green-secondary)';
                                } else if (style === 'xdrake-apex') {
                                    strokeColor1 = 'var(--xdrake-apex-aura-start)';
                                    strokeColor2 = 'var(--xdrake-apex-aura-end)';
                                } else if (style === 'gojo-red') {
                                    strokeColor1 = 'var(--gojo-red-primary)';
                                    strokeColor2 = 'var(--gojo-red-secondary)';
                                } else if (style === 'gojo-blue') {
                                    strokeColor1 = 'var(--gojo-blue-primary)';
                                    strokeColor2 = 'var(--gojo-blue-secondary)';
                                } else if (style === 'gojo-purple') {
                                    strokeColor1 = 'var(--gojo-purple-primary)';
                                    strokeColor2 = 'var(--gojo-purple-secondary)';
                                } else if (style === 'eddie-we-are') {
                                    strokeColor1 = 'var(--eddie-primary)';
                                    strokeColor2 = 'var(--eddie-secondary)';
                                } else if (style === 'eddie-venom') {
                                    strokeColor1 = 'var(--eddie-venom-strike-trail-start)';
                                    strokeColor2 = 'var(--eddie-venom-strike-trail-end)';
                                } else if (style === 'eddie-montage') {
                                    strokeColor1 = getComputedStyle(document.documentElement).getPropertyValue('--eddie-symbiote-montage-trail').trim();
                                    strokeColor2 = 'var(--eddie-primary)';
                                } else if (style === 'zeus-lightning') {
                                    strokeColor1 = 'var(--zeus-lightning-trail-start)';
                                    strokeColor2 = 'var(--zeus-lightning-trail-end)';
                                } else if (style === 'zeus-shield') {
                                    strokeColor1 = 'var(--zeus-primary)';
                                    strokeColor2 = 'var(--zeus-shield-glow)';
                                } else if (style === 'zeus-olympus-pull') {
                                    strokeColor1 = 'var(--zeus-olympus-aura-start)';
                                    strokeColor2 = 'var(--zeus-secondary)';
                                } else if (style === 'zeus-olympus-shot') {
                                    strokeColor1 = 'var(--zeus-olympus-ball-trail-start)';
                                    strokeColor2 = 'var(--zeus-olympus-aura-end)';
                                } else if (style === 'asher') { // NEW ASHER
                                    strokeColor1 = 'var(--asher-primary)';
                                    strokeColor2 = 'var(--asher-secondary)';
                                } else if (style === 'angus') { // NEW ANGUS
                                    strokeColor1 = 'var(--angus-primary)';
                                    strokeColor2 = 'var(--angus-secondary)';
                                }

                                const rootStyle = getComputedStyle(document.documentElement);
                                if (strokeColor1.startsWith('var(')) {
                                    strokeColor1 = rootStyle.getPropertyValue(strokeColor1.match(/var\(([^)]+)\)/)[1]).trim();
                                }
                                if (strokeColor2.startsWith('var(')) {
                                    strokeColor2 = rootStyle.getPropertyValue(strokeColor2.match(/var\(([^)]+)\)/)[1]).trim();
                                }
                                vfx.shockwaves.push({x,y,r:r0, t:0, life:420, color1:strokeColor1, color2:strokeColor2});
                            }
                            function impactWave(x,y,r0){ vfx.shockwaves.push({x,y,r:r0, t:0, life:260, color1:'rgba(96,165,250,', color2:'rgba(244,114,182,'}); }
                            function newLineBurst(x,y,dir){
                                const spread=(Math.random()*0.6-0.3);
                                const a=dir+spread; return {x,y,a,len:40+Math.random()*80, t:0, life:300+Math.random()*300};
                            }

                            // AI Logic Functions
                            function updateAI(dt) {
                                if (!aiEnabled) return;
                                
                                const now = performance.now();
                                
                                // AI thinks every thinkInterval milliseconds (not super fast)
                                if (now - aiPlayer.lastThinkTime > aiPlayer.thinkInterval) {
                                    aiPlayer.lastThinkTime = now;
                                    aiThink();
                                }
                                
                                // Update AI movement
                                aiMove(dt);
                                
                                // Update AI shooting
                                aiShoot(dt);
                                
                                // Apply physics to AI
                                aiPlayer.vx *= aiPlayer.drag;
                                aiPlayer.vy *= aiPlayer.drag;
                                aiPlayer.x += aiPlayer.vx;
                                aiPlayer.y += aiPlayer.vy;
                                
                                // Keep AI in bounds
                                aiPlayer.x = Math.max(aiPlayer.r, Math.min(W - aiPlayer.r, aiPlayer.x));
                                aiPlayer.y = Math.max(aiPlayer.r, Math.min(H - aiPlayer.r, aiPlayer.y));
                                
                                // Handle AI stunning
                                if (aiPlayer.isStunned && now > aiPlayer.stunEndTime) {
                                    aiPlayer.isStunned = false;
                                }

                                // Check AI-ball collision and pickup attempts (LESS AGGRESSIVE - PLAYER PRIORITY)
                                const dx = ball.x - aiPlayer.x;
                                const dy = ball.y - aiPlayer.y;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                const playerDistToBall = Math.sqrt((ball.x - player.x)**2 + (ball.y - player.y)**2);
                                
                                if (dist < aiPlayer.r + ball.r + 6 && !aiPlayer.isStunned) {
                                    if (!aiPlayer.hasBall && !player.hasBall) {
                                        // Check if player is close to ball - give player priority
                                        if (playerDistToBall < player.r + ball.r + 25) {
                                            // Player is close - don't let AI grab it, wait for player action
                                            return; // Exit early, don't pick up ball
                                        }
                                        
                                        // Check if player is dribbling nearby
                                        const playerDist = Math.sqrt((player.x - aiPlayer.x)**2 + (player.y - aiPlayer.y)**2);
                                        if (player.isDribbling && playerDist < 50) {
                                            // AI tried to pick up ball while player is dribbling - stun AI!
                                            aiPlayer.isStunned = true;
                                            aiPlayer.stunEndTime = now + 500; // 0.5 second stun
                                            aiPlayer.lastBallPickupAttempt = now;
                                            showNotification('ai got stunned for trying to steal while youre dribbling lol', 'success');
                                        } else {
                                            // Normal AI ball pickup - but only if player isn't close
                                            aiPlayer.hasBall = true;
                                            ball.vx = 0;
                                            ball.vy = 0;
                                        }
                                    }
                                }
                                
                                // Keep ball with AI if AI has it
                                if (aiPlayer.hasBall) {
                                    ball.x = aiPlayer.x + aiPlayer.r + ball.r + 2;
                                    ball.y = aiPlayer.y;
                                    ball.vx = aiPlayer.vx;
                                    ball.vy = aiPlayer.vy;
                                }
                            }
                            
                            function aiThink() {
                                // Don't think while stunned
                                if (aiPlayer.isStunned) return;

                                const distToBall = Math.sqrt((ball.x - aiPlayer.x)**2 + (ball.y - aiPlayer.y)**2);
                                const distToPlayer = Math.sqrt((player.x - aiPlayer.x)**2 + (player.y - aiPlayer.y)**2);
                                const goalX = margin; // Left goal (player's goal)
                                const goalY = H/2;
                                
                                // Smart AI decision making
                                if (aiPlayer.hasBall) {
                                    // If AI has ball, try to position for a good shot
                                    const distToGoal = Math.sqrt((goalX - aiPlayer.x)**2 + (goalY - aiPlayer.y)**2);
                                    
                                    if (distToGoal < 200 && Math.random() < aiPlayer.skill) {
                                        // Close to goal - shoot!
                                        aiPlayer.state = 'shoot';
                                    } else if (distToPlayer < 80) {
                                        // Player is close - try to get some space
                                        aiPlayer.state = 'position';
                                        aiPlayer.targetX = aiPlayer.x + (aiPlayer.x > player.x ? 50 : -50);
                                        aiPlayer.targetY = aiPlayer.y + (Math.random() - 0.5) * 100;
                                    } else {
                                        // Move closer to goal for better shot
                                        aiPlayer.state = 'position';
                                        aiPlayer.targetX = goalX + 150 + Math.random() * 100;
                                        aiPlayer.targetY = goalY + (Math.random() - 0.5) * 150;
                                    }
                                } else if (player.hasBall) {
                                    // Player has ball - defend goal
                                    aiPlayer.state = 'defend';
                                    aiPlayer.targetX = aiPlayer.defensiveX;
                                    aiPlayer.targetY = player.y; // Mirror player's Y position
                                } else {
                                    // Neither has ball - chase it (but not too aggressively)
                                    if (distToBall < distToPlayer * 1.2 || Math.random() < 0.3) {
                                        aiPlayer.state = 'chase';
                                        aiPlayer.targetX = ball.x;
                                        aiPlayer.targetY = ball.y;
                                    } else {
                                        // Sometimes position defensively instead of always chasing
                                        aiPlayer.state = 'defend';
                                        aiPlayer.targetX = aiPlayer.defensiveX;
                                        aiPlayer.targetY = ball.y;
                                    }
                                }
                            }
                            
                            function aiMove(dt) {
                                if (aiPlayer.state === 'shoot' || aiPlayer.isStunned) return; // Don't move while shooting or stunned
                                
                                const dx = aiPlayer.targetX - aiPlayer.x;
                                const dy = aiPlayer.targetY - aiPlayer.y;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                
                                if (dist > 5) {
                                    const moveX = (dx / dist) * aiPlayer.accel;
                                    const moveY = (dy / dist) * aiPlayer.accel;
                                    
                                    aiPlayer.vx += moveX;
                                    aiPlayer.vy += moveY;
                                    
                                    // Limit speed
                                    const speed = Math.sqrt(aiPlayer.vx*aiPlayer.vx + aiPlayer.vy*aiPlayer.vy);
                                    if (speed > aiPlayer.maxSpd) {
                                        aiPlayer.vx = (aiPlayer.vx / speed) * aiPlayer.maxSpd;
                                        aiPlayer.vy = (aiPlayer.vy / speed) * aiPlayer.maxSpd;
                                    }
                                }
                            }
                            
                            function aiShoot(dt) {
                                const now = performance.now();
                                
                                if (aiPlayer.state === 'shoot' && aiPlayer.hasBall) {
                                    if (!aiPlayer.shootCharging) {
                                        // Start charging shot
                                        aiPlayer.shootCharging = true;
                                        aiPlayer.shootStartTime = now;
                                        aiPlayer.shootPower = 0;
                                    } else {
                                        // Charge shot (but not too long - AI is smart, not perfect)
                                        const chargeTime = now - aiPlayer.shootStartTime;
                                        const maxChargeTime = 1000 + Math.random() * 500; // Random charge time
                                        
                                        aiPlayer.shootPower = Math.min(chargeTime / maxChargeTime, 0.8 + aiPlayer.skill * 0.2);
                                        
                                        // Shoot when charged enough or after max time
                                        if (chargeTime > 600 || aiPlayer.shootPower > 0.6) {
                                            // Calculate smart shot direction
                                            const goalX = margin;
                                            const goalY = H/2;
                                            let targetX = goalX;
                                            let targetY = goalY;
                                            
                                            // Add some accuracy variation based on skill
                                            const accuracy = aiPlayer.skill * 50;
                                            targetX += (Math.random() - 0.5) * (100 - accuracy);
                                            targetY += (Math.random() - 0.5) * (100 - accuracy);
                                            
                                            const shotDir = Math.atan2(targetY - aiPlayer.y, targetX - aiPlayer.x);
                                            const power = 8 + aiPlayer.shootPower * 12;
                                            
                                            ball.vx = Math.cos(shotDir) * power;
                                            ball.vy = Math.sin(shotDir) * power;
                                            
                                            aiPlayer.hasBall = false;
                                            aiPlayer.shootCharging = false;
                                            aiPlayer.lastShotTime = now;
                                            aiPlayer.state = 'chase';
                                        }
                                    }
                                }
                                
                                // Reset shooting state if not in shoot mode
                                if (aiPlayer.state !== 'shoot') {
                                    aiPlayer.shootCharging = false;
                                    aiPlayer.shootPower = 0;
                                }
                            }

                            function updateVFX(dt){
                                const now = performance.now();

                                vfx.trail = vfx.trail.filter(t=>performance.now()<t.end);
                                if(vfx.trail.length){
                                    if(!ball._trail) ball._trail=[];
                                    ball._trail.unshift({x:ball.x, y:ball.y, time:performance.now()});
                                    while(ball._trail.length>40) ball._trail.pop();
                                } else {
                                    ball._trail = [];
                                }


                                vfx.shadowTrails = vfx.shadowTrails.filter(t=>performance.now()<t.end);
                                if(vfx.shadowTrails.length){
                                    if(!ball._shadowTrail) ball._shadowTrail=[];
                                    ball._shadowTrail.unshift({x:ball.x, y:ball.y, time:performance.now()});
                                    while(ball._shadowTrail.length>40) ball._shadowTrail.pop();
                                } else {
                                    ball._shadowTrail = [];
                                }


                                vfx.voidTrails = vfx.voidTrails.filter(t=>performance.now()<t.end);
                                if(player.dashing && currentStyle === 'robsan'){
                                    if(!player._voidDashTrail) player._voidDashTrail=[];
                                    player._voidDashTrail.unshift({x:player.x, y:player.y, time:performance.now()});
                                    while(player._voidDashTrail.length>20) player._voidDashTrail.pop();
                                } else {
                                    player._voidDashTrail = [];
                                }


                                vfx.xdrakeSupernovaTrails = vfx.xdrakeSupernovaTrails.filter(t=>performance.now()<t.end);
                                if(player.xdrakeSupernovaDashing && currentStyle === 'xdrake'){
                                    if(!player._xdrakeSupernovaTrail) player._xdrakeSupernovaTrail=[];
                                    player._xdrakeSupernovaTrail.unshift({x:player.x, y:player.y, time:performance.now()});
                                    while(player._xdrakeSupernovaTrail.length>25) player._xdrakeSupernovaTrail.pop();
                                } else {
                                    player._xdrakeSupernovaTrail = [];
                                }


                                vfx.gojoRedTrail = vfx.gojoRedTrail.filter(t=>performance.now()<t.end);
                                if(player.gojoRedActive && ball.vx !== 0 && ball.vy !== 0){
                                    if(!ball._gojoRedTrail) ball._gojoRedTrail=[];
                                    ball._gojoRedTrail.unshift({x:ball.x, y:ball.y, time:performance.now()});
                                    while(ball._gojoRedTrail.length>40) ball._gojoRedTrail.pop();
                                } else {
                                    ball._gojoRedTrail = [];
                                }

                                // NEW DIDDY OIL TRAIL SYSTEM
                                if(ball.hasOilTrail && now < ball.oilTrailEndTime){
                                    if(!ball._diddyOilTrail) ball._diddyOilTrail=[];
                                    ball._diddyOilTrail.unshift({x:ball.x, y:ball.y, time:now});
                                    while(ball._diddyOilTrail.length>35) ball._diddyOilTrail.pop();

                                    // Create smaller oil droplets along the trail
                                    if(Math.random() < 0.4){
                                        vfx.diddySlickTrail.push({
                                            x: ball.x + (Math.random() - 0.5) * 10,
                                            y: ball.y + (Math.random() - 0.5) * 10,
                                            vx: (Math.random() - 0.5) * 1,
                                            vy: (Math.random() - 0.5) * 1,
                                            life: 600 + Math.random() * 300,
                                            t: 0,
                                            r: 1 + Math.random() * 2
                                        });
                                    }
                                } else {
                                    ball._diddyOilTrail = [];
                                    ball.hasOilTrail = false;
                                }

                                // Leonardo Dash Trail
                                vfx.leonardoDashTrail = vfx.leonardoDashTrail.filter(t => performance.now() < t.end);
                                if (player.leonardoDashing && currentStyle === 'leonardo') {
                                    if (!player._leonardoDashTrail) player._leonardoDashTrail = [];
                                    player._leonardoDashTrail.unshift({ x: player.x, y: player.y, time: performance.now() });
                                    while (player._leonardoDashTrail.length > 20) player._leonardoDashTrail.pop();
                                } else {
                                    player._leonardoDashTrail = [];
                                }


                                vfx.gojoPurpleTrail = vfx.gojoPurpleTrail.filter(t=>performance.now()<t.end);
                                if (vfx.gojoPurpleTrail.length > 0 && ball.vx !== 0 && ball.vy !== 0) {
                                    if (!ball._gojoPurpleTrail) ball._gojoPurpleTrail = [];
                                    ball._gojoPurpleTrail.unshift({x: ball.x, y: ball.y, time: performance.now()});
                                    while(ball._gojoPurpleTrail.length > 50) ball._gojoPurpleTrail.pop();
                                } else {
                                    ball._gojoPurpleTrail = [];
                                }


                                vfx.eddieVenomShotTrail = vfx.eddieVenomShotTrail.filter(t=>performance.now()<t.end);
                                if (vfx.eddieVenomShotTrail.length > 0 && ball.vx !== 0 && ball.vy !== 0) {
                                    if (!ball._eddieVenomShotTrail) ball._eddieVenomShotTrail = [];
                                    ball._eddieVenomShotTrail.unshift({x: ball.x, y: ball.y, time: performance.now()});
                                    while(ball._eddieVenomShotTrail.length > 40) ball._eddieVenomShotTrail.pop();
                                } else {
                                    ball._eddieVenomShotTrail = [];
                                }

                                vfx.zeusLightningTrail = vfx.zeusLightningTrail.filter(t=>performance.now()<t.end);
                                if(player.zeusLightningActive && ball.vx !== 0 && ball.vy !== 0){
                                    if(!ball._zeusLightningTrail) ball._zeusLightningTrail=[];
                                    ball._zeusLightningTrail.unshift({x:ball.x, y:ball.y, time:performance.now()});
                                    while(ball._zeusLightningTrail.length>30) ball._zeusLightningTrail.pop();
                                } else {
                                    ball._zeusLightningTrail = [];
                                }

                                vfx.zeusOlympusFuryBallTrail = vfx.zeusOlympusFuryBallTrail.filter(t=>performance.now()<t.end);
                                if(vfx.zeusOlympusFuryBallTrail.length > 0 && ball.vx !== 0 && ball.vy !== 0){
                                    if(!ball._zeusOlympusFuryBallTrail) ball._zeusOlympusFuryBallTrail=[];
                                    ball._zeusOlympusFuryBallTrail.unshift({x:ball.x, y:ball.y, time:performance.now()});
                                    while(ball._zeusOlympusFuryBallTrail.length>50) ball._zeusOlympusFuryBallTrail.pop();
                                } else {
                                    ball._zeusOlympusFuryBallTrail = [];
                                }

                                // Asher Star Trail
                                vfx.asherStarTrail = vfx.asherStarTrail.filter(t => performance.now() < t.end);
                                if (ball.isHoming) {
                                    if (!ball._asherStarTrail) ball._asherStarTrail = [];
                                    ball._asherStarTrail.unshift({ x: ball.x, y: ball.y, time: performance.now() });
                                    while (ball._asherStarTrail.length > 40) ball._asherStarTrail.pop();
                                } else {
                                    ball._asherStarTrail = [];
                                }


                                vfx.eddieSymbioteMontageAimAura = vfx.eddieSymbioteMontageAimAura.filter(a => performance.now() < a.end);
                                vfx.blackPuddles = vfx.blackPuddles.filter(p => (p.t += dt) < p.life);


                                vfx.sparks = vfx.sparks.filter(p=> (p.t+=dt) < p.life);
                                for(const p of vfx.sparks){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.98; p.vy*=0.98; }

                                vfx.robsanParticles = vfx.robsanParticles.filter(p=> (p.t+=dt) < p.life);
                                for(const p of vfx.robsanParticles){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.95; p.vy*=0.95; }

                                vfx.xdrakeFootworkDust = vfx.xdrakeFootworkDust.filter(p=> (p.t+=dt) < p.life);
                                for(const p of vfx.xdrakeFootworkDust){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.92; p.vy*=0.92; }


                                vfx.gojoBlueOrbitParticles = vfx.gojoBlueOrbitParticles.filter(p=> (p.t+=dt) < p.life);
                                for(const p of vfx.gojoBlueOrbitParticles){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9; }


                                for(const p of vfx.eddieWeAreParticles){
                                    p.t+=dt;
                                    const f = 1 - p.t/p.life; const a = f*0.8;
                                    p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9;

                                }
                                vfx.eddieWeAreParticles = vfx.eddieWeAreParticles.filter(p=> p.t < p.life);

                                vfx.zeusLightningParticles = vfx.zeusLightningParticles.filter(p=> (p.t+=dt) < p.life);
                                for(const p of vfx.zeusLightningParticles){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.95; p.vy*=0.95; }

                                vfx.zeusHeavenlyShieldWaves = vfx.zeusHeavenlyShieldWaves.filter(p=> (p.t+=dt) < p.life);
                                for(const p of vfx.zeusHeavenlyShieldWaves){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9; }

                                vfx.zeusLightningChargeEffect = vfx.zeusLightningChargeEffect.filter(p => (p.t += dt) < p.life);
                                for(const p of vfx.zeusLightningChargeEffect){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9; }

                                vfx.zeusOlympusFuryPullLines = vfx.zeusOlympusFuryPullLines.filter(l => (l.t += dt) < l.life);

                                vfx.zeusGroundScorches = vfx.zeusGroundScorches.filter(s => (s.t += dt) < s.life);

                                // Asher VFX update
                                vfx.asherTeleportBurst = vfx.asherTeleportBurst.filter(p => (p.t += dt) < p.life);
                                for (const p of vfx.asherTeleportBurst) { p.x += p.vx * (dt / 16); p.y += p.vy * (dt / 16); p.vx *= 0.96; p.vy *= 0.96; }
                                vfx.asherArrivalGlimmer = vfx.asherArrivalGlimmer.filter(p => (p.t += dt) < p.life);
                                for (const p of vfx.asherArrivalGlimmer) { p.x += p.vx * (dt / 16); p.y += p.vy * (dt / 16); p.vx *= 0.92; p.vy *= 0.92; }


                                vfx.robsanChargeAura = vfx.robsanChargeAura.filter(a=> (a.t+=dt) < a.life); 

                                vfx.eclipseAura = vfx.eclipseAura.filter(a=> (a.t+=dt) < a.life);

                                vfx.eclipseLines = vfx.eclipseLines.filter(l=> (l.t+=dt) < l.life);

                                vfx.xdrakeApexAura = vfx.xdrakeApexAura.filter(a=> (a.t+=dt) < a.life);

                                vfx.gojoPurpleCombineVFX = vfx.gojoPurpleCombineVFX.filter(v=> (v.t+=dt) < v.life);


                                for(const aura of vfx.eddieWeAreAura){
                                    aura.t += dt;

                                }
                                vfx.eddieWeAreAura = vfx.eddieWeAreAura.filter(a => a.t < a.life);

                                vfx.zeusHeavenlyShieldAura = vfx.zeusHeavenlyShieldAura.filter(a => (a.t+=dt) < a.life);

                                vfx.zeusOlympusFuryAura = vfx.zeusOlympusFuryAura.filter(a => (a.t+=dt) < a.life);

                                for(const line of vfx.eddieVenomTendrils){
                                    line.t += dt;

                                    line.endX = ball.x;
                                    line.endY = ball.y;
                                }
                                vfx.eddieVenomTendrils = vfx.eddieVenomTendrils.filter(l => l.t < l.life);

                                vfx.eddieVenomBallSwirl = vfx.eddieVenomBallSwirl.filter(p => (p.t += dt) < p.life);
                                for(const p of vfx.eddieVenomBallSwirl){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9; }

                                vfx.robsanGroundRupture = vfx.robsanGroundRupture.filter(r => (r.t += dt) < r.life);
                                vfx.robsanEclipseWisps = vfx.robsanEclipseWisps.filter(w => (w.t += dt) < w.life);
                                for(const wisp of vfx.robsanEclipseWisps){ wisp.x+=wisp.vx*(dt/16); wisp.y+=wisp.vy*(dt/16); wisp.vx*=0.95; wisp.vy*=0.95; }
                                vfx.robsanVoidPuffs = vfx.robsanVoidPuffs.filter(p => (p.t += dt) < p.life);
                                vfx.xdrakeSupernovaGroundCrack = vfx.xdrakeSupernovaGroundCrack.filter(c => (c.t += dt) < c.life);
                                vfx.xdrakeFootworkLeaves = vfx.xdrakeFootworkLeaves.filter(l => (l.t += dt) < l.life);
                                for(const leaf of vfx.xdrakeFootworkLeaves){ leaf.x+=leaf.vx*(dt/16); leaf.y+=leaf.vy*(dt/16); leaf.vx*=0.9; leaf.vy*=0.9; }
                                vfx.xdrakeAncientApexGroundBurst = vfx.xdrakeAncientApexGroundBurst.filter(b => (b.t += dt) < b.life);
                                for(const b of vfx.xdrakeAncientApexGroundBurst){ b.x+=b.vx*(dt/16); b.y+=b.vy*(dt/16); b.vx*=0.9; b.vy*=0.9; }
                                vfx.gojoRedExplosion = vfx.gojoRedExplosion.filter(e => (e.t += dt) < e.life);
                                vfx.gojoLapseBluePullEffect = vfx.gojoLapseBluePullEffect.filter(p => (p.t += dt) < p.life);
                                for(const p of vfx.gojoLapseBluePullEffect){ p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.85; p.vy*=0.85; }
                                vfx.gojoPurpleArcs = vfx.gojoPurpleArcs.filter(a => (a.t += dt) < a.life);
                                vfx.eddieWeAreRipples = vfx.eddieWeAreRipples.filter(r => (r.t += dt) < r.life);
                                vfx.eddieTeleportFlicker = vfx.eddieTeleportFlicker.filter(f => (f.t += dt) < f.life);

                                vfx.hudsonSpeedLines = vfx.hudsonSpeedLines.filter(line => (line.t += dt) < line.life);
                                vfx.hudsonEnergyWaves = vfx.hudsonEnergyWaves.filter(wave => (wave.t += dt) < wave.life);
                                vfx.hudsonEmperorDribbleTrail = vfx.hudsonEmperorDribbleTrail.filter(trail => (trail.t += dt) < trail.life);
                                vfx.hudsonEmperorDribbleParticles = vfx.hudsonEmperorDribbleParticles.filter(particle => (particle.t += dt) < particle.life);
                                vfx.hudsonEmperorDribbleAura = vfx.hudsonEmperorDribbleAura.filter(aura => (aura.t += dt) < aura.life);

                                vfx.robsanShadowClones = vfx.robsanShadowClones.filter(clone => (clone.t += dt) < clone.life);
                                vfx.robsanVoidRifts = vfx.robsanVoidRifts.filter(rift => (rift.t += dt) < rift.life);

                                vfx.xdrakeNatureSpirits = vfx.xdrakeNatureSpirits.filter(spirit => (spirit.t += dt) < spirit.life);
                                for(const spirit of vfx.xdrakeNatureSpirits) {
                                    spirit.x += spirit.vx * (dt / 16);
                                    spirit.y += spirit.vy * (dt / 16);
                                    spirit.vx *= 0.98;
                                    spirit.vy *= 0.98;
                                }
                                vfx.xdrakeTerraforms = vfx.xdrakeTerraforms.filter(terra => (terra.t += dt) < terra.life);

                                vfx.gojoInfinityBarriers = vfx.gojoInfinityBarriers.filter(barrier => (barrier.t += dt) < barrier.life);
                                vfx.gojoDomainExpansions = vfx.gojoDomainExpansions.filter(domain => (domain.t += dt) < domain.life);

                                vfx.eddieSymbioteSpikes = vfx.eddieSymbioteSpikes.filter(spike => (spike.t += dt) < spike.life);
                                vfx.eddieVenomDrops = vfx.eddieVenomDrops.filter(drop => (drop.t += dt) < drop.life);
                                for(const drop of vfx.eddieVenomDrops) {
                                    drop.x += drop.vx * (dt / 16);
                                    drop.y += drop.vy * (dt / 16);
                                    drop.vx *= 0.95;
                                    drop.vy *= 0.95;
                                }

                                vfx.zeusThunderClouds = vfx.zeusThunderClouds.filter(cloud => (cloud.t += dt) < cloud.life);
                                vfx.zeusLightningBolts = vfx.zeusLightningBolts.filter(bolt => (bolt.t += dt) < bolt.life);

                                vfx.energyResidue = vfx.energyResidue.filter(residue => (residue.t += dt) < residue.life);
                                vfx.fieldCracks = vfx.fieldCracks.filter(crack => (crack.t += dt) < crack.life);
                                vfx.shockwaveRings = vfx.shockwaveRings.filter(ring => (ring.t += dt) < ring.life);


                                vfx.shockwaves = vfx.shockwaves.filter(s=> (s.t+=dt) < s.life);
                                for(const s of vfx.shockwaves){
                                    const t = s.t/s.life; const r = s.r + t*80;
                                    const a = (1-t)*0.8;

                                    const sColor1 = getRGBA(s.color1, a);
                                    const sColor2 = getRGBA(s.color2, a * 0.8);

                                    ctx.strokeStyle=sColor1;
                                    ctx.lineWidth=3; ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2); ctx.stroke();
                                    ctx.strokeStyle=sColor2;
                                    ctx.lineWidth=1.5; ctx.beginPath(); ctx.arc(s.x,s.y,r*1.12,0,Math.PI*2); ctx.stroke();
                                }
                                for(const l of vfx.lines){
                                    const t=l.t/l.life; const a=(1-t)*0.6;
                                    const x2 = l.x + Math.cos(l.a)*l.len;
                                    const y2 = l.y + Math.sin(l.a)*l.len;
                                    ctx.strokeStyle=`rgba(255,255,255,${a})`; ctx.lineWidth=2;
                                    ctx.beginPath(); ctx.moveTo(l.x,l.y); ctx.lineTo(x2,y2); ctx.stroke();
                                }

                                for(const a of vfx.robsanAura){
                                    const progress = a.t / a.life;
                                    const currentRadius = lerp(a.radius * 0.5, a.radius * 2, progress);
                                    const opacity = (1 - progress) * 0.7;

                                    const grd = ctx.createRadialGradient(a.x, a.y, a.radius * 0.5, a.x, a.y, currentRadius);
                                    grd.addColorStop(0, `rgba(49, 46, 129, ${opacity * 0.8})`);
                                    grd.addColorStop(0.7, `rgba(76, 29, 149, ${opacity * 0.4})`);
                                    grd.addColorStop(1, `rgba(0,0,0,0)`);
                                    ctx.fillStyle = grd;
                                    ctx.beginPath();
                                    ctx.arc(a.x, a.y, currentRadius, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                if (vfx.voidTrails.length && player._voidDashTrail && player._voidDashTrail.length > 1) {
                                    for(let i=0;i<player._voidDashTrail.length-1;i++){
                                        const p=player._voidDashTrail[i], n=player._voidDashTrail[i+1];
                                        const age = (performance.now()-p.time);
                                        const a = clamp(1-age/(VOID_DASH_DURATION + 100), 0, 1)*0.9;
                                        const w = lerp(vfx.voidTrails[0].w,2,i/player._voidDashTrail.length);
                                        const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                                        g.addColorStop(0,getRGBA(vfx.voidTrails[0].trailColorStart,a));
                                        g.addColorStop(1,getRGBA(vfx.voidTrails[0].trailColorEnd,a*0.6));
                                        ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                                        ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                                    }
                                }

                                if (vfx.xdrakeSupernovaTrails.length && player._xdrakeSupernovaTrail && player._xdrakeSupernovaTrail.length > 1) {
                                    for(let i=0;i<player._xdrakeSupernovaTrail.length-1;i++){
                                        const p=player._xdrakeSupernovaTrail[i], n=player._xdrakeSupernovaTrail[i+1];
                                        const age = (performance.now()-p.time);
                                        const a = clamp(1-age/(XDRAKE_SUPERNOVA_DASH_DURATION + 100), 0, 1)*0.9;
                                        const w = lerp(vfx.xdrakeSupernovaTrails[0].w,2,i/player._xdrakeSupernovaTrail.length);
                                        const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                                        g.addColorStop(0,getRGBA(vfx.xdrakeSupernovaTrails[0].trailColorStart,a));
                                        g.addColorStop(1,getRGBA(vfx.xdrakeSupernovaTrails[0].trailColorEnd,a*0.6));
                                        ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                                        ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                                    }



                                }
                            }

                                  function drawField(){
                                ctx.save();
                                ctx.strokeStyle='rgba(255,255,255,0.7)';
                                ctx.lineWidth=3;
                                roundRect(ctx, margin, margin, W-2*margin, H-2*margin, 16);
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.moveTo(W/2, margin); ctx.lineTo(W/2, H-margin); ctx.stroke();
                                ctx.beginPath(); ctx.arc(W/2, H/2, 70, 0, Math.PI*2); ctx.stroke();
                                drawGoal(margin, H/2-goalW/2, true);
                                drawGoal(W-margin-goalDepth, H/2-goalW/2, false);
                                ctx.restore();
                            }

                            function drawGoal(x,y,left){
                                ctx.save();
                                ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.lineWidth=2.5;
                                ctx.strokeRect(x, y, goalDepth, goalW);
                                const areaW=70, areaH=goalW+60;
                                const gx = left ? margin : W-margin-areaW;
                                ctx.strokeRect(gx, H/2-areaH/2, areaW, areaH);
                                ctx.restore();
                            }

                            function drawPlayer(){
                                ctx.save();

                                const currentR = player.r; // Define currentR at the beginning of drawPlayer

                                // Draw Zeus Ground Scorches
                                for(const scorch of vfx.zeusGroundScorches){
                                    const progress = scorch.t / scorch.life;
                                    const opacity = (1 - progress) * 0.4;
                                    const currentRadius = scorch.r * (1 + progress * 0.5);

                                    const grd = ctx.createRadialGradient(scorch.x, scorch.y, 0, scorch.x, scorch.y, currentRadius);
                                    const rootStyle = getComputedStyle(document.documentElement);
                                    const startColor = rootStyle.getPropertyValue('--zeus-olympus-aura-start').trim();
                                    const endColor = rootStyle.getPropertyValue('--zeus-primary').trim();
                                    grd.addColorStop(0, getRGBA(startColor, opacity * 0.8));
                                    grd.addColorStop(1, getRGBA(endColor, opacity * 0.2));
                                    ctx.fillStyle = grd;
                                    ctx.beginPath();
                                    ctx.arc(scorch.x, scorch.y, currentRadius, 0, Math.PI * 2);
                                    ctx.fill();
                                }


                                if (player.spinning && currentStyle === 'robsan') {
                                    const spinProgress = 1 - (player.spinTimer / ROBSAN_SPIN_DURATION);
                                    const auraRadius = player.r * (1 + spinProgress * 1.5);
                                    const auraOpacity = (1 - spinProgress) * 0.6;
                                    const pulseOffset = Math.sin(performance.now() * 0.02) * 2;

                                    const grd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraRadius + pulseOffset);
                                    grd.addColorStop(0, `rgba(49, 46, 129, ${auraOpacity * 0.8})`);
                                    grd.addColorStop(0.5, `rgba(76, 29, 149, ${auraOpacity * 0.5})`);
                                    grd.addColorStop(1, `rgba(0,0,0,0)`);
                                    ctx.fillStyle = grd;
                                    ctx.beginPath();
                                    ctx.arc(player.x, player.y, auraRadius + pulseOffset, 0, Math.PI * 2);
                                    ctx.fill();

                                    for (let i = 0; i < 3; i++) {
                                        const offset = i * (spinProgress * 8);
                                        const angle = spinProgress * Math.PI * 4 + i * (Math.PI / 6);
                                        const sx = player.x + Math.cos(angle) * offset;
                                        const sy = player.y + Math.sin(angle) * offset;
                                        const shadowOpacity = (1 - spinProgress) * (0.3 - i * 0.1);
                                        if (shadowOpacity > 0) {
                                            ctx.fillStyle = `rgba(0,0,0,${shadowOpacity})`;
                                            ctx.beginPath();
                                            ctx.arc(sx, sy, player.r, 0, Math.PI * 2);
                                            ctx.fill();
                                        }
                                    }
                                }


                                if (player.charging && currentStyle === 'robsan') {
                                    const chargeProgress = 1 - (player.chargeTimer / ROBSAN_CHARGE_DURATION);
                                    const auraRadius = player.r * (1.2 + chargeProgress * 0.8);
                                    const auraOpacity = chargeProgress * 0.5 + 0.2;
                                    const pulseOffset = Math.sin(performance.now() * 0.05) * 3;

                                    const grd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraRadius + pulseOffset);
                                    grd.addColorStop(0, `rgba(30, 0, 50, ${auraOpacity * 0.6})`);
                                    grd.addColorStop(0.5, `rgba(40, 0, 60, ${auraOpacity * 0.3})`);
                                    grd.addColorStop(1, `rgba(0,0,0,0)`);
                                    ctx.fillStyle = grd;
                                    ctx.beginPath();
                                    ctx.arc(player.x, player.y, auraRadius + pulseOffset, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                for(const aura of vfx.eclipseAura){
                                    const progress = aura.t / aura.life;
                                    const currentAuraRadius = lerp(aura.radius * 0.5, aura.radius * 2, progress);
                                    const opacity = (1 - progress) * 0.6;

                                    const grd = ctx.createRadialGradient(aura.x, aura.y, aura.radius * 0.5, aura.x, aura.y, currentAuraRadius);
                                    grd.addColorStop(0, `rgba(0, 0, 0, ${opacity * 0.8})`);
                                    grd.addColorStop(0.7, `rgba(30, 0, 50, ${opacity * 0.4})`);
                                    grd.addColorStop(1, `rgba(0,0,0,0)`);
                                    ctx.fillStyle = grd;
                                    ctx.beginPath();
                                    ctx.arc(aura.x, aura.y, currentAuraRadius, 0, Math.PI * 2);
                                    ctx.fill();
                                }


                                if (player.xdrakeSupernovaDashing && currentStyle === 'xdrake') {
                                    const dashProgress = 1 - (player.xdrakeSupernovaDashTimer / XDRAKE_SUPERNOVA_DASH_DURATION);
                                    const auraRadius = player.r * (1.2 + dashProgress * 0.8);
                                    const auraOpacity = (1 - dashProgress) * 0.7;
                                    const pulseOffset = Math.sin(performance.now() * 0.08) * 4;

                                    const grd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraRadius + pulseOffset);
                                    const rootStyle = getComputedStyle(document.documentElement);
                                    const startColor = rootStyle.getPropertyValue('--xdrake-green-primary').trim();
                                    const endColor = rootStyle.getPropertyValue('--xdrake-green-secondary').trim();

                                    grd.addColorStop(0, getRGBA(startColor, auraOpacity * 0.8));
                                    grd.addColorStop(0.5, getRGBA(endColor, auraOpacity * 0.5));
                                    grd.addColorStop(1, `rgba(0,0,0,0)`);
                                    ctx.fillStyle = grd;
                                    ctx.beginPath();
                                    ctx.arc(player.x, player.y, auraRadius + pulseOffset, 0, Math.PI * 2);
                                    ctx.fill();
                                }


                                if (player.xdrakeAncientApexCharging && currentStyle === 'xdrake') {
                                    const now = performance.now();
                                    const chargeProgress = clamp((now - player.ancientApexChargeTimer) / XDRAKE_ANCIENT_APEX_CHARGE_DURATION, 0.0, 1.0);
                                    const auraRadius = player.r * (1.5 + chargeProgress * 1.5);
                                    const auraOpacity = chargeProgress * 0.6 + 0.2;
                                    const pulseOffset = Math.sin(now * 0.08) * 5;

                                    const grd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraRadius + pulseOffset);
                                    const rootStyle = getComputedStyle(document.documentElement);
                                    const startColor = rootStyle.getPropertyValue('--xdrake-apex-aura-start').trim();
                                    const midColor = rootStyle.getPropertyValue('--xdrake-green-primary').trim();
                                    const endColor = rootStyle.getPropertyValue('--xdrake-apex-aura-end').trim();

                                    grd.addColorStop(0, getRGBA(startColor, auraOpacity * 0.9));
                                    grd.addColorStop(0.5, getRGBA(midColor, auraOpacity * 0.7));
                                    grd.addColorStop(1, getRGBA(endColor, auraOpacity * 0.4));
                                    ctx.fillStyle = grd;
                                    ctx.beginPath();
                                    ctx.arc(player.x, player.y, auraRadius + pulseOffset, 0, Math.PI * 2);
                                    ctx.fill();
                                }


                                if (currentStyle === 'gojo' && (player.gojoRedActive || player.gojoLapseBlueActive || player.gojoPurpleActive || player.gojoRedCharging)) {
                                    const glowStrength = Math.sin(performance.now() * 0.01) * 0.1 + 0.3;
                                    ctx.shadowBlur = 15;
                                    ctx.shadowColor = `rgba(99, 102, 241, ${glowStrength})`;
                                }


                                if (currentStyle === 'eddie' && player.eddieWeAreActive) {
                                    const now = performance.now();
                                    const progress = 1 - (player.eddieWeAreEndTime - now) / EDDIE_WE_ARE_DURATION;
                                    const auraRadius = currentR * (1.2 + Math.sin(now * 0.02) * 0.2); // Use currentR
                                    const auraOpacity = 0.5 + Math.cos(now * 0.03) * 0.2;

                                    const grd = ctx.createRadialGradient(player.x, player.y, currentR, player.x, player.y, auraRadius);
                                    grd.addColorStop(0, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--eddie-we-are-aura').trim(), auraOpacity * 0.8));
                                    grd.addColorStop(1, `rgba(0,0,0,0)`);
                                    ctx.fillStyle = grd;
                                    ctx.beginPath();
                                    ctx.arc(player.x, player.y, auraRadius, 0, Math.PI * 2); // Use auraRadius here
                                    ctx.fill();

                                    ctx.shadowBlur = 20;
                                    ctx.shadowColor = getComputedStyle(document.documentElement).getPropertyValue('--eddie-we-are-glow').trim();
                                }

                                // Symbiote Montage aiming aura
                                if (currentStyle === 'eddie' && player.eddieSymbioteMontageActive && player.eddieSymbioteMontagePhase === 'aiming') {
                                    for(const aura of vfx.eddieSymbioteMontageAimAura){
                                        const progress = (performance.now() - aura.t) / aura.life;
                                        const currentAuraRadius = lerp(player.r * 1.5, aura.radius, progress);
                                        const opacity = (1 - progress) * 0.7; // Fade out

                                        const grd = ctx.createRadialGradient(aura.x, aura.y, player.r, aura.x, aura.y, currentAuraRadius);
                                        grd.addColorStop(0, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--eddie-symbiote-montage-trail').trim(), opacity * 0.8));
                                        grd.addColorStop(1, `rgba(0,0,0,0)`);
                                        ctx.fillStyle = grd;
                                        ctx.beginPath();
                                        ctx.arc(aura.x, aura.y, currentAuraRadius, 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                }

                                // Zeus Lightning Bolt charge aura
                                if (currentStyle === 'zeus' && player.zeusLightningCharging) {
                                    const now = performance.now();
                                    const chargeProgress = clamp((now - player.zeusLightningChargeStartTime) / ZEUS_LIGHTNING_CHARGE_DURATION, 0.0, 1.0);
                                    const auraRadius = player.r * (1.2 + chargeProgress * 0.8);
                                    const auraOpacity = chargeProgress * 0.7;
                                    const pulseOffset = Math.sin(now * 0.1) * 3;

                                    const grd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, auraRadius + pulseOffset);
                                    const rootStyle = getComputedStyle(document.documentElement);
                                    grd.addColorStop(0, getRGBA(rootStyle.getPropertyValue('--zeus-lightning-trail-start'), auraOpacity * 0.8));
                                    grd.addColorStop(0.5, getRGBA(rootStyle.getPropertyValue('--zeus-lightning-trail-end'), auraOpacity * 0.5));
                                    grd.addColorStop(1, `rgba(0,0,0,0)`);
                                    ctx.fillStyle = grd;
                                    ctx.beginPath();
                                    ctx.arc(player.x, player.y, auraRadius + pulseOffset, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // Zeus Heavenly Shield Aura
                                if (currentStyle === 'zeus' && player.zeusHeavenlyShieldActive) {
                                    for (const aura of vfx.zeusHeavenlyShieldAura) {
                                        const progress = aura.t / aura.life;
                                        const currentRadius = lerp(aura.radius * 0.5, aura.radius, progress);
                                        const opacity = (1 - progress) * 0.6; // Fade out slightly over time

                                        const grd = ctx.createRadialGradient(aura.x, aura.y, player.r, aura.x, aura.y, currentRadius);
                                        grd.addColorStop(0, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--zeus-shield-aura'), opacity * 0.8));
                                        grd.addColorStop(0.8, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--zeus-shield-glow'), opacity * 0.4));
                                        grd.addColorStop(1, `rgba(0,0,0,0)`);
                                        ctx.fillStyle = grd;
                                        ctx.beginPath();
                                        ctx.arc(aura.x, aura.y, currentRadius, 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                }

                                // Zeus Olympus Fury aiming aura
                                if (currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming') {
                                    for(const aura of vfx.zeusOlympusFuryAura){
                                        const progress = (performance.now() - aura.t) / aura.life;
                                        const currentAuraRadius = lerp(player.r * 1.5, aura.radius, progress);
                                        const opacity = (1 - progress) * 0.7; // Fade out

                                        const grd = ctx.createRadialGradient(aura.x, aura.y, player.r, aura.x, aura.y, currentAuraRadius);
                                        grd.addColorStop(0, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--zeus-olympus-aura-start'), opacity * 0.8));
                                        grd.addColorStop(1, `rgba(0,0,0,0)`);
                                        ctx.fillStyle = grd;
                                        ctx.beginPath();
                                        ctx.arc(aura.x, aura.y, currentAuraRadius, 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                }


                                if(player.hasBall && currentStyle === 'hudson'){
                                    const grd=ctx.createRadialGradient(player.x, player.y, player.r*0.6, player.x, player.y, player.r*1.8);
                                    grd.addColorStop(0,'rgba(79,209,197,0.35)');
                                    grd.addColorStop(1,'rgba(79,209,197,0)');
                                    ctx.fillStyle=grd;
                                    ctx.beginPath(); ctx.arc(player.x, player.y, player.r*2.2, 0, Math.PI*2); ctx.fill();
                                }


                                let playerFillColor = '#2dd4bf'; 
                                if (currentStyle === 'xdrake') {
                                    if (player.xdrakeSupernovaDashing || player.xdrakeFossilFootworking || player.xdrakeAncientApexCharging) {
                                        playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--xdrake-green-primary');
                                    } else {
                                        playerFillColor = '#2dd4bf';
                                    }
                                } else if (currentStyle === 'gojo') {
                                    playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--gojo-blue-primary');
                                } else if (currentStyle === 'eddie') {
                                    if (player.eddieWeAreActive || player.eddieAwakeningActive) {
                                        playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--eddie-secondary'); // Black
                                    } else {
                                        playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--eddie-primary'); // Dark grey
                                    }
                                } else if (currentStyle === 'zeus') { // NEW: Zeus Player Color
                                    playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--zeus-primary');
                                    if (player.zeusHeavenlyShieldActive || player.zeusLightningCharging || player.zeusOlympusFuryActive) {
                                        // Slight color shift when abilities are active
                                        playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--zeus-secondary');
                                    }
                                } else if (currentStyle === 'cristiano') {
                                    if (player.cristianoPortugueseSpiritActive) {
                                        playerFillColor = getComputedStyle(document.documentElement).getPropertyValue('--cristiano-primary'); // Red when boosted
                                    } else {
                                        playerFillColor = '#2dd4bf'; // Default cyan
                                    }
                                }

                                // EDDIE AWAKENING BLACK GLOW EFFECT
                                if (currentStyle === 'eddie' && player.eddieAwakeningActive) {
                                    const awakePulse = Math.sin(performance.now() * 0.008) * 0.4 + 0.6;
                                    const awakeRadius = player.r * (2.5 + awakePulse * 0.5);
                                    const awakeOpacity = awakePulse * 0.7;
                                    
                                    const awakeGrd = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, awakeRadius);
                                    awakeGrd.addColorStop(0, `rgba(0, 0, 0, ${awakeOpacity * 0.8})`);
                                    awakeGrd.addColorStop(0.4, `rgba(20, 20, 30, ${awakeOpacity * 0.6})`);
                                    awakeGrd.addColorStop(0.8, `rgba(40, 40, 60, ${awakeOpacity * 0.3})`);
                                    awakeGrd.addColorStop(1, `rgba(0, 0, 0, 0)`);
                                    ctx.fillStyle = awakeGrd;
                                    ctx.beginPath();
                                    ctx.arc(player.x, player.y, awakeRadius, 0, Math.PI * 2);
                                    ctx.fill();
                                    
                                    // Add shadow effect
                                    ctx.shadowBlur = 25;
                                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                                }

                                // CRISTIANO PORTUGUESE SPIRIT GLOW EFFECT
                                if (currentStyle === 'cristiano' && player.cristianoPortugueseSpiritActive) {
                                    const spiritPulse = Math.sin(performance.now() * 0.012) * 0.5 + 0.7;
                                    const spiritRadius = player.r * (3.5 + spiritPulse * 0.8);
                                    const spiritOpacity = spiritPulse * 0.8;
                                    
                                    ctx.save();
                                    
                                    // Outer red aura layer
                                    const redAura = ctx.createRadialGradient(player.x, player.y, player.r, player.x, player.y, spiritRadius);
                                    redAura.addColorStop(0, `rgba(220, 38, 38, ${spiritOpacity * 0.6})`);
                                    redAura.addColorStop(0.4, `rgba(255, 50, 50, ${spiritOpacity * 0.4})`);
                                    redAura.addColorStop(0.7, `rgba(255, 215, 0, ${spiritOpacity * 0.3})`);
                                    redAura.addColorStop(1, `rgba(0, 0, 0, 0)`);
                                    ctx.fillStyle = redAura;
                                    ctx.beginPath();
                                    ctx.arc(player.x, player.y, spiritRadius, 0, Math.PI * 2);
                                    ctx.fill();
                                    
                                    // Inner green core layer
                                    const greenCore = ctx.createRadialGradient(player.x, player.y, player.r * 0.5, player.x, player.y, spiritRadius * 0.6);
                                    greenCore.addColorStop(0, `rgba(22, 163, 74, ${spiritOpacity * 0.7})`);
                                    greenCore.addColorStop(0.5, `rgba(34, 197, 94, ${spiritOpacity * 0.5})`);
                                    greenCore.addColorStop(1, `rgba(22, 163, 74, ${spiritOpacity * 0.2})`);
                                    ctx.fillStyle = greenCore;
                                    ctx.beginPath();
                                    ctx.arc(player.x, player.y, spiritRadius * 0.6, 0, Math.PI * 2);
                                    ctx.fill();
                                    
                                    // Add powerful shadow effect
                                    ctx.shadowBlur = 30;
                                    ctx.shadowColor = `rgba(255, 215, 0, ${spiritOpacity})`;
                                    
                                    ctx.restore();
                                }

                                ctx.fillStyle=playerFillColor;
                                ctx.strokeStyle='rgba(0,0,0,.45)';
                                ctx.lineWidth=2;
                                ctx.beginPath(); ctx.arc(player.x, player.y, player.r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                                ctx.shadowBlur = 0;

                                const ang=Math.atan2(mouse.y-player.y, mouse.x-player.x);
                                const ex=player.x+Math.cos(ang)*player.r*0.5;
                                const ey=player.y+Math.sin(ang)*player.r*0.5;
                                ctx.fillStyle='#083344'; ctx.beginPath(); ctx.arc(ex, ey, 3.5, 0, Math.PI*2); ctx.fill();
                                ctx.restore();


                                if(player.hasBall && !player.gojoPurpleActive && !player.gojoRedCharging && !(currentStyle === 'eddie' && player.eddieSymbioteMontageActive) &&
                                   !player.zeusLightningCharging && !(currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming')){ // NEW ZEUS CONDITIONS
                                    ctx.save();
                                    ctx.strokeStyle='rgba(255,255,255,.8)'; ctx.setLineDash([8,6]); ctx.lineWidth=2;
                                    ctx.beginPath(); ctx.moveTo(player.x, player.y); ctx.lineTo(ball.x, ball.y); ctx.stroke();
                                    ctx.restore();
                                }


                                if (player.gojoLapseBlueActive && player.gojoLapseBlueBall) {
                                    const lb = player.gojoLapseBlueBall;
                                    ctx.save();
                                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-blue-primary');
                                    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-blue-secondary');
                                    ctx.lineWidth = 2;
                                    ctx.shadowBlur = 15;
                                    ctx.shadowColor = `rgba(49, 130, 206, 0.7)`;
                                    ctx.beginPath();
                                    ctx.arc(lb.x, lb.y, lb.r, 0, Math.PI * 2);
                                    ctx.fill();
                                    ctx.stroke();
                                    ctx.restore();
                                }


                                if (player.gojoPurpleActive) {
                                    ctx.save();
                                    ctx.shadowBlur = 20;

                                    if (player.gojoPurpleLeftBall) {
                                        const lb = player.gojoPurpleLeftBall;
                                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-red-primary');
                                        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-red-secondary');
                                        ctx.shadowColor = `rgba(229, 62, 62, 0.7)`;
                                        ctx.lineWidth = 3;
                                        ctx.beginPath();
                                        ctx.arc(lb.x, lb.y, lb.r, 0, Math.PI * 2);
                                        ctx.fill();
                                        ctx.stroke();
                                    }

                                    if (player.gojoPurpleRightBall) {
                                        const rb = player.gojoPurpleRightBall;
                                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-blue-primary');
                                        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--gojo-blue-secondary');
                                        ctx.shadowColor = `rgba(49, 130, 206, 0.7)`;
                                        ctx.lineWidth = 3;
                                        ctx.beginPath();
                                        ctx.arc(rb.x, rb.y, rb.r, 0, Math.PI * 2);
                                        ctx.fill();
                                        ctx.stroke();
                                    }
                                    ctx.restore();
                                }
                            }

                          function drawBall(){

                                if(vfx.trail.length && ball._trail && ball._trail.length > 1){
                                    for(let i=0;i<ball._trail.length-1;i++){
                                        const p=ball._trail[i], n=ball._trail[i+1];
                                        const age = (performance.now()-p.time);
                                        const a = clamp(1-age/450, 0, 1)*0.8;
                                        const w = lerp(14,2,i/ball._trail.length);
                                        const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                                        g.addColorStop(0,`rgba(96,165,250,${a})`);
                                        g.addColorStop(1,`rgba(244,114,182,${a})`);
                                        ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                                        ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                                    }
                                }

                                if(vfx.shadowTrails.length && ball._shadowTrail && ball._shadowTrail.length > 1){
                                    for(let i=0;i<ball._shadowTrail.length-1;i++){
                                        const p=ball._shadowTrail[i], n=ball._shadowTrail[i+1];
                                        const age = (performance.now()-p.time);
                                        const a = clamp(1-age/600, 0, 1)*0.9;
                                        const w = lerp(20,4,i/ball._shadowTrail.length);
                                        const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                                        g.addColorStop(0,`rgba(20, 0, 40, ${a})`); 
                                        g.addColorStop(1,`rgba(10, 0, 20, ${a * 0.6})`);
                                        ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                                        ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                                    }
                                }

                                if (vfx.xdrakeApexAura.length && ball._xdrakeApexTrail && ball._xdrakeApexTrail.length > 1) {
                                     for(let i = 0; i < ball._xdrakeApexTrail.length - 1; i++){
                                        const p = ball._xdrakeApexTrail[i], n = ball._xdrakeApexTrail[i+1];
                                        const age = (performance.now() - p.time);
                                        const a = clamp(1 - age / (vfx.xdrakeApexAura[0].life + 100), 0, 1) * 0.9;
                                        const w = lerp(24, 6, i / ball._xdrakeApexTrail.length);
                                        const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                                        const rootStyle = getComputedStyle(document.documentElement);
                                        const startColor = rootStyle.getPropertyValue('--xdrake-apex-ball-trail-start').trim();
                                        const endColor = rootStyle.getPropertyValue('--xdrake-apex-ball-trail-end').trim();
                                        g.addColorStop(0, getRGBA(startColor, a));
                                        g.addColorStop(1, getRGBA(endColor, a * 0.7));
                                        ctx.strokeStyle = g;
                                        ctx.lineWidth = w;
                                        ctx.lineCap = 'round';
                                        ctx.beginPath();
                                        ctx.moveTo(p.x, p.y);
                                        ctx.lineTo(n.x, n.y);
                                        ctx.stroke();
                                     }
                                }


                                if (vfx.gojoRedTrail.length && ball._gojoRedTrail && ball._gojoRedTrail.length > 1) {
                                    for (let i = 0; i < ball._gojoRedTrail.length - 1; i++) {
                                        const p = ball._gojoRedTrail[i], n = ball._gojoRedTrail[i+1];
                                        const age = (performance.now() - p.time);
                                        const a = clamp(1 - age / 500, 0, 1) * 0.9;
                                        const w = lerp(vfx.gojoRedTrail[0].w, 2, i / ball._gojoRedTrail.length);
                                        const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                                        g.addColorStop(0, getRGBA(vfx.gojoRedTrail[0].colorStart, a));
                                        g.addColorStop(1, getRGBA(vfx.gojoRedTrail[0].colorEnd, a * 0.6));
                                        ctx.strokeStyle = g;
                                        ctx.lineWidth = w;
                                        ctx.lineCap = 'round';
                                        ctx.beginPath();
                                        ctx.moveTo(p.x, p.y);
                                        ctx.lineTo(n.x, n.y);
                                        ctx.stroke();
                                    }
                                }


                                if (vfx.gojoPurpleTrail.length && ball._gojoPurpleTrail && ball._gojoPurpleTrail.length > 1) {
                                    for (let i = 0; i < ball._gojoPurpleTrail.length - 1; i++) {
                                        const p = ball._gojoPurpleTrail[i], n = ball._gojoPurpleTrail[i+1];
                                        const age = (performance.now() - p.time);
                                        const a = clamp(1 - age / 1000, 0, 1) * 0.9;
                                        const w = lerp(vfx.gojoPurpleTrail[0].w, 2, i / ball._gojoPurpleTrail.length);
                                        const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                                        g.addColorStop(0, getRGBA(vfx.gojoPurpleTrail[0].colorStart, a));
                                        g.addColorStop(1, getRGBA(vfx.gojoPurpleTrail[0].colorEnd, a * 0.6));
                                        ctx.strokeStyle = g;
                                        ctx.lineWidth = w;
                                        ctx.lineCap = 'round';
                                        ctx.beginPath();
                                        ctx.moveTo(p.x, p.y);
                                        ctx.lineTo(n.x, n.y);
                                        ctx.stroke();
                                    }
                                }


                                if (vfx.eddieVenomShotTrail.length && ball._eddieVenomShotTrail && ball._eddieVenomShotTrail.length > 1) {
                                    for (let i = 0; i < ball._eddieVenomShotTrail.length - 1; i++) {
                                        const p = ball._eddieVenomShotTrail[i], n = ball._eddieVenomShotTrail[i+1];
                                        const age = (performance.now() - p.time);
                                        const a = clamp(1 - age / 600, 0, 1) * 0.9;
                                        const w = lerp(vfx.eddieVenomShotTrail[0].w, 2, i / ball._eddieVenomShotTrail.length);
                                        const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                                        g.addColorStop(0, getRGBA(vfx.eddieVenomShotTrail[0].colorStart, a));
                                        g.addColorStop(1, getRGBA(vfx.eddieVenomShotTrail[0].colorEnd, a * 0.6));
                                        ctx.strokeStyle = g;
                                        ctx.lineWidth = w;
                                        ctx.lineCap = 'round';
                                        ctx.beginPath();
                                        ctx.moveTo(p.x, p.y);
                                        ctx.lineTo(n.x, n.y);
                                        ctx.stroke();
                                    }
                                }

                                // Zeus Lightning Trail
                                if (vfx.zeusLightningTrail.length && ball._zeusLightningTrail && ball._zeusLightningTrail.length > 1) {
                                    for (let i = 0; i < ball._zeusLightningTrail.length - 1; i++) {
                                        const p = ball._zeusLightningTrail[i], n = ball._zeusLightningTrail[i+1];
                                        const age = (performance.now() - p.time);
                                        const a = clamp(1 - age / 400, 0, 1) * 0.9;
                                        const w = lerp(vfx.zeusLightningTrail[0].w, 2, i / ball._zeusLightningTrail.length);
                                        const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                                        g.addColorStop(0, getRGBA(vfx.zeusLightningTrail[0].colorStart, a));
                                        g.addColorStop(1, getRGBA(vfx.zeusLightningTrail[0].colorEnd, a * 0.8));
                                        ctx.strokeStyle = g;
                                        ctx.lineWidth = w;
                                        ctx.lineCap = 'round';
                                        ctx.beginPath();
                                        ctx.moveTo(p.x, p.y);
                                        ctx.lineTo(n.x, n.y);
                                        ctx.stroke();
                                    }
                                }

                                // Zeus Olympus Fury Ball Trail
                                if (vfx.zeusOlympusFuryBallTrail.length && ball._zeusOlympusFuryBallTrail && ball._zeusOlympusFuryBallTrail.length > 1) {
                                    for (let i = 0; i < ball._zeusOlympusFuryBallTrail.length - 1; i++) {
                                        const p = ball._zeusOlympusFuryBallTrail[i], n = ball._zeusOlympusFuryBallTrail[i+1];
                                        const age = (performance.now() - p.time);
                                        const a = clamp(1 - age / 800, 0, 1) * 0.9;
                                        const w = lerp(vfx.zeusOlympusFuryBallTrail[0].w, 4, i / ball._zeusOlympusFuryBallTrail.length);
                                        const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                                        g.addColorStop(0, getRGBA(vfx.zeusOlympusFuryBallTrail[0].colorStart, a));
                                        g.addColorStop(1, getRGBA(vfx.zeusOlympusFuryBallTrail[0].colorEnd, a * 0.7));
                                        ctx.strokeStyle = g;
                                        ctx.lineWidth = w;
                                        ctx.lineCap = 'round';
                                        ctx.beginPath();
                                        ctx.moveTo(p.x, p.y);
                                        ctx.lineTo(n.x, n.y);
                                        ctx.stroke();
                                    }
                                }


                                ctx.save();
                                ctx.fillStyle='rgba(0,0,0,.25)';
                                ctx.beginPath(); ctx.ellipse(ball.x+1.5, ball.y+ball.r*0.85, ball.r*0.9, ball.r*0.5, 0, 0, Math.PI*2); ctx.fill();


                                let ballColor = '#f8fafc';
                                if (currentStyle === 'gojo') {
                                    if (player.gojoRedActive) {
                                        ballColor = getComputedStyle(document.documentElement).getPropertyValue('--gojo-red-primary');
                                    } else if (vfx.gojoPurpleTrail.length > 0) {
                                        ballColor = getComputedStyle(document.documentElement).getPropertyValue('--gojo-purple-primary');
                                    }
                                } else if (currentStyle === 'eddie' && vfx.eddieVenomShotTrail.length > 0) {
                                     ballColor = getComputedStyle(document.documentElement).getPropertyValue('--eddie-secondary');
                                } else if (currentStyle === 'zeus') { // NEW: Zeus Ball Color
                                    if (player.zeusLightningActive || vfx.zeusOlympusFuryBallTrail.length > 0) {
                                        ballColor = getComputedStyle(document.documentElement).getPropertyValue('--zeus-lightning-trail-end');
                                    } else {
                                        ballColor = '#f8fafc'; // Default white
                                    }
                                }
                                ctx.fillStyle=ballColor;

                                ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();
                                ctx.strokeStyle='#0f172a'; ctx.lineWidth=1.5; ctx.stroke();
                                ctx.beginPath();
                                for(let i=0;i<5;i++){
                                    const a=(-Math.PI/2)+i*(2*Math.PI/5);
                                    const x=ball.x+Math.cos(a)*ball.r*0.55;
                                    const y=ball.y+Math.sin(a)*ball.r*0.55;
                                    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                                }
                                ctx.closePath(); ctx.stroke();
                                ctx.restore();
                            }

                            function drawAI(){
                                if (!aiEnabled) return;
                                
                                ctx.save();
                                
                                // Draw AI player with different color to distinguish from human player
                                ctx.shadowColor = 'rgba(255, 100, 100, 0.6)';
                                ctx.shadowBlur = aiPlayer.shootCharging ? 15 : 8;
                                
                                // AI player color - reddish to distinguish from player
                                let aiFillColor = '#ef4444'; // Red color for AI
                                if (aiPlayer.shootCharging) {
                                    aiFillColor = '#dc2626'; // Darker red when charging
                                }
                                
                                ctx.fillStyle = aiFillColor;
                                ctx.strokeStyle = 'rgba(0,0,0,.45)';
                                ctx.lineWidth = 2;
                                ctx.beginPath(); 
                                ctx.arc(aiPlayer.x, aiPlayer.y, aiPlayer.r, 0, Math.PI*2); 
                                ctx.fill(); 
                                ctx.stroke();
                                ctx.shadowBlur = 0;
                                
                                // Draw AI aim line when it has the ball
                                if (aiPlayer.hasBall && aiPlayer.state === 'shoot') {
                                    const goalX = margin;
                                    const goalY = H/2;
                                    ctx.save();
                                    ctx.strokeStyle = 'rgba(255,100,100,.6)'; 
                                    ctx.setLineDash([8,6]); 
                                    ctx.lineWidth = 2;
                                    ctx.beginPath(); 
                                    ctx.moveTo(aiPlayer.x, aiPlayer.y); 
                                    ctx.lineTo(goalX, goalY); 
                                    ctx.stroke();
                                    ctx.restore();
                                }
                                
                                ctx.restore();
                            }

                            function drawUI(){
                                const now = performance.now();
                                const rootStyle = getComputedStyle(document.documentElement);


                                if(mouse.down && player.hasBall && chargeStart && !player.gojoRedCharging){
                                    const held=Math.min(now - chargeStart, AUTO_MS);
                                    const pct=held/AUTO_MS*100;
                                    powerFill.style.width=pct.toFixed(1)+'%';
                                } else if (currentStyle === 'xdrake' && player.xdrakeAncientApexCharging) {
                                    const held = Math.min(now - player.ancientApexChargeTimer, XDRAKE_ANCIENT_APEX_CHARGE_DURATION);
                                    const pct = (held / XDRAKE_ANCIENT_APEX_CHARGE_DURATION) * 100;
                                    powerFill.style.width = pct.toFixed(1) + '%';
                                } else if (currentStyle === 'gojo' && player.gojoRedCharging) {
                                    const held = Math.min(now - player.gojoRedChargeStartTime, GOJO_RED_CHARGE_DURATION);
                                    const pct = (held / GOJO_RED_CHARGE_DURATION) * 100;
                                    powerFill.style.width = pct.toFixed(1) + '%';
                                } else if (currentStyle === 'eddie' && player.eddieSymbioteMontageActive && player.eddieSymbioteMontagePhase === 'aiming') {
                                    const held = Math.min(now - player.eddieSymbioteMontageAimStartTime, EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION);
                                    const pct = (held / EDDIE_SYMBIOTE_MONTAGE_AIM_DURATION) * 100;
                                    powerFill.style.width = pct.toFixed(1) + '%';
                                } else if (currentStyle === 'zeus' && player.zeusLightningCharging) {
                                    const held = Math.min(now - player.zeusLightningChargeStartTime, ZEUS_LIGHTNING_CHARGE_DURATION);
                                    const pct = (held / ZEUS_LIGHTNING_CHARGE_DURATION) * 100;
                                    powerFill.style.width = pct.toFixed(1) + '%';
                                } else if (currentStyle === 'zeus' && player.zeusOlympusFuryActive && player.zeusOlympusFuryPhase === 'aiming') {
                                    const held = Math.min(now - player.zeusOlympusFuryAimStartTime, ZEUS_OLYMPUS_FURY_AIM_DURATION);
                                    const pct = (held / ZEUS_OLYMPUS_FURY_AIM_DURATION) * 100;
                                    powerFill.style.width = pct.toFixed(1) + '%';
                                }
                                else {
                                    powerFill.style.width = '0%';
                                }



                                let cdLeftC = 0;
                                slotC.classList.remove('ready'); 
                                slotC.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool');

                                if (currentStyle === 'hudson') {
                                    cdLeftC = Math.max(0, abilityReadyAt - now);
                                    slotC.classList.add('hudson');
                                    abilityNameCEl.textContent = 'Hudson Impact';
                                } else if (currentStyle === 'robsan') {
                                    cdLeftC = Math.max(0, shadowSpiralReadyAt - now);
                                    slotC.classList.add('robsan');
                                    abilityNameCEl.textContent = 'Shadow Spiral';
                                } else if (currentStyle === 'xdrake') {
                                    cdLeftC = Math.max(0, supernovaReadyAt - now);
                                    slotC.classList.add('xdrake');
                                    abilityNameCEl.textContent = 'Supernova';
                                } else if (currentStyle === 'gojo') {
                                    cdLeftC = Math.max(0, gojoRedReadyAt - now);
                                    slotC.classList.add('gojo');
                                    abilityNameCEl.textContent = 'Red';
                                } else if (currentStyle === 'eddie') {
                                    cdLeftC = Math.max(0, eddieWeAreReadyAt - now);
                                    slotC.classList.add('eddie');
                                    abilityNameCEl.textContent = 'We Are';
                                } else if (currentStyle === 'zeus') {
                                    cdLeftC = Math.max(0, zeusLightningReadyAt - now);
                                    slotC.classList.add('zeus');
                                    abilityNameCEl.textContent = 'Lightning Bolt';
                                } else if (currentStyle === 'asher') { // NEW ASHER
                                    cdLeftC = Math.max(0, asherAutoGoalReadyAt - now);
                                    slotC.classList.add('asher');
                                    abilityNameCEl.textContent = 'Starfall Shot';
                                } else if (currentStyle === 'leonardo') { // NEW LEONARDO
                                    cdLeftC = Math.max(0, leonardoFocusShotReadyAt - now);
                                    slotC.classList.add('leonardo');
                                    abilityNameCEl.textContent = 'Focus Shot';
                                } else if (currentStyle === 'angus') { // NEW ANGUS
                                    // Special handling for Angus - no cooldown, just usage limit
                                    cdLeftC = 0; // Always show as ready if uses left
                                    slotC.classList.add('angus');
                                    abilityNameCEl.textContent = `Power Burst (${player.angusBurstUsesLeft}/3)`;
                                } else if (currentStyle === 'diddy') { // NEW DIDDY
                                    cdLeftC = Math.max(0, diddyBabyOilReadyAt - now);
                                    slotC.classList.add('diddy');
                                    abilityNameCEl.textContent = 'Baby Oil Ascension';
                                } else if (currentStyle === 'cristiano') {
                                    cdLeftC = Math.max(0, cristianoPowerShotReadyAt - now);
                                    slotC.classList.add('cristiano');
                                    abilityNameCEl.textContent = 'Power Shot';
                                }
                                const coolPctC = clamp(1 - cdLeftC / ABILITY_COOLDOWN, 0, 1) * 100;
                                const coolElC = document.getElementById('coolC');
                                const coolTxC = document.getElementById('coolCText');
                                coolElC.style.width = `${coolPctC}%`;

                                if(cdLeftC > 0){
                                    coolTxC.textContent = (cdLeftC/1000).toFixed(1)+'s';
                                    if(currentStyle === 'xdrake') slotC.classList.add('xdrake');
                                    if(currentStyle === 'gojo') slotC.classList.add('gojo-red-cool');
                                    if(currentStyle === 'eddie') slotC.classList.add('eddie');
                                    if(currentStyle === 'zeus') slotC.classList.add('zeus');
                                    if(currentStyle === 'asher') slotC.classList.add('asher'); // NEW
                                    if(currentStyle === 'leonardo') slotC.classList.add('leonardo'); // NEW
                                    if(currentStyle === 'angus') slotC.classList.add('angus'); // NEW ANGUS
                                    if(currentStyle === 'diddy') slotC.classList.add('diddy'); // NEW DIDDY
                                    if(currentStyle === 'cristiano') slotC.classList.add('cristiano');

                                } else {
                                    slotC.classList.add('ready');
                                    coolTxC.textContent = '';
                                    if(currentStyle === 'xdrake') slotC.classList.add('xdrake');
                                    if(currentStyle === 'gojo') slotC.classList.add('gojo-red-ready');
                                    if(currentStyle === 'eddie') slotC.classList.add('eddie');
                                    if(currentStyle === 'zeus') slotC.classList.add('zeus');
                                    if(currentStyle === 'asher') slotC.classList.add('asher'); // NEW
                                    if(currentStyle === 'leonardo') slotC.classList.add('leonardo'); // NEW
                                    if(currentStyle === 'angus') slotC.classList.add('angus'); // NEW ANGUS
                                    if(currentStyle === 'diddy') slotC.classList.add('diddy'); // NEW DIDDY
                                    if(currentStyle === 'cristiano') slotC.classList.add('cristiano');

                                }
                                if (currentStyle === 'none') { slotC.style.display = 'none'; } else { slotC.style.display = 'flex'; }



                                let cdLeftV = 0;
                                slotV.classList.remove('ready'); 
                                slotV.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher','leonardo', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool');

                                if (currentStyle === 'robsan') {
                                    cdLeftV = Math.max(0, eclipseGraspReadyAt - now);
                                    slotV.classList.add('robsan');
                                    abilityNameVEl.textContent = 'Eclipse Grasp';
                                } else if (currentStyle === 'xdrake') {
                                    cdLeftV = Math.max(0, fossilFootworkReadyAt - now);
                                    slotV.classList.add('xdrake');
                                    abilityNameVEl.textContent = 'Fossilised Footwork';
                                } else if (currentStyle === 'gojo') {
                                    cdLeftV = Math.max(0, gojoLapseBlueReadyAt - now);
                                    slotV.classList.add('gojo');
                                    abilityNameVEl.textContent = 'Lapse Blue';
                                } else if (currentStyle === 'eddie') {
                                    cdLeftV = Math.max(0, eddieVenomStrikeReadyAt - now);
                                    slotV.classList.add('eddie');
                                    abilityNameVEl.textContent = 'Venom Strike';
                                } else if (currentStyle === 'zeus') {
                                    cdLeftV = Math.max(0, zeusHeavenlyShieldReadyAt - now);
                                    slotV.classList.add('zeus');
                                    abilityNameVEl.textContent = 'Heavenly Shield';
                                } else if (currentStyle === 'asher') { // NEW ASHER
                                    cdLeftV = Math.max(0, asherBallTeleportReadyAt - now);
                                    slotV.classList.add('asher');
                                    abilityNameVEl.textContent = 'Celestial Pull';
                                } else if (currentStyle === 'leonardo') { // NEW LEONARDO
                                    cdLeftV = Math.max(0, leonardoShieldReadyAt - now);
                                    slotV.classList.add('leonardo');
                                    abilityNameVEl.textContent = 'Sensory Shield';
                                } else if (currentStyle === 'angus') { // NEW ANGUS
                                    cdLeftV = Math.max(0, angusTimeStopReadyAt - now);
                                    slotV.classList.add('angus');
                                    abilityNameVEl.textContent = 'Time Stop';
                                } else if (currentStyle === 'diddy') { // NEW DIDDY
                                    cdLeftV = Math.max(0, diddySlickShotReadyAt - now);
                                    slotV.classList.add('diddy');
                                    abilityNameVEl.textContent = 'Slick Shot';
                                } else if (currentStyle === 'cristiano') {
                                    cdLeftV = Math.max(0, cristianoGoatTackleReadyAt - now);
                                    slotV.classList.add('cristiano');
                                    abilityNameVEl.textContent = "GOAT's Tackle";
                                } else if (currentStyle === 'hudson') {
                                    cdLeftV = Math.max(0, hudsonEmperorDribbleReadyAt - now);
                                    slotV.classList.add('hudson');
                                    abilityNameVEl.textContent = 'dribble like an emperor';
                                }
                                let cooldownDuration = ABILITY_COOLDOWN;
                                if (currentStyle === 'hudson') cooldownDuration = HUDSON_EMPEROR_DRIBBLE_COOLDOWN;
                                const coolPctV = clamp(1 - cdLeftV / cooldownDuration, 0, 1) * 100;
                                const coolElV = document.getElementById('coolV');
                                const coolTxV = document.getElementById('coolVText');
                                coolElV.style.width = `${coolPctV}%`;

                                if(cdLeftV > 0){
                                    coolTxV.textContent = (cdLeftV/1000).toFixed(1)+'s';
                                    if(currentStyle === 'robsan') slotV.classList.add('eclipse-cool');
                                    if(currentStyle === 'xdrake') slotV.classList.add('footwork-cool');
                                    if(currentStyle === 'gojo') slotV.classList.add('gojo-blue-cool');
                                    if(currentStyle === 'eddie') slotV.classList.add('eddie');
                                    if(currentStyle === 'zeus') slotV.classList.add('zeus');
                                    if(currentStyle === 'asher') slotV.classList.add('asher'); // NEW
                                    if(currentStyle === 'leonardo') slotV.classList.add('leonardo'); // NEW
                                    if(currentStyle === 'angus') slotV.classList.add('angus'); // NEW ANGUS
                                    if(currentStyle === 'diddy') slotV.classList.add('diddy'); // NEW DIDDY
                                    if(currentStyle === 'cristiano') slotV.classList.add('cristiano');
                                    if(currentStyle === 'hudson') slotV.classList.add('hudson');
                                } else {
                                    slotV.classList.add('ready');
                                    coolTxV.textContent = '';
                                    if(currentStyle === 'robsan') slotV.classList.add('eclipse-ready');
                                    if(currentStyle === 'xdrake') slotV.classList.add('footwork-ready');
                                    if(currentStyle === 'gojo') slotV.classList.add('gojo-blue-ready');
                                    if(currentStyle === 'eddie') slotV.classList.add('eddie');
                                    if(currentStyle === 'zeus') slotV.classList.add('zeus');
                                    if(currentStyle === 'asher') slotV.classList.add('asher'); // NEW
                                    if(currentStyle === 'leonardo') slotV.classList.add('leonardo'); // NEW
                                    if(currentStyle === 'angus') slotV.classList.add('angus'); // NEW ANGUS
                                    if(currentStyle === 'diddy') slotV.classList.add('diddy'); // NEW DIDDY
                                    if(currentStyle === 'cristiano') slotV.classList.add('cristiano');
                                    if(currentStyle === 'hudson') slotV.classList.add('hudson');
                                }
                                if (currentStyle === 'none') { slotV.style.display = 'none'; } else { slotV.style.display = 'flex'; }



                                let cdLeftX = 0;
                                slotX.classList.remove('ready'); 
                                slotX.classList.remove('hudson', 'robsan', 'xdrake', 'gojo', 'eddie', 'zeus', 'asher', 'leonardo', 'angus', 'cristiano', 'eclipse-ready', 'eclipse-cool', 'void-ready', 'void-cool', 'footwork-ready', 'footwork-cool', 'apex-ready', 'apex-cool', 'gojo-red-ready', 'gojo-red-cool', 'gojo-blue-ready', 'gojo-blue-cool', 'gojo-purple-ready', 'gojo-purple-cool');

                                if (currentStyle === 'robsan') {
                                    cdLeftX = Math.max(0, voidDashReadyAt - now);
                                    slotX.classList.add('robsan');
                                    abilityNameXEl.textContent = 'Void Dash';
                                } else if (currentStyle === 'xdrake') {
                                    cdLeftX = Math.max(0, ancientApexReadyAt - now);
                                    slotX.classList.add('xdrake');
                                    abilityNameXEl.textContent = 'Ancient Apex';
                                } else if (currentStyle === 'gojo') {
                                    cdLeftX = Math.max(0, gojoPurpleReadyAt - now);
                                    slotX.classList.add('gojo');
                                    abilityNameXEl.textContent = 'Purple';
                                } else if (currentStyle === 'eddie') {
                                    cdLeftX = Math.max(0, eddieSymbioteMontageReadyAt - now);
                                    slotX.classList.add('eddie');
                                    abilityNameXEl.textContent = 'Symbiote Montage';
                                } else if (currentStyle === 'zeus') {
                                    cdLeftX = Math.max(0, zeusOlympusFuryReadyAt - now);
                                    slotX.classList.add('zeus');
                                    abilityNameXEl.textContent = 'Olympus\' Fury';
                                } else if (currentStyle === 'leonardo') { // NEW LEONARDO
                                    cdLeftX = Math.max(0, leonardoDashReadyAt - now);
                                    slotX.classList.add('leonardo');
                                    abilityNameXEl.textContent = 'Pattern Weave';
                                } else if (currentStyle === 'angus') { // NEW ANGUS
                                    cdLeftX = Math.max(0, angusTeleportReadyAt - now);
                                    slotX.classList.add('angus');
                                    abilityNameXEl.textContent = 'Shadow Teleport';
                                } else if (currentStyle === 'diddy') { // NEW DIDDY
                                    cdLeftX = Math.max(0, diddyOilSlickReadyAt - now);
                                    slotX.classList.add('diddy');
                                    abilityNameXEl.textContent = 'Baby Oil Blindness';
                                } else if (currentStyle === 'cristiano') {
                                    cdLeftX = Math.max(0, cristianoPortugueseSpiritReadyAt - now);
                                    slotX.classList.add('cristiano');
                                    abilityNameXEl.textContent = 'Portuguese Spirit';
                                }
                                const coolPctX = clamp(1 - cdLeftX / (currentStyle === 'gojo' || currentStyle === 'eddie' || currentStyle === 'zeus' ? ABILITY_COOLDOWN * 2 : ABILITY_COOLDOWN), 0, 1) * 100;
                                const coolElX = document.getElementById('coolX');
                                const coolTxX = document.getElementById('coolXText');
                                coolElX.style.width = `${coolPctX}%`;

                                if(cdLeftX > 0){
                                    coolTxX.textContent = (cdLeftX/1000).toFixed(1)+'s';
                                    if(currentStyle === 'robsan') slotX.classList.add('void-cool');
                                    if(currentStyle === 'xdrake') slotX.classList.add('apex-cool');
                                    if(currentStyle === 'gojo') slotX.classList.add('gojo-purple-cool');
                                    if(currentStyle === 'eddie') slotX.classList.add('eddie');
                                    if(currentStyle === 'zeus') slotX.classList.add('zeus');
                                    if(currentStyle === 'leonardo') slotX.classList.add('leonardo'); // NEW
                                    if(currentStyle === 'angus') slotX.classList.add('angus'); // NEW ANGUS
                                    if(currentStyle === 'diddy') slotX.classList.add('diddy'); // NEW DIDDY
                                    if(currentStyle === 'cristiano') slotX.classList.add('cristiano');
                                } else {
                                    slotX.classList.add('ready');
                                    coolTxX.textContent = '';
                                    if(currentStyle === 'robsan') slotX.classList.add('void-ready');
                                    if(currentStyle === 'xdrake') slotX.classList.add('apex-ready');
                                    if(currentStyle === 'gojo') slotX.classList.add('gojo-purple-ready');
                                    if(currentStyle === 'eddie') slotX.classList.add('eddie');
                                    if(currentStyle === 'zeus') slotX.classList.add('zeus');
                                    if(currentStyle === 'leonardo') slotX.classList.add('leonardo'); // NEW
                                    if(currentStyle === 'angus') slotX.classList.add('angus'); // NEW ANGUS
                                    if(currentStyle === 'diddy') slotX.classList.add('diddy'); // NEW DIDDY
                                    if(currentStyle === 'cristiano') slotX.classList.add('cristiano');
                                }
                                if (currentStyle === 'none' || currentStyle === 'hudson' || currentStyle === 'asher') { slotX.style.display = 'none'; } else { slotX.style.display = 'flex'; }
                            }

                            function checkGoal(){
                                if(ball.x - ball.r <= margin + goalDepth && ball.y > H/2 - goalW/2 && ball.y < H/2 + goalW/2){
                                    scoreR++;
                                    // Increase Eddie's awakening progress by 10% when scoring goals
                                    if (currentStyle === 'eddie' && player.eddieAwakeningProgress < 100) {
                                        player.eddieAwakeningProgress = Math.min(100, player.eddieAwakeningProgress + 10);
                                        updateAwakeningBar();
                                    }
                                    resetRound();
                                }
                                if(ball.x + ball.r >= W - margin - goalDepth && ball.y > H/2 - goalW/2 && ball.y < H/2 + goalW/2){
                                    scoreL++;
                                    // Increase Eddie's awakening progress by 10% when scoring goals
                                    if (currentStyle === 'eddie' && player.eddieAwakeningProgress < 100) {
                                        player.eddieAwakeningProgress = Math.min(100, player.eddieAwakeningProgress + 10);
                                        updateAwakeningBar();
                                    }
                                    resetRound();
                                }
                            }

                            function updateAwakeningBar() {
                                if (currentStyle === 'eddie') {
                                    awakeningFill.style.width = `${player.eddieAwakeningProgress}%`;
                                    if (player.eddieAwakeningProgress >= 100) {
                                        awakeningBar.classList.add('full');
                                    } else {
                                        awakeningBar.classList.remove('full');
                                    }
                                }
                            }

                            function triggerEddieAwakening() {
                                // Set awakening state
                                player.eddieAwakeningActive = true;
                                player.eddieAwakeningEndTime = performance.now() + 100000; // 100 seconds
                                player.eddieAwakeningVideoPlaying = true;
                                
                                // Create and play video
                                const video = document.createElement('video');
                                video.src = 'venomawk.mp4';
                                video.style.position = 'fixed';
                                video.style.top = '50%';
                                video.style.left = '50%';
                                video.style.transform = 'translate(-50%, -50%)';
                                video.style.zIndex = '9999';
                                video.style.width = '100%';
                                video.style.height = '100%';
                                video.style.objectFit = 'contain';
                                video.autoplay = true;
                                video.muted = false;
                                
                                document.body.appendChild(video);
                                
                                // Remove video after 5 seconds
                                setTimeout(() => {
                                    video.remove();
                                    player.eddieAwakeningVideoPlaying = false;
                                }, 5000);
                                
                                // Update moves to awakening versions
                                updateEddieAwakeningMoves();
                                
                                // Reset awakening progress
                                player.eddieAwakeningProgress = 100; // Keep at 100 during awakening
                                updateAwakeningBar();
                            }

                            function updateEddieAwakeningMoves() {
                                if (currentStyle === 'eddie') {
                                    if (player.eddieAwakeningActive) {
                                        abilityNameCEl.textContent = 'Venom Devastation';
                                        abilityNameVEl.textContent = 'Shadow Realm';
                                        abilityNameXEl.textContent = 'Symbiote Montage';
                                    } else {
                                        abilityNameCEl.textContent = 'We Are';
                                        abilityNameVEl.textContent = 'Venom Strike';
                                        abilityNameXEl.textContent = 'Symbiote Montage';
                                    }
                                }
                            }

                            function updateEddieAwakeningTimer() {
                                if (currentStyle === 'eddie' && player.eddieAwakeningActive) {
                                    const now = performance.now();
                                    const timeLeft = player.eddieAwakeningEndTime - now;
                                    
                                    if (timeLeft <= 0) {
                                        // Awakening ended
                                        player.eddieAwakeningActive = false;
                                        player.eddieAwakeningProgress = 0;
                                        updateAwakeningBar();
                                        updateEddieAwakeningMoves();
                                    } else {
                                        // Update awakening progress (decreases from 100% to 0% over 100 seconds)
                                        const progressPercent = (timeLeft / 100000) * 100;
                                        player.eddieAwakeningProgress = Math.max(0, progressPercent);
                                        updateAwakeningBar();
                                    }
                                }
                            }

                            function resetRound(){
                                player.x=W*0.25; player.y=H*0.5; player.vx=0; player.vy=0; player.hasBall=false;
                                ball.x=W*0.5; ball.y=H*0.5; ball.vx=0; ball.vy=0;
                                
                                // Reset Eddie awakening state on round reset
                                if (currentStyle === 'eddie') {
                                    player.eddieAwakeningActive = false;
                                    // Keep awakening progress so it doesn't reset between rounds
                                    updateAwakeningBar();
                                    updateEddieAwakeningMoves();
                                }
                                ball.isHoming = false; // NEW ASHER
                                
                                // Reset AI player
                                if (aiEnabled) {
                                    aiPlayer.x = W*0.75; 
                                    aiPlayer.y = H*0.5; 
                                    aiPlayer.vx = 0; 
                                    aiPlayer.vy = 0; 
                                    aiPlayer.hasBall = false;
                                    aiPlayer.state = 'chase';
                                    aiPlayer.shootCharging = false;
                                }



                                player.spinning = false;
                                player.charging = false;
                                player.telekinising = false;
                                player.dashing = false;
                                player.xdrakeSupernovaDashing = false;
                                player.xdrakeFossilFootworking = false;
                                player.xdrakeAncientApexCharging = false;
                                player.gojoRedCharging = false;
                                player.gojoRedActive = false;
                                player.gojoLapseBlueActive = false;
                                player.gojoLapseBlueBall = null;
                                player.gojoPurpleActive = false;
                                player.gojoPurpleConverging = false;
                                player.gojoPurpleConvergenceStartTime = 0;
                                player.gojoPurpleLeftBall = null;
                                player.gojoPurpleRightBall = null;
                                player.gojoPurpleInitialDir = 0;
                                player.gojoPurpleShotFired = false;
                                gojoPurpleShockwaveEndTime = 0;

                                player.eddieWeAreActive = false;
                                player.maxSpd = player.eddieWeAreOriginalMaxSpd;
                                player.eddieWeAreEndTime = 0;

                                // Reset Cristiano state
                                player.cristianoPortugueseSpiritActive = false;
                                player.cristianoPortugueseSpiritEndTime = 0;
                                player.eddieVenomStrikeActive = false;
                                player.eddieSymbioteMontageActive = false;
                                player.eddieSymbioteMontagePhase = '';
                                player.eddieSymbioteMontageTeleportCount = 0;
                                player.eddieSymbioteMontageAimStartTime = 0;
                                player.eddieSymbioteMontageShotFired = false;

                                player.zeusLightningCharging = false;
                                player.zeusLightningChargeStartTime = 0;
                                player.zeusLightningActive = false;
                                player.zeusHeavenlyShieldActive = false;
                                player.zeusHeavenlyShieldEndTime = 0;
                                player.zeusHeavenlyShieldRadius = 0;
                                player.zeusOlympusFuryActive = false;
                                player.zeusOlympusFuryPhase = '';
                                player.zeusOlympusFuryPullStartTime = 0;
                                player.zeusOlympusFuryAimStartTime = 0;
                                player.zeusOlympusFuryShotFired = false;
                                player.zeusOlympusFuryOrigHasBall = false;
                                player.asherAutoGoalActive = false; // NEW ASHER

                                player.leonardoFocusShotActive = false;
                                player.leonardoShieldActive = false;
                                player.leonardoDashing = false;
                                // NEW ANGUS RESET PROPERTIES
                                player.angusCharging = false;
                                player.angusChargeStartTime = 0;
                                player.angusBurstUsesLeft = 3; // Reset to 3 uses
                                player.angusTimeStopActive = false;
                                player.angusTimeStopEndTime = 0;
                                player.angusTeleportActive = false;




                                vfx.trail = [];
                                vfx.sparks = [];
                                vfx.shockwaves = [];
                                vfx.flashes = [];
                                vfx.lines = [];
                                vfx.robsanParticles = [];
                                vfx.robsanAura = [];
                                vfx.shadowTrails = [];
                                vfx.robsanChargeAura = [];
                                vfx.eclipseAura = [];
                                vfx.eclipseLines = [];
                                vfx.voidTrails = [];
                                vfx.xdrakeSupernovaTrails = [];
                                vfx.xdrakeFootworkDust = [];
                                vfx.xdrakeApexAura = [];
                                vfx.gojoRedTrail = [];
                                vfx.gojoBlueOrbitParticles = [];
                                vfx.gojoPurpleCombineVFX = [];
                                vfx.gojoPurpleTrail = [];
                                vfx.eddieWeAreAura = [];
                                vfx.eddieWeAreParticles = [];
                                vfx.eddieVenomTendrils = [];
                                vfx.eddieVenomShotTrail = [];
                                vfx.eddieSymbioteMontageAimAura = [];
                                vfx.blackPuddles = [];

                                vfx.zeusLightningParticles = [];
                                vfx.zeusLightningTrail = [];
                                vfx.zeusHeavenlyShieldWaves = [];
                                vfx.zeusHeavenlyShieldAura = [];
                                vfx.zeusOlympusFuryAura = [];
                                vfx.zeusOlympusFuryBallTrail = [];
                                vfx.zeusLightningChargeEffect = [];
                                vfx.zeusOlympusFuryPullLines = [];
                                vfx.zeusGroundScorches = [];

                                // NEW ASHER VFX CLEARING
                                vfx.asherStarTrail = [];
                                vfx.asherTeleportBurst = [];
                                vfx.asherArrivalGlimmer = [];

                                vfx.hudsonEmperorDribbleTrail = [];
                                vfx.hudsonEmperorDribbleParticles = [];
                                vfx.hudsonEmperorDribbleAura = [];
                                vfx.robsanGroundRupture = [];
                                vfx.robsanEclipseWisps = [];
                                vfx.robsanVoidPuffs = [];
                                vfx.xdrakeSupernovaGroundCrack = [];
                                vfx.xdrakeFootworkLeaves = [];
                                vfx.xdrakeAncientApexGroundBurst = [];
                                vfx.gojoRedExplosion = [];
                                vfx.gojoLapseBluePullEffect = [];
                                vfx.gojoPurpleArcs = [];
                                vfx.eddieWeAreRipples = [];
                                vfx.eddieVenomBallSwirl = [];
                                vfx.eddieTeleportFlicker = [];

                                vfx.hudsonSpeedLines = [];
                                vfx.hudsonEnergyWaves = [];
                                vfx.robsanShadowClones = [];
                                vfx.robsanVoidRifts = [];
                                vfx.xdrakeNatureSpirits = [];
                                vfx.xdrakeTerraforms = [];
                                vfx.gojoInfinityBarriers = [];
                                vfx.gojoDomainExpansions = [];
                                vfx.eddieSymbioteSpikes = [];
                                vfx.eddieVenomDrops = [];
                                vfx.zeusThunderClouds = [];
                                vfx.zeusLightningBolts = [];
                                vfx.playerMovementTrail = [];
                                vfx.fieldCracks = [];
                                vfx.energyResidue = [];
                                vfx.shockwaveRings = [];
                                // NEW LEONARDO VFX CLEARING
                                vfx.leonardoFocusText = [];
                                vfx.leonardoFocusParticles = [];
                                vfx.leonardoShieldAura = [];
                                vfx.leonardoShieldParticles = [];
                                vfx.leonardoDashTrail = [];
                                vfx.leonardoDashParticles = [];
                                vfx.leonardoPatternField = [];
                                // NEW ANGUS VFX CLEARING
                                vfx.angusChargeParticles = [];
                                vfx.angusBurstVFX = [];
                                vfx.angusTimeStopField = [];
                                vfx.angusTeleportTrail = [];
                                // CRISTIANO VFX CLEARING
                                vfx.cristianoPowerShotTrail = [];
                                vfx.cristianoGoatTackleParticles = [];
                                vfx.cristianoPortugueseSpiritAura = [];
                                vfx.cristianoMovementTrail = [];
                            }

                            function resetGame(){
                                scoreL=0; scoreR=0;
                                resetRound();
                            }

                            function loop(timestamp) {
                                if (!isPlaying) return;
                                const dt = Math.min(timestamp - last, 16.67); // Cap delta time for smoother performance
                                last = timestamp;

                                updatePlayer(dt);
                                updateBall(dt);
                                updateAI(dt);
                                updateVFX(dt); 
                                updateEddieAwakeningTimer();
                                checkGoal();

                                // Use double buffering technique for smoother rendering
                                ctx.save();
                                ctx.clearRect(0, 0, W, H);
                                drawField();
                                drawBall();
                                drawPlayer();
                                drawAI();
                                drawVFX(dt); 
                                drawUI();
                                ctx.restore();

                                loopId = requestAnimationFrame(loop);
                            }


                                  function drawVFX(dt){

                                for(const p of vfx.sparks){
                                    const f = 1 - p.t/p.life; const a = f*0.9;
                                    const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*4);
                                    g.addColorStop(0,`${p.color}${a})`);
                                    g.addColorStop(1,`${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                                    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
                                }


                                // Enhanced Robsan particles with pulsing shadow effect
                                for(const p of vfx.robsanParticles){
                                    const f = 1 - p.t/p.life; 
                                    const a = f * 0.8;
                                    const pulse = Math.sin(p.t * 0.01) * 0.3 + 0.7;
                                    const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*3.5);
                                    g.addColorStop(0,`rgba(68, 10, 107, ${a * pulse})`);
                                    g.addColorStop(0.5,`rgba(99, 58, 161, ${a * 0.6})`);
                                    g.addColorStop(1,`rgba(30, 0, 50, 0)`);
                                    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r * pulse,0,Math.PI*2); ctx.fill();
                                }

                                // Enhanced XDrake earth dust with nature essence
                                for(const p of vfx.xdrakeFootworkDust){
                                    const f = 1 - p.t/p.life; 
                                    const a = f * 0.85;
                                    const earthPulse = Math.sin(p.t * 0.008) * 0.3 + 0.7;
                                    const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*3.5);
                                    g.addColorStop(0,`rgba(109, 75, 46, ${a * earthPulse})`);
                                    g.addColorStop(0.4,`rgba(34, 197, 94, ${a * 0.4})`);
                                    g.addColorStop(1,`rgba(101, 69, 34, 0)`);
                                    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r * earthPulse,0,Math.PI*2); ctx.fill();
                                }

                                // Enhanced Gojo Blue orbit particles with infinity shimmer
                                for(const p of vfx.gojoBlueOrbitParticles){
                                    const f = 1 - p.t/p.life; 
                                    const a = f * 0.9;
                                    const infinityWave = Math.sin(p.t * 0.005) * 0.4 + 0.6;
                                    const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*4);
                                    g.addColorStop(0,`rgba(49, 130, 206, ${a * infinityWave})`);
                                    g.addColorStop(0.3,`rgba(255, 255, 255, ${a * 0.5})`);
                                    g.addColorStop(1,`rgba(44, 82, 130, 0)`);
                                    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r * infinityWave,0,Math.PI*2); ctx.fill();
                                }

                                // NEW ANGUS VFX RENDERING
                                // Enhanced Angus charging particles - white floating orbs with shimmer
                                for (const p of vfx.angusChargeParticles) {
                                    const f = 1 - p.t/p.life; 
                                    const a = f * 0.9;
                                    const shimmer = Math.sin(p.t * 0.02) * 0.2 + 0.8;
                                    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 3.5);
                                    g.addColorStop(0, `rgba(255, 255, 255, ${a * shimmer})`);
                                    g.addColorStop(0.6, `rgba(243, 244, 246, ${a * 0.7})`);
                                    g.addColorStop(1, 'rgba(255, 255, 255, 0)');
                                    ctx.fillStyle = g; 
                                    ctx.beginPath(); 
                                    ctx.arc(p.x, p.y, p.r * shimmer, 0, Math.PI * 2); 
                                    ctx.fill();
                                }

                                // Burst VFX - massive white explosion
                                for (const burst of vfx.angusBurstVFX) {
                                    const progress = burst.t / burst.life;
                                    const opacity = Math.sin(progress * Math.PI) * 0.6;
                                    const radius = burst.radius * (1 + progress * 2);

                                    ctx.save();
                                    ctx.translate(burst.x, burst.y);

                                    // Central white explosion
                                    const burstGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                                    burstGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                                    burstGradient.addColorStop(0.5, `rgba(243, 244, 246, ${opacity * 0.6})`);
                                    burstGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                                    ctx.fillStyle = burstGradient;
                                    ctx.beginPath();
                                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                                    ctx.fill();

                                    // Radiating lines
                                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                                    ctx.lineWidth = 3;
                                    for (let i = 0; i < 12; i++) {
                                        const angle = (i / 12) * Math.PI * 2;
                                        const lineLength = radius * 0.7;
                                        ctx.beginPath();
                                        ctx.moveTo(Math.cos(angle) * 20, Math.sin(angle) * 20);
                                        ctx.lineTo(Math.cos(angle) * lineLength, Math.sin(angle) * lineLength);
                                        ctx.stroke();
                                    }

                                    ctx.restore();
                                }

                                if (vfx.angusPuddles) {
    for (let i = vfx.angusPuddles.length - 1; i >= 0; i--) {
        const p = vfx.angusPuddles[i];
        p.t += 30; // deltaTime from your game loop

        ctx.save();
        ctx.globalAlpha = p.alpha * (1 - p.t / p.life); // fade out gradually
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.ellipse(p.x, p.y, p.radius, p.radius * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        if (p.t >= p.life) {
            vfx.angusPuddles.splice(i, 1);
        }
    }
}


                                // Time Stop Field - gray time distortion effect
                                for (const field of vfx.angusTimeStopField) {
                                    const progress = field.t / field.life;
                                    const opacity = Math.sin(progress * Math.PI) * 0.4;
                                    const radius = field.radius;

                                    ctx.save();
                                    ctx.translate(field.x, field.y);

                                    // Time distortion rings
                                    for (let i = 0; i < 4; i++) {
                                        const ringRadius = radius * (0.3 + i * 0.2);
                                        const ringOpacity = opacity * (1 - i * 0.2);

                                        ctx.strokeStyle = `rgba(156, 163, 175, ${ringOpacity})`;
                                        ctx.lineWidth = 2;
                                        ctx.setLineDash([8, 4]);
                                        ctx.lineDashOffset = -performance.now() * 0.01 * (i + 1);
                                        ctx.beginPath();
                                        ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                                        ctx.stroke();
                                    }
                                    ctx.setLineDash([]);

                                    ctx.restore();
                                }

                                // Teleport Trail - shadow path effect
                                for (const trail of vfx.angusTeleportTrail) {
                                    const progress = trail.t / trail.life;
                                    const opacity = (1 - progress) * 0.7;

                                    ctx.save();
                                    ctx.strokeStyle = `rgba(75, 85, 99, ${opacity})`;
                                    ctx.lineWidth = 8;
                                    ctx.lineCap = 'round';

                                    // Draw shadow trail from start to end
                                    const gradient = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
                                    gradient.addColorStop(0, `rgba(156, 163, 175, ${opacity})`);
                                    gradient.addColorStop(0.5, `rgba(255, 255, 255, ${opacity * 0.8})`);
                                    gradient.addColorStop(1, `rgba(75, 85, 99, ${opacity})`);
                                    ctx.strokeStyle = gradient;

                                    ctx.beginPath();
                                    ctx.moveTo(trail.startX, trail.startY);
                                    ctx.lineTo(trail.endX, trail.endY);
                                    ctx.stroke();

                                    ctx.restore();
                                }

                                // NEW LEONARDO VFX (UPGRADED)
                                // Focus Shot Text - Double Door Swaying Open Effect
                       // Focus Shot Text - Double Door Swaying Open Effect
                    for (const text of vfx.leonardoFocusText) {
                        const progress = text.t / text.life;
                        const easeOut = 1 - Math.pow(1 - progress, 3); // Easing function
                        const opacity = Math.sin(progress * Math.PI);

                        ctx.save();
                        ctx.globalAlpha = opacity;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowColor = getComputedStyle(document.documentElement).getPropertyValue('--leonardo-accent');
                        ctx.shadowBlur = 20;
                        ctx.font = `bold 32px 'Segoe UI'`; // Adjusted font size for new text

                        // "AUTISM" on left, rotating outwards
                        ctx.save();
                        ctx.translate(text.x - (70 * easeOut), text.y);
                        ctx.rotate(-Math.PI / 12 * easeOut);
                        ctx.fillStyle = 'black';
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.font = `bold 36px 'Segoe UI'`;
                        ctx.strokeText('AUTISM', 0, 0);
                        ctx.fillText('AUTISM', 0, 0);
                        ctx.restore();

                        // "ATTACK" on right, rotating outwards
                        ctx.save();
                        ctx.translate(text.x + (70 * easeOut), text.y);
                        ctx.rotate(Math.PI / 12 * easeOut);
                        ctx.fillStyle = 'black';
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.font = `bold 36px 'Segoe UI'`;
                        ctx.strokeText('ATTACK', 0, 0);
                        ctx.fillText('ATTACK', 0, 0);
                        ctx.restore();

                        // Add central energy burst effect
                        ctx.save();
                        ctx.translate(text.x, text.y);
                        const burstRadius = 30 * (1 - progress);
                        const burstGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, burstRadius);
                        burstGradient.addColorStop(0, `rgba(165, 243, 252, ${opacity * 0.8})`);
                        burstGradient.addColorStop(1, 'rgba(165, 243, 252, 0)');
                        ctx.fillStyle = burstGradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, burstRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();

                        ctx.restore();
                    }


                                // Enhanced Sensory Shield Aura with Multiple Geometric Patterns and Particles
                                for (const aura of vfx.leonardoShieldAura) {
                                    const progress = aura.t / aura.life;
                                    const opacity = Math.sin(progress * Math.PI) * 0.4;
                                    const rotation = performance.now() * 0.001;
                                    const fastRotation = performance.now() * 0.003;

                                    ctx.save();
                                    ctx.translate(aura.x, aura.y);

                                    // Outer shield ring with energy flow
                                    ctx.strokeStyle = `rgba(6, 182, 212, ${opacity * 0.8})`;
                                    ctx.lineWidth = 3;
                                    ctx.setLineDash([10, 5]);
                                    ctx.lineDashOffset = -performance.now() * 0.05;
                                    ctx.beginPath();
                                    ctx.arc(0, 0, aura.radius, 0, Math.PI * 2);
                                    ctx.stroke();
                                    ctx.setLineDash([]);

                                    // Multiple rotating hexagonal patterns
                                    for (let layer = 0; layer < 4; layer++) {
                                        const radius = aura.radius * (0.3 + layer * 0.15);
                                        const layerRotation = rotation * (layer % 2 === 0 ? 1 : -1) * (1 + layer * 0.3);
                                        const layerOpacity = opacity * (1 - layer * 0.15);

                                        ctx.strokeStyle = `rgba(165, 243, 252, ${layerOpacity})`;
                                        ctx.lineWidth = 2 - layer * 0.3;
                                        ctx.beginPath();
                                        for (let j = 0; j < 6; j++) {
                                            const angle = (j * Math.PI / 3) + layerRotation;
                                            const x = Math.cos(angle) * radius;
                                            const y = Math.sin(angle) * radius;
                                            if (j === 0) ctx.moveTo(x, y);
                                            else ctx.lineTo(x, y);
                                        }
                                        ctx.closePath();
                                        ctx.stroke();
                                    }

                                    // Add floating energy particles around shield
                                    for (let i = 0; i < 8; i++) {
                                        const particleAngle = (i / 8) * Math.PI * 2 + fastRotation;
                                        const particleRadius = aura.radius * 0.8 + Math.sin(fastRotation * 2 + i) * 10;
                                        const px = Math.cos(particleAngle) * particleRadius;
                                        const py = Math.sin(particleAngle) * particleRadius;

                                        const particleGradient = ctx.createRadialGradient(px, py, 0, px, py, 8);
                                        particleGradient.addColorStop(0, `rgba(165, 243, 252, ${opacity * 0.9})`);
                                        particleGradient.addColorStop(1, 'rgba(165, 243, 252, 0)');
                                        ctx.fillStyle = particleGradient;
                                        ctx.beginPath();
                                        ctx.arc(px, py, 4, 0, Math.PI * 2);
                                        ctx.fill();
                                    }

                                    ctx.restore();
                                }

                                // Pattern Weave Dash Trail - Weaving Lines
                                if (vfx.leonardoDashTrail.length && player._leonardoDashTrail && player._leonardoDashTrail.length > 1) {
                                    const trail = player._leonardoDashTrail;
                                    for (let i = 0; i < trail.length - 1; i++) {
                                        const p = trail[i];
                                        const n = trail[i + 1];
                                        const age = (performance.now() - p.time);
                                        const a = clamp(1 - age / (LEONARDO_DASH_DURATION + 150), 0, 1);

                                        // Weaving line
                                        const weaveOffset = Math.sin(i * 0.8 + performance.now() * 0.02) * 10;
                                        const perpDir = Math.atan2(n.y - p.y, n.x - p.x) + Math.PI / 2;

                                        const x1 = p.x + Math.cos(perpDir) * weaveOffset;
                                        const y1 = p.y + Math.sin(perpDir) * weaveOffset;
                                        const x2 = n.x + Math.cos(perpDir) * weaveOffset;
                                        const y2 = n.y + Math.sin(perpDir) * weaveOffset;

                                        const g = ctx.createLinearGradient(x1, y1, x2, y2);
                                        g.addColorStop(0, getRGBA(vfx.leonardoDashTrail[0].colorStart, a * 0.9));
                                        g.addColorStop(1, getRGBA(vfx.leonardoDashTrail[0].colorEnd, a * 0.6));

                                        ctx.strokeStyle = g;
                                        ctx.lineWidth = 3;
                                        ctx.beginPath();
                                        ctx.moveTo(x1, y1);
                                        ctx.lineTo(x2, y2);
                                        ctx.stroke();
                                    }
                                }

                                // Enhanced Pattern Field with geometric patterns and energy waves
                                for (const field of vfx.leonardoPatternField) {
                                    const progress = field.t / field.life;
                                    const opacity = Math.sin(progress * Math.PI) * 0.3;
                                    const rotation = performance.now() * 0.002;

                                    ctx.save();
                                    ctx.translate(field.x, field.y);

                                    // Main field circle with gradient
                                    const fieldGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, field.radius);
                                    fieldGradient.addColorStop(0, `rgba(6, 182, 212, ${opacity * 0.6})`);
                                    fieldGradient.addColorStop(0.7, `rgba(165, 243, 252, ${opacity * 0.3})`);
                                    fieldGradient.addColorStop(1, 'rgba(165, 243, 252, 0)');
                                    ctx.fillStyle = fieldGradient;
                                    ctx.beginPath();
                                    ctx.arc(0, 0, field.radius, 0, Math.PI * 2);
                                    ctx.fill();

                                    // Geometric pattern grid
                                    ctx.strokeStyle = `rgba(165, 243, 252, ${opacity * 0.8})`;
                                    ctx.lineWidth = 1;
                                    const gridSize = 15;
                                    const gridCount = Math.floor(field.radius * 2 / gridSize);

                                    for (let i = -gridCount; i <= gridCount; i++) {
                                        for (let j = -gridCount; j <= gridCount; j++) {
                                            const x = i * gridSize;
                                            const y = j * gridSize;
                                            const distance = Math.sqrt(x*x + y*y);

                                            if (distance < field.radius) {
                                                const nodeOpacity = opacity * (1 - distance / field.radius);
                                                ctx.fillStyle = `rgba(165, 243, 252, ${nodeOpacity})`;
                                                ctx.beginPath();
                                                ctx.arc(x, y, 2, 0, Math.PI * 2);
                                                ctx.fill();
                                            }
                                        }
                                    }

                                    // Rotating energy rings
                                    for (let ring = 1; ring <= 3; ring++) {
                                        const ringRadius = field.radius * (ring / 4);
                                        ctx.strokeStyle = `rgba(6, 182, 212, ${opacity * (1 - ring * 0.2)})`;
                                        ctx.lineWidth = 2;
                                        ctx.setLineDash([5, 10]);
                                        ctx.lineDashOffset = -performance.now() * 0.02 * ring;
                                        ctx.beginPath();
                                        ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                                        ctx.stroke();
                                    }
                                    ctx.setLineDash([]);

                                    ctx.restore();
                                }

                                // NEW LEONARDO PARTICLE RENDERING
                                // Leonardo Focus Particles
                                for(const p of vfx.leonardoFocusParticles){
                                    p.t+=dt;
                                    const f = 1 - p.t/p.life; const a = f*0.9;
                                    p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.98; p.vy*=0.98;

                                    const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*4);
                                    g.addColorStop(0,`${p.color}${a})`);
                                    g.addColorStop(1,`${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                                    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
                                }
                                vfx.leonardoFocusParticles = vfx.leonardoFocusParticles.filter(p=> p.t < p.life);

                                // Leonardo Shield Particles
                                for(const p of vfx.leonardoShieldParticles){
                                    p.t+=dt;
                                    const f = 1 - p.t/p.life; const a = f*0.8;
                                    p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.96; p.vy*=0.96;

                                    const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*3);
                                    g.addColorStop(0,`${p.color}${a})`);
                                    g.addColorStop(1,`${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                                    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
                                }
                                vfx.leonardoShieldParticles = vfx.leonardoShieldParticles.filter(p=> p.t < p.life);

                                // Leonardo Dash Particles
                                for(const p of vfx.leonardoDashParticles){
                                    p.t+=dt;
                                    const f = 1 - p.t/p.life; const a = f*0.7;
                                    p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.94; p.vy*=0.94;

                                    const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*3);
                                    g.addColorStop(0,`${p.color}${a})`);
                                    g.addColorStop(1,`${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                                    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
                                }
                                vfx.leonardoDashParticles = vfx.leonardoDashParticles.filter(p=> p.t < p.life);

                                // NEW ANGUS PARTICLE RENDERING
                                // Angus Charge Particles
                                for(const p of vfx.angusChargeParticles){
                                    p.t+=dt;
                                    const f = 1 - p.t/p.life; 
                                    const a = f * 0.8;
                                    p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.95; p.vy*=0.95;

                                    const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*3);
                                    g.addColorStop(0,`${p.color}${a})`);
                                    g.addColorStop(1,'rgba(255, 255, 255, 0)');
                                    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
                                }
                                vfx.angusChargeParticles = vfx.angusChargeParticles.filter(p=> p.t < p.life);

                                // Angus Burst VFX - massive white explosion (updated in particles above)
                                for (const burst of vfx.angusBurstVFX) {
                                    burst.t += dt;
                                }
                                vfx.angusBurstVFX = vfx.angusBurstVFX.filter(b => b.t < b.life);

                                // Angus Time Stop Field (updated in particles above)
                                for (const field of vfx.angusTimeStopField) {
                                    field.t += dt;
                                }
                                vfx.angusTimeStopField = vfx.angusTimeStopField.filter(f => f.t < f.life);

                                // Angus Teleport Trail (updated in particles above)
                                for (const trail of vfx.angusTeleportTrail) {
                                    trail.t += dt;
                                }
                                vfx.angusTeleportTrail = vfx.angusTeleportTrail.filter(t => t.t < t.life);

                                for(const p of vfx.eddieWeAreParticles){
                                    p.t+=dt;
                                    const f = 1 - p.t/p.life; const a = f*0.8;
                                    p.x+=p.vx*(dt/16); p.y+=p.vy*(dt/16); p.vx*=0.9; p.vy*=0.9;

                                }
                                vfx.eddieWeAreParticles = vfx.eddieWeAreParticles.filter(p=> p.t < p.life);

                                // Zeus Lightning Particles
                                for(const p of vfx.zeusLightningParticles){
                                    const f = 1 - p.t/p.life; const a = f*0.9;
                                    const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*4);
                                    g.addColorStop(0,`${p.color}${a})`);
                                    g.addColorStop(1,`${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                                    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
                                }

                                // Zeus Lightning Charge Effect
                                for(const p of vfx.zeusLightningChargeEffect){
                                    const f = 1 - p.t/p.life; const a = f*0.7;
                                    ctx.fillStyle = `${p.color}${a})`;
                                    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
                                }


                                // Zeus Heavenly Shield Waves (particles)
                                for(const p of vfx.zeusHeavenlyShieldWaves){
                                    const f = 1 - p.t/p.life; const a = f*0.7;
                                    const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*3);
                                    g.addColorStop(0,`${p.color}${a})`);
                                    g.addColorStop(1,`${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                                    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
                                }




                                // Zeus Olympus Fury Pull Lines
                                for(const line of vfx.zeusOlympusFuryPullLines){
                                    const progress = line.t / line.life;
                                    const opacity = (1 - progress) * 0.8;
                                    const currentX = lerp(line.startX, line.endX, progress);
                                    const currentY = lerp(line.startY, line.endY, progress);
                                    const length = lerp(0, Math.hypot(line.endX - line.startX, line.endY - line.startY), progress);
                                    const angle = Math.atan2(line.endY - line.startY, line.endX - line.startX);

                                    ctx.save();
                                    ctx.translate(currentX, currentY);
                                    ctx.rotate(angle);
                                    ctx.strokeStyle = `${line.color}${opacity})`;
                                    ctx.lineWidth = line.thickness * (1 - progress * 0.5);
                                    ctx.beginPath();
                                    ctx.moveTo(-length/2, 0);
                                    ctx.lineTo(length/2, 0);
                                    ctx.stroke();
                                    ctx.restore();
                                }

                                vfx.robsanChargeAura = vfx.robsanChargeAura.filter(a=> (a.t+=dt) < a.life); 

                                vfx.eclipseAura = vfx.eclipseAura.filter(a=> (a.t+=dt) < a.life);

                                // Draw Eclipse Lines (Robsan's Eclipse Grasp VFX)
                                for(const line of vfx.eclipseLines){
                                    const totalProgress = line.t / line.life;
                                    if (totalProgress > 1) continue;

                                    let lineStartX, lineStartY, lineEndX, lineEndY, opacity, lineWidth;
                                    const rootStyle = getComputedStyle(document.documentElement);
                                    const color1 = rootStyle.getPropertyValue('--eclipse-line-color').trim();
                                    const color2 = rootStyle.getPropertyValue('--eclipse-line-glow').trim();

                                    if (line.phase === 'extending') {
                                        // Line extends from player to ball
                                        const extendProgress = line.t / line.extendDuration;
                                        lineStartX = line.startX;
                                        lineStartY = line.startY;
                                        lineEndX = lerp(line.startX, line.endX, Math.min(extendProgress, 1));
                                        lineEndY = lerp(line.startY, line.endY, Math.min(extendProgress, 1));
                                        opacity = Math.min(extendProgress * 2, 1); // Fade in quickly
                                        lineWidth = 6 * Math.min(extendProgress * 1.5, 1);
                                    } else {
                                        // Line retracts back to player
                                        const retractProgress = (line.t - line.extendDuration) / line.retractDuration;
                                        lineStartX = lerp(line.endX, line.startX, Math.min(retractProgress, 1));
                                        lineStartY = lerp(line.endY, line.startY, Math.min(retractProgress, 1));
                                        lineEndX = line.startX;
                                        lineEndY = line.startY;
                                        opacity = (1 - retractProgress) * 0.9; // Fade out as it retracts
                                        lineWidth = 6 * (1 - retractProgress * 0.5);
                                    }

                                    const dx = lineEndX - lineStartX;
                                    const dy = lineEndY - lineStartY;
                                    const dist = Math.hypot(dx, dy);

                                    if (dist < 1) continue; // Skip if line is too short

                                    const angle = Math.atan2(dy, dx);

                                    ctx.save();
                                    ctx.translate(lineStartX, lineStartY);
                                    ctx.rotate(angle);

                                    const segments = Math.max(Math.floor(dist / 8), 1); 
                                    ctx.beginPath();
                                    ctx.moveTo(0, 0);

                                    for (let i = 0; i <= segments; i++) {
                                        const segmentProgress = i / segments;
                                        const x = segmentProgress * dist;
                                        const wiggleOffset = Math.sin(segmentProgress * Math.PI * line.wiggleFreq + performance.now() * 0.03) * line.wiggleAmp * opacity;
                                        ctx.lineTo(x, wiggleOffset);
                                    }

                                    ctx.strokeStyle = getRGBA(color1, opacity);
                                    ctx.lineWidth = lineWidth;
                                    ctx.shadowBlur = 15 * opacity;
                                    ctx.shadowColor = getRGBA(color2, opacity * 0.8);
                                    ctx.stroke();

                                    ctx.restore();
                                }

                                vfx.xdrakeApexAura = vfx.xdrakeApexAura.filter(a=> (a.t+=dt) < a.life);

                                vfx.gojoPurpleCombineVFX = vfx.gojoPurpleCombineVFX.filter(v=> (v.t+=dt) < v.life);


                                for(const aura of vfx.eddieWeAreAura){
                                    const progress = aura.t / aura.life;
                                    const currentRadius = lerp(aura.radius * 0.5, aura.radius * 2, progress);
                                    const opacity = (1 - progress) * 0.7;

                                    const grd = ctx.createRadialGradient(aura.x, aura.y, aura.radius * 0.5, aura.x, aura.y, currentRadius);
                                    grd.addColorStop(0, getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--eddie-we-are-aura').trim(), opacity * 0.8));
                                    grd.addColorStop(1, `rgba(0,0,0,0)`);
                                    ctx.fillStyle = grd;
                                    ctx.beginPath();
                                    ctx.arc(aura.x, aura.y, currentRadius, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // Zeus Heavenly Shield Aura
                                vfx.zeusHeavenlyShieldAura = vfx.zeusHeavenlyShieldAura.filter(a => (a.t+=dt) < a.life);

                                // Zeus Olympus Fury Aura
                                vfx.zeusOlympusFuryAura = vfx.zeusOlympusFuryAura.filter(a => (a.t+=dt) < a.life);

                                for(const line of vfx.eddieVenomTendrils){
                                    const progress = line.t / line.life;
                                    if (progress > 1) continue;

                                    const startX = line.startX;
                                    const startY = line.startY;
                                    const endX = line.endX; // Use updated endX, endY
                                    const endY = line.endY; // Use updated endX, endY

                                    const dist = Math.hypot(endX - startX, endY - startY);
                                    const angle = Math.atan2(endY - startY, endX - startX);

                                    ctx.save();
                                    ctx.translate(startX, startY);
                                    ctx.rotate(angle);

                                    const segments = Math.floor(dist / 10) || 1; // Ensure at least one segment
                                    ctx.beginPath();
                                    ctx.moveTo(0, 0);

                                    for (let i = 0; i <= segments; i++) {
                                        const segmentProgress = i / segments;
                                        const x = segmentProgress * dist;
                                        const wiggleOffset = Math.sin(segmentProgress * Math.PI * line.wiggleFreq + performance.now() * 0.02) * line.wiggleAmp * (1 - progress);
                                        ctx.lineTo(x, wiggleOffset);
                                    }

                                    ctx.strokeStyle = getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-tendril-start').trim(), 0.9 * (1 - progress));
                                    ctx.lineWidth = 6 * (1 - progress); // Thicker line
                                    ctx.shadowBlur = 20 * (1 - progress); // More glow
                                    ctx.shadowColor = getRGBA(getComputedStyle(document.documentElement).getPropertyValue('--eddie-venom-strike-glow').trim(), 0.8 * (1 - progress)); // Brighter glow color
                                    ctx.stroke();

                                    ctx.restore();
                                }
                                for(const puddle of vfx.blackPuddles){
                                    const f = 1 - puddle.t/puddle.life;
                                    const a = f * 0.6; // Fade out opacity
                                    const r = puddle.r * (1 + (puddle.t / puddle.life) * 0.5); // Grow slightly

                                    ctx.fillStyle = `${puddle.color}${a})`;
                                    ctx.beginPath();
                                    ctx.arc(puddle.x, puddle.y, r, 0, Math.PI * 2);
                                    ctx.fill();
                                }


                                // Draw Robsan Ground Rupture
                                for(const rupture of vfx.robsanGroundRupture){
                                    const progress = rupture.t / rupture.life;
                                    const opacity = (1 - progress) * 0.8;
                                    const length = rupture.length * (1 + progress);
                                    const width = rupture.width * (1 - progress * 0.5);

                                    ctx.save();
                                    ctx.translate(rupture.x, rupture.y);
                                    ctx.rotate(rupture.dir);
                                    ctx.strokeStyle = `${rupture.color}${opacity})`;
                                    ctx.lineWidth = width;
                                    ctx.lineCap = 'round';
                                    ctx.beginPath();
                                    ctx.moveTo(-length / 2, 0);
                                    ctx.lineTo(length / 2, 0);
                                    ctx.stroke();
                                    ctx.restore();
                                }

                                // Draw Robsan Eclipse Wisps
                                for(const wisp of vfx.robsanEclipseWisps){
                                    const f = 1 - wisp.t/wisp.life; const a = f*0.6;
                                    ctx.fillStyle = `${wisp.color}${a})`;
                                    ctx.beginPath(); ctx.arc(wisp.x, wisp.y, wisp.r, 0, Math.PI*2); ctx.fill();
                                }

                                // Draw Robsan Void Puffs
                                for(const puff of vfx.robsanVoidPuffs){
                                    const progress = puff.t / puff.life;
                                    const opacity = (1 - progress) * 0.7;
                                    const radius = puff.r * (1 + progress);

                                    ctx.fillStyle = `${puff.color}${opacity})`;
                                    ctx.beginPath();
                                    ctx.arc(puff.x, puff.y, radius, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // Draw XDrake Supernova Ground Crack
                                for(const crack of vfx.xdrakeSupernovaGroundCrack){
                                    const progress = crack.t / crack.life;
                                    const opacity = (1 - progress) * 0.5;
                                    const size = crack.size * (1 + progress * 0.5);

                                    ctx.fillStyle = `${crack.color}${opacity})`;
                                    ctx.beginPath();
                                    ctx.arc(crack.x, crack.y, size, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // Draw XDrake Footwork Leaves
                                for(const leaf of vfx.xdrakeFootworkLeaves){
                                    const f = 1 - leaf.t/leaf.life; const a = f*0.8;
                                    ctx.fillStyle = `${leaf.color}${a})`;
                                    ctx.beginPath(); ctx.ellipse(leaf.x, leaf.y, leaf.r * 1.5, leaf.r * 0.8, leaf.vx > 0 ? 0.3 : -0.3, 0, Math.PI*2); ctx.fill();
                                }

                                // Draw XDrake Ancient Apex Ground Burst
                                for(const burst of vfx.xdrakeAncientApexGroundBurst){
                                    const f = 1 - burst.t/burst.life; const a = f*0.7;
                                    ctx.fillStyle = `${burst.color}${a})`;
                                    ctx.beginPath(); ctx.arc(burst.x, burst.y, burst.r, 0, Math.PI*2); ctx.fill();
                                }

                                // Draw Gojo Red Explosion
                                for(const exp of vfx.gojoRedExplosion){
                                    const progress = exp.t / exp.life;
                                    const opacity = (1 - progress) * 0.8;
                                    const radius = exp.radius * (1 + progress);

                                    const grd = ctx.createRadialGradient(exp.x, exp.y, 0, exp.x, exp.y, radius);
                                    grd.addColorStop(0, `${exp.color}${opacity})`);
                                    grd.addColorStop(1, `${exp.color.split(',')[0]},${exp.color.split(',')[1]},${exp.color.split(',')[2]},0)`);
                                    ctx.fillStyle = grd;
                                    ctx.beginPath();
                                    ctx.arc(exp.x, exp.y, radius, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // Draw Gojo Lapse Blue Pull Effect
                                for(const p of vfx.gojoLapseBluePullEffect){
                                    const f = 1 - p.t/p.life; const a = f*0.7;
                                    ctx.fillStyle = `${p.color}${a})`;
                                    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
                                }

                                // Draw Gojo Purple Arcs
                                for(const arc of vfx.gojoPurpleArcs){
                                    const progress = arc.t / arc.life;
                                    const opacity = (1 - progress) * 0.9;
                                    const currentRadius = arc.radius * (1 + progress * 2);

                                    ctx.strokeStyle = `${arc.color}${opacity})`;
                                    ctx.lineWidth = 3 * (1 - progress * 0.5);
                                    ctx.beginPath();
                                    ctx.arc(arc.x, arc.y, currentRadius, arc.initialAngle, arc.initialAngle + Math.PI / 4 * (1 - progress));
                                    ctx.stroke();
                                }

                                // Draw Eddie We Are Ripples
                                for(const ripple of vfx.eddieWeAreRipples){
                                    const progress = ripple.t / ripple.life;
                                    const opacity = (1 - progress) * 0.5;
                                    const radius = lerp(ripple.initialRadius, ripple.maxRadius, progress);

                                    ctx.strokeStyle = `${ripple.color}${opacity})`;
                                    ctx.lineWidth = 2 * (1 - progress);
                                    ctx.beginPath();
                                    ctx.arc(ripple.x, ripple.y, radius, 0, Math.PI * 2);
                                    ctx.stroke();
                                }

                                // Draw Eddie Venom Ball Swirl
                                for(const p of vfx.eddieVenomBallSwirl){
                                    const f = 1 - p.t/p.life; const a = f*0.7;
                                    ctx.fillStyle = `${p.color}${a})`;
                                    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
                                }

                                // Draw Eddie Teleport Flicker
                                for(const flicker of vfx.eddieTeleportFlicker){
                                    const progress = flicker.t / flicker.life;
                                    const opacity = Math.sin(progress * Math.PI) * 0.8; // Pulsate opacity
                                    const radius = flicker.radius * (1 + progress * 0.2);

                                    const grd = ctx.createRadialGradient(flicker.x, flicker.y, 0, flicker.x, flicker.y, radius);
                                    grd.addColorStop(0, `${flicker.color}${opacity})`);
                                    grd.addColorStop(1, `${flicker.color.split(',')[0]},${flicker.color.split(',')[1]},${flicker.color.split(',')[2]},0)`);
                                    ctx.fillStyle = grd;
                                    ctx.beginPath();
                                    ctx.arc(flicker.x, flicker.y, radius, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // Draw Enhanced VFX

                                // Hudson Speed Lines
                                for(const line of vfx.hudsonSpeedLines) {
                                    const progress = line.t / line.life;
                                    const opacity = (1 - progress) * 0.7;
                                    const currentLength = line.length * (1 + progress);

                                    ctx.save();
                                    ctx.translate(line.x, line.y);
                                    ctx.rotate(line.dir);
                                    ctx.strokeStyle = `${line.color}${opacity})`;
                                    ctx.lineWidth = 3 * (1 - progress * 0.5);
                                    ctx.beginPath();
                                    ctx.moveTo(0, 0);
                                    ctx.lineTo(currentLength, 0);
                                    ctx.stroke();
                                    ctx.restore();
                                }

                                // Hudson Energy Waves
                                for(const wave of vfx.hudsonEnergyWaves) {
                                    const progress = wave.t / wave.life;
                                    const opacity = (1 - progress) * 0.5;
                                    const radius = lerp(wave.initialRadius, wave.maxRadius, progress);

                                    ctx.strokeStyle = `${wave.color}${opacity})`;
                                    ctx.lineWidth = 4 * (1 - progress);
                                    ctx.beginPath();
                                    ctx.arc(wave.x, wave.y, radius, 0, Math.PI * 2);
                                    ctx.stroke();
                                }

                                // Hudson Emperor Dribble Trail
                                for(const trail of vfx.hudsonEmperorDribbleTrail) {
                                    const progress = trail.t / trail.life;
                                    const opacity = (1 - progress) * 0.8;
                                    const size = trail.width * (1 - progress * 0.3);

                                    ctx.fillStyle = `${trail.color.replace(')', `, ${opacity})`)}`;
                                    ctx.beginPath();
                                    ctx.arc(trail.x, trail.y, size, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // Hudson Emperor Dribble Particles
                                for(const particle of vfx.hudsonEmperorDribbleParticles) {
                                    const progress = particle.t / particle.life;
                                    const opacity = (1 - progress) * 0.9;
                                    const size = particle.r * (1 + progress * 0.2);

                                    ctx.fillStyle = `${particle.color.replace('0.8', opacity.toString())}`;
                                    ctx.beginPath();
                                    ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // Hudson Emperor Dribble Aura
                                for(const aura of vfx.hudsonEmperorDribbleAura) {
                                    const progress = aura.t / aura.life;
                                    const opacity = (1 - progress) * 0.4;
                                    const radius = aura.radius * (1 + progress * 0.5);

                                    const grd = ctx.createRadialGradient(aura.x, aura.y, 0, aura.x, aura.y, radius);
                                    grd.addColorStop(0, `rgba(200, 50, 150, ${opacity})`);
                                    grd.addColorStop(1, `rgba(150, 100, 200, 0)`);
                                    ctx.fillStyle = grd;
                                    ctx.beginPath();
                                    ctx.arc(aura.x, aura.y, radius, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // Robsan Shadow Clones
                                for(const clone of vfx.robsanShadowClones) {
                                    const progress = clone.t / clone.life;
                                    const opacity = (1 - progress) * clone.opacity;

                                    ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
                                    ctx.beginPath();
                                    ctx.arc(clone.x, clone.y, clone.r, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // Robsan Void Rifts
                                for(const rift of vfx.robsanVoidRifts) {
                                    const progress = rift.t / rift.life;
                                    const opacity = (1 - progress) * 0.8;
                                    const width = lerp(rift.width, rift.maxWidth, progress);

                                    ctx.fillStyle = `${rift.color}${opacity})`;
                                    ctx.fillRect(rift.x - width/2, rift.y - rift.height/2, width, rift.height);
                                }

                                // XDrake Nature Spirits
                                for(const spirit of vfx.xdrakeNatureSpirits) {
                                    const f = 1 - spirit.t / spirit.life;
                                    const a = f * 0.8;
                                    ctx.fillStyle = `${spirit.color}${a})`;
                                    ctx.beginPath();
                                    ctx.arc(spirit.x, spirit.y, spirit.r, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // XDrake Terraforms
                                for(const terra of vfx.xdrakeTerraforms) {
                                    const progress = terra.t / terra.life;
                                    const opacity = (1 - progress) * 0.7;
                                    const height = terra.height * (1 + progress * 0.5);

                                    ctx.fillStyle = `${terra.color}${opacity})`;
                                    ctx.fillRect(terra.x - 5, terra.y - height, 10, height);
                                }

                                // Gojo Infinity Barriers
                                for(const barrier of vfx.gojoInfinityBarriers) {
                                    const progress = barrier.t / barrier.life;
                                    const opacity = (1 - progress) * 0.6;

                                    ctx.save();
                                    ctx.translate(barrier.x, barrier.y);
                                    ctx.rotate(barrier.angle + progress * Math.PI);
                                    ctx.strokeStyle = `${barrier.color}${opacity})`;
                                    ctx.lineWidth = 3;
                                    ctx.beginPath();
                                    ctx.moveTo(-barrier.length/2, 0);
                                    ctx.lineTo(barrier.length/2, 0);
                                    ctx.stroke();
                                    ctx.restore();
                                }

                                // Gojo Domain Expansions
                                for(const domain of vfx.gojoDomainExpansions) {
                                    const progress = domain.t / domain.life;
                                    const opacity = (1 - progress) * domain.intensity * 0.3;
                                    const radius = lerp(domain.initialRadius, domain.maxRadius, progress);

                                    const grd = ctx.createRadialGradient(domain.x, domain.y, 0, domain.x, domain.y, radius);
                                    grd.addColorStop(0, `${domain.color}${opacity})`);
                                    grd.addColorStop(1, `${domain.color.split(',')[0]},${domain.color.split(',')[1]},${domain.color.split(',')[2]},0)`);
                                    ctx.fillStyle = grd;
                                    ctx.beginPath();
                                    ctx.arc(domain.x, domain.y, radius, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // Eddie Symbiote Spikes
                                for(const spike of vfx.eddieSymbioteSpikes) {
                                    const progress = spike.t / spike.life;
                                    const opacity = (1 - progress) * 0.8;
                                    const length = spike.length * (1 + progress);

                                    ctx.save();
                                    ctx.translate(spike.x, spike.y);
                                    ctx.rotate(spike.dir);
                                    ctx.strokeStyle = `${spike.color}${opacity})`;
                                    ctx.lineWidth = 4 * (1 - progress * 0.5);
                                    ctx.beginPath();
                                    ctx.moveTo(0, 0);
                                    ctx.lineTo(length, 0);
                                    ctx.stroke();
                                    ctx.restore();
                                }

                                // Eddie Venom Drops
                                for(const drop of vfx.eddieVenomDrops) {
                                    const f = 1 - drop.t / drop.life;
                                    const a = f * 0.8;
                                    ctx.fillStyle = `${drop.color}${a})`;
                                    ctx.beginPath();
                                    ctx.arc(drop.x, drop.y, drop.r, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // Zeus Thunder Clouds
                                for(const cloud of vfx.zeusThunderClouds) {
                                    const progress = cloud.t / cloud.life;
                                    const opacity = (1 - progress) * cloud.opacity;

                                    ctx.fillStyle = `${cloud.color}${opacity})`;
                                    ctx.beginPath();
                                    ctx.arc(cloud.x, cloud.y, cloud.r, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // Zeus Lightning Bolts
                                for(const bolt of vfx.zeusLightningBolts) {
                                    const progress = bolt.t / bolt.life;
                                    const opacity = (1 - progress) * 0.9;

                                    ctx.strokeStyle = `${bolt.color}${opacity})`;
                                    ctx.lineWidth = bolt.thickness * (1 - progress * 0.5);
                                    ctx.shadowBlur = 10;
                                    ctx.shadowColor = `rgba(255, 255, 255, ${opacity})`;

                                    for(const segment of bolt.segments) {
                                        ctx.beginPath();
                                        ctx.moveTo(segment.x, segment.y);
                                        ctx.lineTo(segment.x2, segment.y2);
                                        ctx.stroke();
                                    }
                                    ctx.shadowBlur = 0;
                                }

                                // Energy Residue
                                for(const residue of vfx.energyResidue) {
                                    const f = 1 - residue.t / residue.life;
                                    const a = f * 0.6;
                                    ctx.fillStyle = `${residue.color}${a})`;
                                    ctx.beginPath();
                                    ctx.arc(residue.x, residue.y, residue.r * f, 0, Math.PI * 2);
                                    ctx.fill();
                                }


                                vfx.shockwaves = vfx.shockwaves.filter(s=> (s.t+=dt) < s.life);
                                for(const s of vfx.shockwaves){
                                    const t = s.t/s.life; const r = s.r + t*80;
                                    const a = (1-t)*0.8;

                                    const sColor1 = getRGBA(s.color1, a);
                                    const sColor2 = getRGBA(s.color2, a * 0.8);

                                    ctx.strokeStyle=sColor1;
                                    ctx.lineWidth=3; ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2); ctx.stroke();
                                    ctx.strokeStyle=sColor2;
                                    ctx.lineWidth=1.5; ctx.beginPath(); ctx.arc(s.x,s.y,r*1.12,0,Math.PI*2); ctx.stroke();
                                }
                                for(const l of vfx.lines){
                                    const t=l.t/l.life; const a=(1-t)*0.6;
                                    const x2 = l.x + Math.cos(l.a)*l.len;
                                    const y2 = l.y + Math.sin(l.a)*l.len;
                                    ctx.strokeStyle=`rgba(255,255,255,${a})`; ctx.lineWidth=2;
                                    ctx.beginPath(); ctx.moveTo(l.x,l.y); ctx.lineTo(x2,y2); ctx.stroke();
                                }

                                for(const a of vfx.robsanAura){
                                    const progress = a.t / a.life;
                                    const currentRadius = lerp(a.radius * 0.5, a.radius * 2, progress);
                                    const opacity = (1 - progress) * 0.7;

                                    const grd = ctx.createRadialGradient(a.x, a.y, a.radius * 0.5, a.x, a.y, currentRadius);
                                    grd.addColorStop(0, `rgba(49, 46, 129, ${opacity * 0.8})`);
                                    grd.addColorStop(0.7, `rgba(76, 29, 149, ${opacity * 0.4})`);
                                    grd.addColorStop(1, `rgba(0,0,0,0)`);
                                    ctx.fillStyle = grd;
                                    ctx.beginPath();
                                    ctx.arc(a.x, a.y, currentRadius, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // Draw Robsan Void Dash Trail
                                if (vfx.voidTrails.length && player._voidDashTrail && player._voidDashTrail.length > 1) {
                                    for(let i=0;i<player._voidDashTrail.length-1;i++){
                                        const p=player._voidDashTrail[i], n=player._voidDashTrail[i+1];
                                        const age = (performance.now()-p.time);
                                        const a = clamp(1-age/(VOID_DASH_DURATION + 100), 0, 1)*0.9;
                                        const w = lerp(vfx.voidTrails[0].w,2,i/player._voidDashTrail.length);
                                        const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                                        g.addColorStop(0,getRGBA(vfx.voidTrails[0].trailColorStart,a));
                                        g.addColorStop(1,getRGBA(vfx.voidTrails[0].trailColorEnd,a*0.6));
                                        ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                                        ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                                    }
                                }

                                // Draw XDrake Supernova Trail
                                if (vfx.xdrakeSupernovaTrails.length && player._xdrakeSupernovaTrail && player._xdrakeSupernovaTrail.length > 1) {
                                    for(let i=0;i<player._xdrakeSupernovaTrail.length-1;i++){
                                        const p=player._xdrakeSupernovaTrail[i], n=player._xdrakeSupernovaTrail[i+1];
                                        const age = (performance.now()-p.time);
                                        const a = clamp(1-age/(XDRAKE_SUPERNOVA_DASH_DURATION + 100), 0, 1)*0.9;
                                        const w = lerp(vfx.xdrakeSupernovaTrails[0].w,2,i/player._xdrakeSupernovaTrail.length);
                                        const g=ctx.createLinearGradient(p.x,p.y,n.x,n.y);
                                        g.addColorStop(0,getRGBA(vfx.xdrakeSupernovaTrails[0].trailColorStart,a));
                                        g.addColorStop(1,getRGBA(vfx.xdrakeSupernovaTrails[0].trailColorEnd,a*0.6));
                                        ctx.strokeStyle=g; ctx.lineWidth=w; ctx.lineCap='round';
                                        ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(n.x,n.y); ctx.stroke();
                                    }
                                }


                                // This block was previously removed as requested. It remains removed.
                                // if(vfx.flashes.length){
                                //     const f = vfx.flashes[0];
                                //     const a = (1 - f.t/f.life) * 0.4;
                                //     ctx.fillStyle=`rgba(255,255,255,${a})`;
                                //     ctx.fillRect(0,0,W,H);
                                // }

                    // Asher Star Trail
                                if (vfx.asherStarTrail.length && ball._asherStarTrail && ball._asherStarTrail.length > 1) {
                                    for (let i = 0; i < ball._asherStarTrail.length - 1; i++) {
                                        const p = ball._asherStarTrail[i], n = ball._asherStarTrail[i+1];
                                        const age = (performance.now() - p.time);
                                        const a = clamp(1 - age / ASHER_HOMING_SHOT_DURATION, 0, 1) * 0.9;
                                        const w = lerp(vfx.asherStarTrail[0].w, 2, i / ball._asherStarTrail.length);
                                        const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                                        g.addColorStop(0, getRGBA(vfx.asherStarTrail[0].colorStart, a));
                                        g.addColorStop(1, getRGBA(vfx.asherStarTrail[0].colorEnd, a * 0.7));
                                        ctx.strokeStyle = g;
                                        ctx.lineWidth = w;
                                        ctx.lineCap = 'round';
                                        ctx.beginPath();
                                        ctx.moveTo(p.x, p.y);
                                        ctx.lineTo(n.x, n.y);
                                        ctx.stroke();
                                        // Add sparkling star particles along the trail
                                        if (Math.random() < 0.3) {
                                            vfx.sparks.push({
                                                x: p.x, y: p.y,
                                                vx: (Math.random() - 0.5) * 2,
                                                vy: (Math.random() - 0.5) * 2,
                                                life: 200 + Math.random() * 200,
                                                t: 0, r: 1 + Math.random() * 2,
                                                color: 'rgba(233, 213, 255,'
                                            });
                                        }
                                    }
                                }

                                // NEW DIDDY OIL TRAIL RENDERING
                                if (ball._diddyOilTrail && ball._diddyOilTrail.length > 1) {
                                    for (let i = 0; i < ball._diddyOilTrail.length - 1; i++) {
                                        const p = ball._diddyOilTrail[i], n = ball._diddyOilTrail[i+1];
                                        const age = (performance.now() - p.time);
                                        const a = clamp(1 - age / 3000, 0, 1) * 0.8; // 3 second fade
                                        const w = lerp(12, 2, i / ball._diddyOilTrail.length); // Smaller trail width

                                        if (oilImageLoaded) {
                                            // Use oil.png images along the trail path
                                            const segments = Math.max(1, Math.floor(w / 6)); // More images for thicker trails
                                            for(let s = 0; s < segments; s++) {
                                                const t = s / Math.max(1, segments - 1);
                                                const x = lerp(p.x, n.x, t);
                                                const y = lerp(p.y, n.y, t);
                                                const scale = (w / 40) * (0.6 + Math.random() * 0.3); // Smaller oil images

                                                ctx.save();
                                                ctx.globalAlpha = a * (0.7 + Math.random() * 0.3);
                                                ctx.translate(x, y);
                                                ctx.rotate(Math.random() * Math.PI * 2);
                                                ctx.scale(scale, scale);
                                                ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                                                ctx.restore();
                                            }
                                        } else {
                                            // Fallback oil trail gradient
                                            const g = ctx.createLinearGradient(p.x, p.y, n.x, n.y);
                                            g.addColorStop(0, `rgba(184, 134, 11, ${a})`); // Golden oil
                                            g.addColorStop(0.5, `rgba(139, 69, 19, ${a * 0.8})`); // Brown oil
                                            g.addColorStop(1, `rgba(101, 67, 33, ${a * 0.5})`); // Dark brown

                                            ctx.strokeStyle = g;
                                            ctx.lineWidth = w;
                                            ctx.lineCap = 'round';
                                            ctx.beginPath();
                                            ctx.moveTo(p.x, p.y);
                                            ctx.lineTo(n.x, n.y);
                                            ctx.stroke();

                                            // Add oil glisten effect
                                            if (Math.random() < 0.2) {
                                                ctx.fillStyle = `rgba(255, 215, 0, ${a * 0.6})`;
                                                ctx.beginPath();
                                                ctx.arc(p.x + (Math.random() - 0.5) * w, p.y + (Math.random() - 0.5) * w, 1 + Math.random(), 0, Math.PI * 2);
                                                ctx.fill();
                                            }
                                        }
                                    }
                                }

                                // Asher Teleport Burst (Departure)
                                for(const p of vfx.asherTeleportBurst){
                                    const f = 1 - p.t/p.life;
                                    const a = f * 0.9;
                                    const r = p.r * (1 + (1-f)*2); // Particles expand
                                    const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r);
                                    g.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                                    g.addColorStop(0.5, `${p.color}${a})`);
                                    g.addColorStop(1, `${p.color.split(',')[0]},${p.color.split(',')[1]},${p.color.split(',')[2]},0)`);
                                    ctx.fillStyle = g;
                                    ctx.beginPath();
                                    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                                    ctx.fill();
                                }


                                // NEW LEONARDO VFX
                                // Focus Shot Text
                                // Asher Arrival Glimmer
                                for(const p of vfx.asherArrivalGlimmer){
                                    const f = 1 - p.t/p.life;
                                    const a = Math.sin(f * Math.PI) * 0.8; // Pulsing opacity
                                    const r = p.r * (1 + Math.sin(f * Math.PI) * 0.5); // Pulsing size
                                    ctx.fillStyle = `${p.color}${a})`;
                                    ctx.beginPath();
                                    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // NEW DIDDY VFX
                                // Baby Oil Guy Oil Particles
                                for(const p of vfx.diddyOilParticles){
                                    p.t += dt;
                                    p.x += p.vx;
                                    p.y += p.vy;
                                    p.vx *= 0.98; // Slight friction
                                    p.vy *= 0.98;

                                    const f = 1 - p.t / p.life;
                                    const a = f * p.opacity;
                                    const r = p.r * (1 + (1-f) * 0.3); // Slight expansion

                                    if (oilImageLoaded) {
                                        // Use oil.png image with transparency and rotation
                                        ctx.save();
                                        ctx.globalAlpha = a;
                                        ctx.translate(p.x, p.y);
                                        ctx.rotate(p.t * 0.01); // Slow rotation for realism
                                        ctx.scale(r / 20, r / 20); // Scale based on particle size
                                        ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                                        ctx.restore();
                                    } else {
                                        // Fallback gradient effect
                                        const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r);
                                        g.addColorStop(0, `rgba(255, 215, 0, ${a})`); // Golden center
                                        g.addColorStop(0.6, `rgba(184, 134, 11, ${a * 0.8})`); // Darker gold
                                        g.addColorStop(1, `rgba(120, 53, 15, ${a * 0.3})`); // Brown edge

                                        ctx.fillStyle = g;
                                        ctx.beginPath();
                                        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                }
                                vfx.diddyOilParticles = vfx.diddyOilParticles.filter(p => p.t < p.life);

                                // Baby Oil Guy Ascension VFX
                                for(const p of vfx.diddyAscensionVFX){
                                    p.t += dt;
                                    p.y -= p.speed; // Rising effect

                                    const f = 1 - p.t / p.life;
                                    const a = Math.sin(f * Math.PI) * 0.9; // Pulsing
                                    const r = p.r * (1 + Math.sin(p.t * 0.01) * 0.2); // Gentle size pulse

                                    if (oilImageLoaded) {
                                        // Use oil.png with golden glow for ascension
                                        ctx.save();

                                        // Add golden glow behind the oil
                                        const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 3);
                                        g.addColorStop(0, `rgba(255, 223, 0, ${a * 0.6})`);
                                        g.addColorStop(0.4, `rgba(255, 193, 7, ${a * 0.4})`);
                                        g.addColorStop(1, `rgba(255, 193, 7, 0)`);
                                        ctx.fillStyle = g;
                                        ctx.beginPath();
                                        ctx.arc(p.x, p.y, r * 2, 0, Math.PI * 2);
                                        ctx.fill();

                                        // Draw ascending oil image with golden tint
                                        ctx.globalAlpha = a * 0.9;
                                        ctx.globalCompositeOperation = 'screen'; // Makes it glow
                                        ctx.translate(p.x, p.y);
                                        ctx.rotate(p.t * 0.02); // Mystical rotation
                                        ctx.scale(r / 20, r / 20);
                                        ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                                        ctx.restore();
                                    } else {
                                        // Fallback glowing golden ascension effect
                                        const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 2);
                                        g.addColorStop(0, `rgba(255, 223, 0, ${a})`);
                                        g.addColorStop(0.4, `rgba(255, 193, 7, ${a * 0.7})`);
                                        g.addColorStop(1, `rgba(255, 193, 7, 0)`);

                                        ctx.fillStyle = g;
                                        ctx.beginPath();
                                        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                                        ctx.fill();
                                    }

                                    // Add sparkle effect for both modes
                                    if (Math.random() < 0.4) {
                                        ctx.fillStyle = `rgba(255, 255, 255, ${a * 0.8})`;
                                        ctx.beginPath();
                                        ctx.arc(p.x + (Math.random() - 0.5) * r, p.y + (Math.random() - 0.5) * r, 1, 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                }
                                vfx.diddyAscensionVFX = vfx.diddyAscensionVFX.filter(p => p.t < p.life);

                                // Baby Oil Guy Oil Slicks
                                for(const slick of vfx.diddyOilSlicks){
                                    slick.t += dt;

                                    const f = 1 - slick.t / slick.life;
                                    const a = f * slick.opacity;
                                    const r = slick.radius * (0.8 + f * 0.2); // Slight shrinking over time

                                    if (oilImageLoaded) {
                                        // Create realistic oil puddle using multiple oil images
                                        const oilPatches = 8; // Number of oil patches to create the puddle
                                        for(let i = 0; i < oilPatches; i++){
                                            const angle = (Math.PI * 2 * i) / oilPatches;
                                            const distance = r * (0.3 + Math.random() * 0.4);
                                            const x = slick.x + Math.cos(angle) * distance;
                                            const y = slick.y + Math.sin(angle) * distance;
                                            const scale = (0.8 + Math.random() * 0.4) * (r / 60);

                                            ctx.save();
                                            ctx.globalAlpha = a * (0.6 + Math.random() * 0.4);
                                            ctx.translate(x, y);
                                            ctx.rotate(angle + slick.t * 0.001);
                                            ctx.scale(scale, scale);
                                            ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                                            ctx.restore();
                                        }

                                        // Central oil patch
                                        ctx.save();
                                        ctx.globalAlpha = a * 0.8;
                                        ctx.translate(slick.x, slick.y);
                                        ctx.rotate(slick.t * 0.002);
                                        ctx.scale(r / 40, r / 40);
                                        ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                                        ctx.restore();
                                    } else {
                                        // Fallback animated oil slick with ripple effect
                                        const ripples = 3;
                                        for(let i = 0; i < ripples; i++){
                                            const rippleF = (slick.t * 0.003 + i * 0.33) % 1;
                                            const rippleR = r * (0.3 + rippleF * 0.7);
                                            const rippleA = a * (1 - rippleF) * 0.5;

                                            const g = ctx.createRadialGradient(slick.x, slick.y, 0, slick.x, slick.y, rippleR);
                                            g.addColorStop(0, `rgba(139, 69, 19, ${rippleA})`); // Brown center
                                            g.addColorStop(0.6, `rgba(160, 82, 45, ${rippleA * 0.7})`); // Saddle brown
                                            g.addColorStop(1, `rgba(160, 82, 45, 0)`); // Transparent edge

                                            ctx.fillStyle = g;
                                            ctx.beginPath();
                                            ctx.arc(slick.x, slick.y, rippleR, 0, Math.PI * 2);
                                            ctx.fill();
                                        }
                                    }
                                }
                                vfx.diddyOilSlicks = vfx.diddyOilSlicks.filter(slick => slick.t < slick.life);

                                // Baby Oil Guy Slick Trail
                                for(const trail of vfx.diddySlickTrail){
                                    trail.t += dt;
                                    trail.x += trail.vx;
                                    trail.y += trail.vy;
                                    trail.vy += 0.1; // Gravity effect

                                    const f = 1 - trail.t / trail.life;
                                    const a = f * 0.8;
                                    const r = trail.r * (1 + (1-f) * 0.5);

                                    if (oilImageLoaded) {
                                        // Use oil.png for realistic droplets
                                        ctx.save();
                                        ctx.globalAlpha = a;
                                        ctx.translate(trail.x, trail.y);
                                        ctx.rotate(trail.t * 0.005); // Gentle rotation
                                        ctx.scale(r / 35, r / 35); // Even smaller scale for droplets
                                        ctx.drawImage(oilImage, -oilImage.width/2, -oilImage.height/2);
                                        ctx.restore();
                                    } else {
                                        // Fallback gradient droplet effect
                                        const g = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, r);
                                        g.addColorStop(0, `rgba(184, 134, 11, ${a})`);
                                        g.addColorStop(0.7, `rgba(139, 69, 19, ${a * 0.6})`);
                                        g.addColorStop(1, `rgba(101, 67, 33, ${a * 0.2})`);

                                        ctx.fillStyle = g;
                                        ctx.beginPath();
                                        ctx.arc(trail.x, trail.y, r, 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                }
                                vfx.diddySlickTrail = vfx.diddySlickTrail.filter(trail => trail.t < trail.life);

                                // ========== EPIC NEW VFX SYSTEMS ==========
                                
                                // EPIC EXPLOSIONS - Massive screen-shaking detonations
                                for(const explosion of vfx.epicExplosions){
                                    explosion.t += dt;
                                    const progress = explosion.t / explosion.life;
                                    const easeOut = 1 - Math.pow(1 - progress, 3);
                                    const radius = explosion.startRadius + (explosion.endRadius - explosion.startRadius) * easeOut;
                                    const opacity = Math.sin(progress * Math.PI) * explosion.maxOpacity;
                                    
                                    ctx.save();
                                    
                                    // Outer shockwave ring
                                    const shockwaveGrad = ctx.createRadialGradient(explosion.x, explosion.y, radius * 0.8, explosion.x, explosion.y, radius * 1.5);
                                    shockwaveGrad.addColorStop(0, `rgba(255, 255, 255, ${opacity * 0.9})`);
                                    shockwaveGrad.addColorStop(0.3, `rgba(255, 100, 50, ${opacity * 0.7})`);
                                    shockwaveGrad.addColorStop(0.7, `rgba(255, 200, 0, ${opacity * 0.5})`);
                                    shockwaveGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                                    ctx.fillStyle = shockwaveGrad;
                                    ctx.beginPath();
                                    ctx.arc(explosion.x, explosion.y, radius * 1.2, 0, Math.PI * 2);
                                    ctx.fill();
                                    
                                    // Core explosion
                                    const coreGrad = ctx.createRadialGradient(explosion.x, explosion.y, 0, explosion.x, explosion.y, radius * 0.6);
                                    coreGrad.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                                    coreGrad.addColorStop(0.2, `rgba(255, 150, 100, ${opacity * 0.9})`);
                                    coreGrad.addColorStop(0.5, `rgba(255, 80, 80, ${opacity * 0.7})`);
                                    coreGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                                    ctx.fillStyle = coreGrad;
                                    ctx.beginPath();
                                    ctx.arc(explosion.x, explosion.y, radius * 0.5, 0, Math.PI * 2);
                                    ctx.fill();
                                    
                                    // Energy spikes radiating outward
                                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
                                    ctx.lineWidth = 4;
                                    for(let i = 0; i < 24; i++){
                                        const angle = (i / 24) * Math.PI * 2;
                                        const spikeLength = radius * (0.8 + Math.sin(performance.now() * 0.02 + i) * 0.3);
                                        ctx.beginPath();
                                        ctx.moveTo(explosion.x + Math.cos(angle) * radius * 0.2, explosion.y + Math.sin(angle) * radius * 0.2);
                                        ctx.lineTo(explosion.x + Math.cos(angle) * spikeLength, explosion.y + Math.sin(angle) * spikeLength);
                                        ctx.stroke();
                                    }
                                    
                                    ctx.restore();
                                }
                                vfx.epicExplosions = vfx.epicExplosions.filter(e => e.t < e.life);
                                
                                // MASSIVE SHOCKWAVES - Ground-breaking waves that distort everything
                                for(const wave of vfx.massiveShockwaves){
                                    wave.t += dt;
                                    const progress = wave.t / wave.life;
                                    const radius = wave.startRadius + (wave.endRadius - wave.startRadius) * progress;
                                    const opacity = Math.sin(progress * Math.PI) * wave.maxOpacity;
                                    
                                    ctx.save();
                                    
                                    // Primary wave
                                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.9})`;
                                    ctx.lineWidth = 8;
                                    ctx.shadowBlur = 20;
                                    ctx.shadowColor = `rgba(255, 255, 255, ${opacity})`;
                                    ctx.beginPath();
                                    ctx.arc(wave.x, wave.y, radius, 0, Math.PI * 2);
                                    ctx.stroke();
                                    
                                    // Secondary wave
                                    ctx.strokeStyle = `rgba(100, 200, 255, ${opacity * 0.6})`;
                                    ctx.lineWidth = 4;
                                    ctx.beginPath();
                                    ctx.arc(wave.x, wave.y, radius * 1.1, 0, Math.PI * 2);
                                    ctx.stroke();
                                    
                                    // Tertiary wave
                                    ctx.strokeStyle = `rgba(255, 100, 255, ${opacity * 0.4})`;
                                    ctx.lineWidth = 2;
                                    ctx.beginPath();
                                    ctx.arc(wave.x, wave.y, radius * 1.2, 0, Math.PI * 2);
                                    ctx.stroke();
                                    
                                    ctx.restore();
                                }
                                vfx.massiveShockwaves = vfx.massiveShockwaves.filter(w => w.t < w.life);
                                
                                // ENERGY NOVAS - Brilliant stellar explosions
                                for(const nova of vfx.energyNovas){
                                    nova.t += dt;
                                    const progress = nova.t / nova.life;
                                    const easeOut = 1 - Math.pow(1 - progress, 2);
                                    const radius = nova.startRadius + (nova.endRadius - nova.startRadius) * easeOut;
                                    const opacity = Math.sin(progress * Math.PI) * nova.maxOpacity;
                                    
                                    ctx.save();
                                    
                                    // Nova core with pulsing brightness
                                    const pulse = Math.sin(performance.now() * 0.02) * 0.3 + 0.7;
                                    const novaGrad = ctx.createRadialGradient(nova.x, nova.y, 0, nova.x, nova.y, radius);
                                    novaGrad.addColorStop(0, `rgba(255, 255, 255, ${opacity * pulse})`);
                                    novaGrad.addColorStop(0.1, `rgba(255, 200, 150, ${opacity * 0.8})`);
                                    novaGrad.addColorStop(0.3, `rgba(150, 100, 255, ${opacity * 0.6})`);
                                    novaGrad.addColorStop(0.6, `rgba(100, 150, 255, ${opacity * 0.4})`);
                                    novaGrad.addColorStop(1, 'rgba(50, 50, 255, 0)');
                                    ctx.fillStyle = novaGrad;
                                    ctx.beginPath();
                                    ctx.arc(nova.x, nova.y, radius, 0, Math.PI * 2);
                                    ctx.fill();
                                    
                                    // Stellar rays
                                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.7})`;
                                    ctx.lineWidth = 3;
                                    for(let i = 0; i < 16; i++){
                                        const angle = (i / 16) * Math.PI * 2 + performance.now() * 0.001;
                                        const rayLength = radius * (1.2 + Math.sin(performance.now() * 0.01 + i) * 0.4);
                                        ctx.beginPath();
                                        ctx.moveTo(nova.x, nova.y);
                                        ctx.lineTo(nova.x + Math.cos(angle) * rayLength, nova.y + Math.sin(angle) * rayLength);
                                        ctx.stroke();
                                    }
                                    
                                    ctx.restore();
                                }
                                vfx.energyNovas = vfx.energyNovas.filter(n => n.t < n.life);
                                
                                // PARTICLE STORMS - Dense clouds of energy particles
                                for(const storm of vfx.particleStorms){
                                    storm.t += dt;
                                    const progress = storm.t / storm.life;
                                    const opacity = Math.sin(progress * Math.PI) * storm.intensity;
                                    
                                    for(let i = 0; i < storm.particles.length; i++){
                                        const p = storm.particles[i];
                                        p.x += p.vx;
                                        p.y += p.vy;
                                        p.vx *= 0.99;
                                        p.vy *= 0.99;
                                        
                                        const particleGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 3);
                                        particleGrad.addColorStop(0, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${opacity})`);
                                        particleGrad.addColorStop(1, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, 0)`);
                                        ctx.fillStyle = particleGrad;
                                        ctx.beginPath();
                                        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                }
                                vfx.particleStorms = vfx.particleStorms.filter(s => s.t < s.life);

                                // CRISTIANO VFX RENDERING - ENHANCED POWER SHOT
                                // Devastating Power Shot Trail - Multiple layers with enhanced effects
                                for(const trail of vfx.cristianoPowerShotTrail){
                                    trail.t += dt;
                                    const f = 1 - trail.t / trail.life;
                                    const intensity = trail.intensity || 1;
                                    const a = f * 0.95 * intensity;
                                    
                                    ctx.save();
                                    
                                    // Outer glow layer - Golden energy
                                    ctx.shadowBlur = 25;
                                    ctx.shadowColor = `rgba(255, 215, 0, ${a * 0.8})`;
                                    const outerGlow = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
                                    outerGlow.addColorStop(0, `rgba(255, 50, 50, ${a})`); // Intense red
                                    outerGlow.addColorStop(0.3, `rgba(255, 215, 0, ${a * 0.9})`); // Gold
                                    outerGlow.addColorStop(0.7, `rgba(255, 255, 255, ${a * 0.8})`); // Bright white
                                    outerGlow.addColorStop(1, `rgba(22, 163, 74, ${a * 0.6})`); // Portuguese green
                                    
                                    ctx.strokeStyle = outerGlow;
                                    ctx.lineWidth = 18 * intensity;
                                    ctx.lineCap = 'round';
                                    ctx.beginPath();
                                    ctx.moveTo(trail.startX, trail.startY);
                                    ctx.lineTo(trail.endX, trail.endY);
                                    ctx.stroke();
                                    
                                    // Inner core - Pure power
                                    ctx.shadowBlur = 8;
                                    ctx.shadowColor = `rgba(255, 255, 255, ${a})`;
                                    const innerCore = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
                                    innerCore.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                                    innerCore.addColorStop(0.5, `rgba(255, 215, 0, ${a * 0.9})`);
                                    innerCore.addColorStop(1, `rgba(255, 255, 255, ${a * 0.7})`);
                                    
                                    ctx.strokeStyle = innerCore;
                                    ctx.lineWidth = 8 * intensity;
                                    ctx.beginPath();
                                    ctx.moveTo(trail.startX, trail.startY);
                                    ctx.lineTo(trail.endX, trail.endY);
                                    ctx.stroke();
                                    
                                    ctx.restore();
                                }
                                vfx.cristianoPowerShotTrail = vfx.cristianoPowerShotTrail.filter(trail => trail.t < trail.life);

                                // GOAT Tackle Particles - Enhanced golden explosion effects
                                for(const p of vfx.cristianoGoatTackleParticles){
                                    p.t += dt;
                                    const f = 1 - p.t / p.life;
                                    const a = f * 0.9;
                                    p.x += p.vx * (dt/16); 
                                    p.y += p.vy * (dt/16);
                                    p.vx *= 0.96; 
                                    p.vy *= 0.96;

                                    ctx.save();
                                    
                                    if (p.isExplosion) {
                                        // Explosion particles - bright golden bursts
                                        ctx.shadowBlur = 15;
                                        ctx.shadowColor = `rgba(255, 215, 0, ${a})`;
                                        const size = Math.max(0.1, p.size * f);
                                        const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, Math.max(0.1, size * 1.5));
                                        g.addColorStop(0, `rgba(255, 255, 255, ${a})`); // Bright white center
                                        g.addColorStop(0.3, `rgba(255, 215, 0, ${a * 0.9})`); // Gold
                                        g.addColorStop(0.7, `rgba(255, 140, 0, ${a * 0.7})`); // Orange
                                        g.addColorStop(1, `rgba(220, 38, 38, ${a * 0.4})`); // Red edge
                                        ctx.fillStyle = g;
                                        ctx.beginPath();
                                        ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                                        ctx.fill();
                                    } else if (p.isPowerShotExplosion) {
                                        // Power shot explosion particles
                                        ctx.shadowBlur = 12;
                                        ctx.shadowColor = `rgba(255, 50, 50, ${a})`;
                                        const size = Math.max(0.1, p.size * f);
                                        const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, Math.max(0.1, size));
                                        g.addColorStop(0, `rgba(255, 255, 255, ${a})`); // White hot center
                                        g.addColorStop(0.4, `rgba(255, 50, 50, ${a * 0.8})`); // Intense red
                                        g.addColorStop(0.8, `rgba(255, 215, 0, ${a * 0.6})`); // Gold
                                        g.addColorStop(1, `rgba(255, 100, 0, ${a * 0.3})`); // Orange fade
                                        ctx.fillStyle = g;
                                        ctx.beginPath();
                                        ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                                        ctx.fill();
                                    } else if (p.isEnergyBurst) {
                                        // Portuguese Spirit energy burst particles
                                        const size = Math.max(0.1, p.size * f);
                                        const sparkle = Math.sin(p.t * 0.02) * 0.4 + 0.6;
                                        ctx.shadowBlur = 8;
                                        ctx.shadowColor = `rgba(22, 163, 74, ${a * sparkle})`;
                                        const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, Math.max(0.1, size));
                                        g.addColorStop(0, `rgba(255, 255, 255, ${a * sparkle})`); // White center
                                        g.addColorStop(0.5, `rgba(22, 163, 74, ${a * 0.8})`); // Green
                                        g.addColorStop(1, `rgba(220, 38, 38, ${a * 0.4})`); // Red edge
                                        ctx.fillStyle = g;
                                        ctx.beginPath();
                                        ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                                        ctx.fill();
                                    } else {
                                        // Regular tackle particles
                                        const sparkle = Math.sin(p.t * 0.01) * 0.3 + 0.7;
                                        ctx.shadowBlur = 8;
                                        ctx.shadowColor = `rgba(255, 215, 0, ${a * 0.6})`;
                                        const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, Math.max(0.1, p.size * 3));
                                        g.addColorStop(0, `rgba(255, 215, 0, ${a * sparkle})`); // Gold
                                        g.addColorStop(0.5, `rgba(255, 255, 255, ${a * 0.6})`); // White shimmer
                                        g.addColorStop(1, `rgba(255, 165, 0, 0)`); // Orange fade
                                        ctx.fillStyle = g;
                                        ctx.beginPath();
                                        ctx.arc(p.x, p.y, p.size * sparkle, 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                    
                                    ctx.restore();
                                }
                                vfx.cristianoGoatTackleParticles = vfx.cristianoGoatTackleParticles.filter(p => p.t < p.life);

                                // Portuguese Spirit Aura - Portuguese flag colors swirling
                                for(const aura of vfx.cristianoPortugueseSpiritAura){
                                    aura.t += dt;
                                    const f = 1 - aura.t / aura.life;
                                    const a = f * 0.4;
                                    const pulse = Math.sin(aura.t * 0.005) * 0.3 + 0.7;
                                    
                                    ctx.save();
                                    ctx.translate(aura.x, aura.y);
                                    
                                    // Portuguese flag inspired rotating aura
                                    const rotation = aura.t * 0.002;
                                    for(let ring = 0; ring < 3; ring++){
                                        const radius = aura.radius * (0.5 + ring * 0.25) * pulse;
                                        const ringOpacity = a * (1 - ring * 0.3);
                                        
                                        // Red section
                                        const redGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                                        redGradient.addColorStop(0, `rgba(220, 20, 60, ${ringOpacity})`);
                                        redGradient.addColorStop(1, `rgba(220, 20, 60, 0)`);
                                        ctx.fillStyle = redGradient;
                                        
                                        ctx.beginPath();
                                        ctx.arc(0, 0, radius, rotation, rotation + Math.PI);
                                        ctx.fill();
                                        
                                        // Green section
                                        const greenGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                                        greenGradient.addColorStop(0, `rgba(34, 139, 34, ${ringOpacity})`);
                                        greenGradient.addColorStop(1, `rgba(34, 139, 34, 0)`);
                                        ctx.fillStyle = greenGradient;
                                        
                                        ctx.beginPath();
                                        ctx.arc(0, 0, radius, rotation + Math.PI, rotation + Math.PI * 2);
                                        ctx.fill();
                                    }
                                    
                                    ctx.restore();
                                }
                                vfx.cristianoPortugueseSpiritAura = vfx.cristianoPortugueseSpiritAura.filter(aura => aura.t < aura.life);

                                // Movement Trail - Dynamic red/green speed lines
                                for(const trail of vfx.cristianoMovementTrail){
                                    trail.t += dt;
                                    const f = 1 - trail.t / trail.life;
                                    const a = f * 0.7;
                                    
                                    // Validate coordinates before creating gradient
                                    if (isFinite(trail.x) && isFinite(trail.y) && isFinite(trail.vx) && isFinite(trail.vy)) {
                                        // Update position for energy burst particles
                                        if (trail.isEnergyBurst || trail.isPowerShotExplosion) {
                                            trail.x += trail.vx * (dt/16);
                                            trail.y += trail.vy * (dt/16);
                                            trail.vx *= 0.98;
                                            trail.vy *= 0.98;
                                            
                                            // Draw as particles instead of trails for energy bursts
                                            const size = Math.max(0.1, trail.size * f);
                                            const g = ctx.createRadialGradient(trail.x, trail.y, 0, trail.x, trail.y, Math.max(0.1, size));
                                            if (trail.isEnergyBurst) {
                                                g.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                                                g.addColorStop(0.5, `rgba(22, 163, 74, ${a * 0.8})`);
                                                g.addColorStop(1, `rgba(220, 38, 38, ${a * 0.4})`);
                                            } else {
                                                g.addColorStop(0, `rgba(255, 255, 255, ${a})`);
                                                g.addColorStop(0.5, `rgba(255, 50, 50, ${a * 0.8})`);
                                                g.addColorStop(1, `rgba(255, 215, 0, ${a * 0.6})`);
                                            }
                                            ctx.fillStyle = g;
                                            ctx.beginPath();
                                            ctx.arc(trail.x, trail.y, size, 0, Math.PI * 2);
                                            ctx.fill();
                                        } else if (trail.startX && trail.startY && trail.endX && trail.endY && 
                                                 isFinite(trail.startX) && isFinite(trail.startY) && isFinite(trail.endX) && isFinite(trail.endY)) {
                                            // Draw as trail lines for regular movement trails
                                            const g = ctx.createLinearGradient(trail.startX, trail.startY, trail.endX, trail.endY);
                                            g.addColorStop(0, `rgba(220, 20, 60, ${a})`); // Red
                                            g.addColorStop(0.5, `rgba(255, 255, 255, ${a * 0.5})`); // White
                                            g.addColorStop(1, `rgba(34, 139, 34, ${a})`); // Green
                                            
                                            ctx.strokeStyle = g;
                                            ctx.lineWidth = 4;
                                            ctx.lineCap = 'round';
                                            ctx.beginPath();
                                            ctx.moveTo(trail.startX, trail.startY);
                                            ctx.lineTo(trail.endX, trail.endY);
                                            ctx.stroke();
                                        }
                                    }
                                }
                                vfx.cristianoMovementTrail = vfx.cristianoMovementTrail.filter(trail => trail.t < trail.life);

                            }



                            // NEW BABY OIL GUY ABILITY FUNCTIONS
                            function tryDiddyBabyOilAscension() {
                                const now = performance.now();
                                if (currentStyle !== 'diddy') return;

                                // Check if player has ball - can only use when NOT having ball
                                if (player.hasBall) {
                                    showNotification('cant use baby oil ascension while holding ball', 'error');
                                    return;
                                }

                                // Check cooldown
                                if (now < diddyBabyOilReadyAt) {
                                    const cooldownLeft = Math.ceil((diddyBabyOilReadyAt - now) / 1000);
                                    showNotification(`Baby Oil Ascension on cooldown for ${cooldownLeft}s`, 'error');
                                    return;
                                }

                                if (player.diddyBabyOilActive) return;

                                // Start the baby oil sequence
                                player.diddyBabyOilActive = true;
                                player.diddyBabyOilPhase = 'subtitle1';
                                player.diddyBabyOilStartTime = now;

                                // Show first subtitle with typewriter effect
                                showBabyOilGuySubtitle('Yo theres the ball! baby oil help me!', () => {
                                    player.diddyBabyOilPhase = 'running';

                                    // Auto teleport to ball after subtitle
                                    const distance = Math.sqrt((ball.x - player.x) ** 2 + (ball.y - player.y) ** 2);
                                    const teleportSteps = 15;
                                    const stepX = (ball.x - player.x) / teleportSteps;
                                    const stepY = (ball.y - player.y) / teleportSteps;

                                    let step = 0;
                                    const teleportInterval = setInterval(() => {
                                        if (step < teleportSteps) {
                                            player.x += stepX;
                                            player.y += stepY;

                                            // Add oil particle trail during teleport
                                            vfx.diddyOilParticles.push({
                                                x: player.x + (Math.random() - 0.5) * 20,
                                                y: player.y + (Math.random() - 0.5) * 20,
                                                vx: (Math.random() - 0.5) * 3,
                                                vy: (Math.random() - 0.5) * 3,
                                                life: 800,
                                                t: 0,
                                                r: 2 + Math.random() * 3,
                                                opacity: 0.8
                                            });
                                            step++;
                                        } else {
                                            clearInterval(teleportInterval);

                                            // Grab the ball and start ascension
                                            player.hasBall = true;
                                            ball.vx = 0;
                                            ball.vy = 0;

                                            player.diddyBabyOilPhase = 'ascension';

                                            // Create dramatic ascension effects
                                            for(let i = 0; i < 20; i++){
                                                vfx.diddyAscensionVFX.push({
                                                    x: ball.x + (Math.random() - 0.5) * 50,
                                                    y: ball.y + (Math.random() - 0.5) * 50,
                                                    speed: 1 + Math.random() * 2,
                                                    life: 1500 + Math.random() * 500,
                                                    t: 0,
                                                    r: 8 + Math.random() * 6
                                                });
                                            }

                                            // Ball ascends with golden glow
                                            setTimeout(() => {
                                                player.diddyBabyOilPhase = 'subtitle2';
                                                showBabyOilGuySubtitle('Thanks baby oil :D)', () => {
                                                    player.diddyBabyOilActive = false;
                                                    player.diddyBabyOilPhase = '';
                                                });
                                            }, 1000);
                                        }
                                    }, 50); // 50ms per step for smooth teleport
                                });

                                diddyBabyOilReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function tryDiddySlickShot() {
                                const now = performance.now();
                                if (currentStyle !== 'diddy') return;

                                if (now < diddySlickShotReadyAt) {
                                    const cooldownLeft = Math.ceil((diddySlickShotReadyAt - now) / 1000);
                                    showNotification(`Slick Shot on cooldown for ${cooldownLeft}s`, 'error');
                                    return;
                                }

                                if (!player.hasBall) {
                                    showNotification('Need ball for Slick Shot!', 'error');
                                    return;
                                }

                                // Fire slippery shot
                                const shootDir = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                                ball.vx = Math.cos(shootDir) * DIDDY_SLICK_SHOT_POWER + player.vx * 0.2;
                                ball.vy = Math.sin(shootDir) * DIDDY_SLICK_SHOT_POWER + player.vy * 0.2;

                                // Add oil trail to ball
                                ball.hasOilTrail = true;
                                ball.oilTrailEndTime = now + 1000;

                                player.hasBall = false;
                                diddySlickShotReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function tryDiddyOilSlickTrap() {
                                const now = performance.now();
                                if (currentStyle !== 'diddy') return;

                                if (now < diddyOilSlickReadyAt) {
                                    const cooldownLeft = Math.ceil((diddyOilSlickReadyAt - now) / 1000);
                                    showNotification(`Baby Oil Blindness on cooldown for ${cooldownLeft}s`, 'error');
                                    return;
                                }

                                // Create oil slick at mouse position with burst effect
                                vfx.diddyOilSlicks.push({
                                    x: mouse.x,
                                    y: mouse.y,
                                    radius: 80,
                                    t: 0,
                                    life: DIDDY_OIL_SLICK_DURATION,
                                    opacity: 0.7
                                });

                                // Create oil burst particles
                                for(let i = 0; i < 25; i++){
                                    const angle = (Math.PI * 2 * i) / 25;
                                    vfx.diddyOilParticles.push({
                                        x: mouse.x,
                                        y: mouse.y,
                                        vx: Math.cos(angle) * (2 + Math.random() * 3),
                                        vy: Math.sin(angle) * (2 + Math.random() * 3),
                                        life: 1200 + Math.random() * 600,
                                        t: 0,
                                        r: 2 + Math.random() * 3,
                                        opacity: 0.8
                                    });
                                }

                                player.diddyOilSlickActive = true;
                                player.diddyOilSlickEndTime = now + DIDDY_OIL_SLICK_DURATION;

                                diddyOilSlickReadyAt = now + ABILITY_COOLDOWN;
                            }

                            // CRISTIANO ABILITY FUNCTIONS
                            function tryCristianoPowerShot() {
                                const now = performance.now();
                                if (currentStyle !== 'cristiano') return;
                                
                                if (now < cristianoPowerShotReadyAt) {
                                    const cooldownLeft = Math.ceil((cristianoPowerShotReadyAt - now) / 1000);
                                    showNotification(`Power Shot on cooldown for ${cooldownLeft}s`, 'error');
                                    return;
                                }

                                if (!player.hasBall) {
                                    showNotification('Need ball to use Power Shot!', 'error');
                                    return;
                                }

                                // Extremely powerful unblockable shot
                                const shotPower = CRISTIANO_POWER_SHOT_POWER + (player.cristianoPortugueseSpiritActive ? CRISTIANO_PORTUGUESE_SPIRIT_SHOT_POWER_BONUS : 0);
                                const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                                
                                ball.vx = Math.cos(angle) * shotPower;
                                ball.vy = Math.sin(angle) * shotPower;
                                ball.maxSpeed = 100000; // Remove speed cap for power shot
                                ball.isUnblockable = true; // Special property for unblockable shots
                                ball.isCristianoPowerShot = true; // Enhanced shot marker
                                
                                player.hasBall = false;
                                
                                // Enhanced power shot trail VFX - multiple trails
                                for (let i = 0; i < 3; i++) {
                                    vfx.cristianoPowerShotTrail.push({
                                        startX: player.x + (Math.random() - 0.5) * 10,
                                        startY: player.y + (Math.random() - 0.5) * 10,
                                        endX: player.x + Math.cos(angle) * (250 + i * 50),
                                        endY: player.y + Math.sin(angle) * (250 + i * 50),
                                        life: 1200 + i * 200,
                                        t: 0,
                                        intensity: 1 - i * 0.2
                                    });
                                }
                                
                                // Create charging explosion effect at player position
                                for (let i = 0; i < 20; i++) {
                                    const explosionAngle = (Math.PI * 2 * i) / 20;
                                    vfx.cristianoMovementTrail.push({
                                        x: player.x,
                                        y: player.y,
                                        vx: Math.cos(explosionAngle) * 12,
                                        vy: Math.sin(explosionAngle) * 12,
                                        life: 600,
                                        t: 0,
                                        size: Math.random() * 6 + 4,
                                        isPowerShotExplosion: true
                                    });
                                }
                                
                                // Screen shake effect for power
                                if (typeof screenShake !== 'undefined') {
                                    screenShake(15, 300);
                                }
                                
                            shockwave(player.x, player.y, 40, 'cristiano');

                                // Reset ball speed after power shot
                                setTimeout(() => {
                                    ball.maxSpeed = 18;
                                }, 800);

                                showNotification('CRISTIANO POWER SHOT! DEVASTATING FORCE!', 'success');
                                cristianoPowerShotReadyAt = now + ABILITY_COOLDOWN;
                            }


                            function tryCristianoGoatTackle() {
                                const now = performance.now();
                                if (currentStyle !== 'cristiano') return;
                                
                                if (now < cristianoGoatTackleReadyAt) {
                                    const cooldownLeft = Math.ceil((cristianoGoatTackleReadyAt - now) / 1000);
                                    showNotification(`GOAT's Tackle on cooldown for ${cooldownLeft}s`, 'error');
                                    return;
                                }

                                const distanceToBall = Math.hypot(ball.x - player.x, ball.y - player.y);
                                const distanceToAI = aiEnabled ? Math.hypot(aiPlayer.x - player.x, aiPlayer.y - player.y) : Infinity;
                                
                                // Check if we can tackle the ball or steal from AI
                                const canTackleBall = distanceToBall <= CRISTIANO_GOAT_TACKLE_RANGE && !player.hasBall && !aiPlayer.hasBall;
                                const canStealFromAI = aiEnabled && aiPlayer.hasBall && distanceToAI <= CRISTIANO_GOAT_TACKLE_RANGE;
                                
                                if (!canTackleBall && !canStealFromAI) {
                                    if (player.hasBall) {
                                        showNotification("Already have the ball!", 'error');
                                    } else if (aiPlayer.hasBall) {
                                        showNotification(`Too far from AI! Must be within ${Math.floor(CRISTIANO_GOAT_TACKLE_RANGE)}px`, 'error');
                                    } else {
                                        showNotification(`Too far from ball! Must be within ${Math.floor(CRISTIANO_GOAT_TACKLE_RANGE)}px`, 'error');
                                    }
                                    return;
                                }

                                const oldX = player.x;
                                const oldY = player.y;
                                
                                if (canStealFromAI) {
                                    // Steal from AI - teleport to AI and take ball
                                    const angle = Math.atan2(aiPlayer.y - player.y, aiPlayer.x - player.x);
                                    player.x = aiPlayer.x - Math.cos(angle) * (player.r + aiPlayer.r + 10);
                                    player.y = aiPlayer.y - Math.sin(angle) * (player.r + aiPlayer.r + 10);
                                    
                                    // Stun AI player
                                    aiPlayer.hasBall = false;
                                    aiPlayer.isStunned = true;
                                    aiPlayer.stunEndTime = now + 2000; // 2 second stun
                                    
                                    // Take possession
                                    player.hasBall = true;
                                    ball.x = player.x + player.r + ball.r + 2;
                                    ball.y = player.y;
                                    ball.vx = 0;
                                    ball.vy = 0;
                                    
                                    showNotification("GOAT's Tackle! Ball stolen from AI!", 'success');
                                } else if (canTackleBall) {
                                    // Regular ball tackle - teleport to ball
                                    const angle = Math.atan2(ball.y - player.y, ball.x - player.x);
                                    player.x = ball.x - Math.cos(angle) * (player.r + ball.r + 8);
                                    player.y = ball.y - Math.sin(angle) * (player.r + ball.r + 8);
                                    
                                    // Take possession
                                    player.hasBall = true;
                                    ball.vx = 0;
                                    ball.vy = 0;
                                    
                                    showNotification("GOAT's Tackle! Ball secured!", 'success');
                                }

                                // Enhanced tackle burst effect
                                for (let i = 0; i < 25; i++) {
                                    vfx.cristianoGoatTackleParticles.push({
                                        x: oldX,
                                        y: oldY,
                                        vx: (Math.random() - 0.5) * 18,
                                        vy: (Math.random() - 0.5) * 18,
                                        life: 1200,
                                        t: 0,
                                        size: Math.random() * 8 + 4
                                    });
                                }

                                // Create golden explosion effect at tackle location
                                for (let i = 0; i < 15; i++) {
                                    const angle = (Math.PI * 2 * i) / 15;
                                    vfx.cristianoGoatTackleParticles.push({
                                        x: player.x,
                                        y: player.y,
                                        vx: Math.cos(angle) * 10,
                                        vy: Math.sin(angle) * 10,
                                        life: 800,
                                        t: 0,
                                        size: Math.random() * 6 + 6,
                                        isExplosion: true
                                    });
                                }

                                cristianoGoatTackleReadyAt = now + ABILITY_COOLDOWN;
                            }

                            function tryCristianoPortugueseSpirit() {
                                const now = performance.now();
                                if (currentStyle !== 'cristiano') return;
                                
                                if (now < cristianoPortugueseSpiritReadyAt) {
                                    const cooldownLeft = Math.ceil((cristianoPortugueseSpiritReadyAt - now) / 1000);
                                    showNotification(`Portuguese Spirit on cooldown for ${cooldownLeft}s`, 'error');
                                    return;
                                }

                                // Activate Portuguese Spirit boost with enhanced effects
                                player.cristianoPortugueseSpiritActive = true;
                                player.cristianoPortugueseSpiritEndTime = now + CRISTIANO_PORTUGUESE_SPIRIT_DURATION;
                                player.maxSpd *= CRISTIANO_PORTUGUESE_SPIRIT_SPEED_MULTIPLIER;

                                // Add multiple layered Portuguese Spirit aura VFX
                                vfx.cristianoPortugueseSpiritAura.push({
                                    x: player.x,
                                    y: player.y,
                                    radius: player.r * 4,
                                    life: CRISTIANO_PORTUGUESE_SPIRIT_DURATION,
                                    t: 0,
                                    layer: 'outer'
                                });
                                
                                vfx.cristianoPortugueseSpiritAura.push({
                                    x: player.x,
                                    y: player.y,
                                    radius: player.r * 2.5,
                                    life: CRISTIANO_PORTUGUESE_SPIRIT_DURATION,
                                    t: 0,
                                    layer: 'inner'
                                });

                                // Create energy burst effect
                                for (let i = 0; i < 30; i++) {
                                    const angle = (Math.PI * 2 * i) / 30;
                                    vfx.cristianoMovementTrail.push({
                                        x: player.x + Math.cos(angle) * player.r,
                                        y: player.y + Math.sin(angle) * player.r,
                                        vx: Math.cos(angle) * 8,
                                        vy: Math.sin(angle) * 8,
                                        life: 1000,
                                        t: 0,
                                        size: Math.random() * 4 + 3,
                                        isEnergyBurst: true
                                    });
                                }

                                showNotification('Portuguese Spirit ACTIVATED! Unstoppable power unleashed!', 'success');
                                cristianoPortugueseSpiritReadyAt = now + 15000; // 15 second cooldown
                            }

                            // Baby Oil Guy subtitle system with typewriter effect
                            function showBabyOilGuySubtitle(text, callback) {
                                const subtitleEl = document.getElementById('baby-oil-guy-subtitles');
                                const textEl = document.getElementById('subtitle-text');

                                subtitleEl.style.display = 'block';
                                textEl.textContent = '';

                                let charIndex = 0;
                                const typeInterval = setInterval(() => {
                                    if (charIndex < text.length) {
                                        textEl.textContent += text[charIndex];
                                        charIndex++;
                                    } else {
                                        clearInterval(typeInterval);
                                        setTimeout(() => {
                                            subtitleEl.style.display = 'none';
                                            if (callback) callback();
                                        }, 1000);
                                    }
                                }, 50); // 50ms per character for typewriter effect
                            }

                            function roundRect(ctx, x, y, width, height, radius) {
                                ctx.beginPath();
                                ctx.moveTo(x + radius, y);
                                ctx.lineTo(x + width - radius, y);
                                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                                ctx.lineTo(x + width, y + height - radius);
                                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                                ctx.lineTo(x + radius, y + height);
                                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                                ctx.lineTo(x, y + radius);
                                ctx.quadraticCurveTo(x, y, x + radius, y);
                                ctx.closePath();
                            }
                        </script>
                    </body>
                    </html>
